<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2020 Zhouhang Zhou. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Zhouhang Zhou</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import measure_theory.bochner_integration</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import measure_theory.indicator_function</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import measure_theory.lebesgue_measure</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/lebesgue_measure.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  # Set integral</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  Integrate a function over a subset of a measure space.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  ## Main definition</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  `measurable_on`, `integrable_on`, `integral_on`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  ## Tags</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  indicator, characteristic</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  open_locale classical topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  open set lattice filter topological_space ennreal emetric measure_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  set_option class.instance_max_depth 50</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='(class) max allowed depth in class-instance resolution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  universes u v w</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  variables {α : Type u} {β : Type v} {γ : Type w}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  section measurable_on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  variables [measurable_space α] [measurable_space β] [has_zero β] {s : set α} {f : α → β}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  /-- `measurable_on s f` means `f` is measurable over the set `s`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  @[reducible]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  def measurable_on (s : set α) (f : α → β) : Prop := measurable (indicator s f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  lemma measurable_on_empty : measurable_on ∅ f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  by { rw [measurable_on, indicator_empty], exact measurable_const }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measurable_space.{?l_1} α] [_inst_2 : measurable_space.{?l_2} β] [_inst_3 : has_zero.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β] (f : α → β), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β _inst_1 (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f) (λ (a : α), @has_zero.zero.{v} β _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type u} [_inst_1 : measurable_space.{v} α] [_inst_2 : measurable_space.{u} β] {a : α}, @measurable.{u v} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
f : α → β
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
f : α → β
⊢ @measurable.{u v} α β _inst_1 _inst_2
    (@set.indicator.{u v} α β _inst_3 (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
f : α → β
⊢ @measurable.{u v} α β _inst_1 _inst_2 (λ (a : α), @has_zero.zero.{v} β _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  lemma measurable_on_univ (hf : measurable f) : measurable_on univ f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  hf.if is_measurable.univ measurable_const</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measurable.if'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_measurable.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 376, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] {p : α → Prop} {h : @decidable_pred.{u+1} α p} {f g : α → β}, @is_measurable.{u} α _inst_1 (@set_of.{u} α (λ (a : α), p a)) → @measurable.{u v} α β _inst_1 _inst_2 f → @measurable.{u v} α β _inst_1 _inst_2 g → @measurable.{u v} α β _inst_1 _inst_2 (λ (a : α), @ite.{v+1} (p a) (h a) β (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measurable_space.{u} α], @is_measurable.{u} α _inst_1 (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {β : Type u} [_inst_1 : measurable_space.{v} α] [_inst_2 : measurable_space.{u} β] {a : α}, @measurable.{u v} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  lemma measurable.measurable_on (hs : is_measurable s) (hf : measurable f) : measurable_on s f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 360, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [m₁ : measurable_space.{u} α] [m₂ : measurable_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A function `f` between measurable spaces is measurable if the preimage of every
 measurable set is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  hf.if hs measurable_const</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measurable.if'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 376, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable.{u v} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] {p : α → Prop} {h : @decidable_pred.{u+1} α p} {f g : α → β}, @is_measurable.{u} α _inst_1 (@set_of.{u} α (λ (a : α), p a)) → @measurable.{u v} α β _inst_1 _inst_2 f → @measurable.{u v} α β _inst_1 _inst_2 g → @measurable.{u v} α β _inst_1 _inst_2 (λ (a : α), @ite.{v+1} (p a) (h a) β (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {β : Type u} [_inst_1 : measurable_space.{v} α] [_inst_2 : measurable_space.{u} β] {a : α}, @measurable.{u v} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  lemma is_measurable.inter_preimage {B : set β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    (hs : is_measurable s) (hB : is_measurable B) (hf : measurable_on s f):</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    is_measurable (s ∩ f ⁻¹&#x27; B) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{v} β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    replace hf : is_measurable ((indicator s f)⁻¹&#x27; B) := hf B hB,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    rw indicator_preimage at hf,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    replace hf := hf.diff _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    rwa union_diff_cancel_right at hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.union_diff_cancel_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 696, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) → @eq.{u+1} (set.{u} α) (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α)
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
             (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
             (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
       ?m_1)
⊢ @is_measurable.{u} α _inst_1
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))

α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ set.{u} α

α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @is_measurable.{u} α _inst_1 ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α)
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
             (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
             (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))

α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @is_measurable.{u} α _inst_1
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
       (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    { assume a, simp {contextual := tt} },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α)
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
             (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
             (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))

α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @is_measurable.{u} α _inst_1
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
       (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α)
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
             (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
             (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α)
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
          (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
             (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
             (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B))),
a : α
⊢ @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B))) →
  @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @is_measurable.{u} α _inst_1
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
       (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59    exact hs.compl.inter (measurable_const.preimage hB)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {β : Type u} [_inst_1 : measurable_space.{v} α] [_inst_2 : measurable_space.{u} β] {a : α}, @measurable.{u v} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{v} β _inst_2 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
B : set.{v} β,
hs : @is_measurable.{u} α _inst_1 s,
hB : @is_measurable.{v} β _inst_2 B,
hf :
  @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))
⊢ @is_measurable.{u} α _inst_1
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s)
       (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  lemma measurable_on.subset {t : set α} (hs : is_measurable s) (h : s ⊆ t) (hf : measurable_on t f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    measurable_on s f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    have : measurable_on s (indicator t f) := measurable.measurable_on hs hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measurable.measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 47, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β] {s : set.{u} α} {f : α → β}, @is_measurable.{u} α _inst_1 s → @measurable.{u v} α β _inst_1 _inst_2 f → @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
this : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s (@set.indicator.{u v} α β _inst_3 t f)
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    simp only [measurable_on, indicator_indicator] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measurable_space.{?l_1} α] [_inst_2 : measurable_space.{?l_2} β] [_inst_3 : has_zero.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : has_zero.{?l_2} β] (s t : set.{?l_1} α) (f : α → β), @eq.{(max (?l_1+1) (?l_2+1))} (α → β) (@set.indicator.{?l_1 ?l_2} α β _inst_1 s (@set.indicator.{?l_1 ?l_2} α β _inst_1 t f)) (@set.indicator.{?l_1 ?l_2} α β _inst_1 (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) s t) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
this : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s (@set.indicator.{u v} α β _inst_3 t f)
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
this :
  @measurable.{u v} α β _inst_1 _inst_2
    (@set.indicator.{u v} α β _inst_3 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) f)
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    rwa [inter_eq_self_of_subset_left h] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.inter_eq_self_of_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 411, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
this :
  @measurable.{u v} α β _inst_1 _inst_2
    (@set.indicator.{u v} α β _inst_3 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) f)
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
this : @measurable.{u v} α β _inst_1 _inst_2 (@set.indicator.{u v} α β _inst_3 s f)
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s : set.{u} α,
f : α → β,
t : set.{u} α,
hs : @is_measurable.{u} α _inst_1 s,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t,
hf : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
this :
  @measurable.{u v} α β _inst_1 _inst_2
    (@set.indicator.{u v} α β _inst_3 (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t) f)
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  lemma measurable_on.union {t : set α} {f : α → β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    (hs : is_measurable s) (ht : is_measurable t) (hsm : measurable_on s f) (htm : measurable_on t f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    measurable_on (s ∪ t) f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    assume B hB,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f
⊢ @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @measurable_space.is_measurable.{v} β
    (@measurable_space.map.{u v} α β
       (@set.indicator.{u v} α β _inst_3 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f)
       _inst_1)
    B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    show is_measurable ((indicator (s ∪ t) f)⁻¹&#x27; B),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → set.{v} β → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @measurable_space.is_measurable.{v} β
    (@measurable_space.map.{u v} α β
       (@set.indicator.{u v} α β _inst_3 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f)
       _inst_1)
    B'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@set.preimage.{u v} α β
       (@set.indicator.{u v} α β _inst_3 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f)
       B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    rw indicator_preimage,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.indicator_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β] (s : set.{u} α) (f : α → β) (B : set.{v} β), @eq.{(max (u+1) 1)} (set.{u} α) (@set.preimage.{u v} α β (@set.indicator.{u v} α β _inst_1 s f) B) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B)) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α) s) (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_1) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@set.preimage.{u v} α β
       (@set.indicator.{u v} α β _inst_3 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f)
       B)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
             (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t))
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    refine is_measurable.union _ ((hs.union ht).compl.inter (measurable_const.preimage hB)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_measurable.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measurable_space.{u} α] {s₁ s₂ : set.{u} α}, @is_measurable.{u} α _inst_1 s₁ → @is_measurable.{u} α _inst_1 s₂ → @is_measurable.{u} α _inst_1 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_measurable.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u} α _inst_1 t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} {β : Type u} [_inst_1 : measurable_space.{v} α] [_inst_2 : measurable_space.{u} β] {a : α}, @measurable.{u v} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_space.is_measurable.{v} β _inst_2 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
          (@has_neg.neg.{u} (set.{u} α) (@set.has_neg.{u} α)
             (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t))
          (@set.preimage.{u v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
       (@set.preimage.{u v} α β f B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    simp only [union_inter_distrib_right],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.union_inter_distrib_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 717, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t u : set.{?l_1} α}, @eq.{?l_1+1} (set.{?l_1} α) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) (@has_union.union.{?l_1} (set.{?l_1} α) (@set.has_union.{?l_1} α) s t) u) (@has_union.union.{?l_1} (set.{?l_1} α) (@set.has_union.{?l_1} α) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) s u) (@has_inter.inter.{?l_1} (set.{?l_1} α) (@set.has_inter.{?l_1} α) t u))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α)
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
       (@set.preimage.{u v} α β f B))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t (@set.preimage.{u v} α β f B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    exact (hs.inter_preimage hB hsm).union (ht.inter_preimage hB htm)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hB'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_measurable.{u} α _inst_1 t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_space.is_measurable.{v} β _inst_2 B'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measurable_space.{u} α,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α _inst_1 s,
ht : @is_measurable.{u} α _inst_1 t,
hsm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 s f,
htm : @measurable_on.{u v} α β _inst_1 _inst_2 _inst_3 t f,
B : set.{v} β,
hB : @measurable_space.is_measurable.{v} β _inst_2 B
⊢ @is_measurable.{u} α _inst_1
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α)
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s (@set.preimage.{u v} α β f B))
       (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) t (@set.preimage.{u v} α β f B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  lemma measurable_on_singleton {α} [topological_space α] [t1_space α] {a : α} {f : α → β} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='topological_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='t1_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : topological_space.{u_1} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='A topology on `α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A T₁ space, also known as a Fréchet space, is a topological space
 where every singleton set is closed. Equivalently, for every pair
 `x ≠ y`, there is an open set containing `x` and not `y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    measurable_on {a} f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [_inst_1 : has_emptyc.{u_1} γ] [_inst_2 : has_insert.{u_1 u_1} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  λ s hs, show is_measurable ((indicator _ _)⁻¹&#x27; s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_space.is_measurable.{v} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {β : Type v} [_inst_1 : has_zero.{v} β], set.{u_1} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} {β : Type v}, (α → β) → set.{v} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@set.preimage.{u_1 v} α β
       (@set.indicator.{u_1 v} α β _inst_3
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
          f)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    rw indicator_preimage,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.indicator_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type v} [_inst_1 : has_zero.{v} β] (s : set.{u_1} α) (f : α → β) (B : set.{v} β), @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@set.preimage.{u_1 v} α β (@set.indicator.{u_1 v} α β _inst_1 s f) B) (@has_union.union.{u_1} (set.{u_1} α) (@set.has_union.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s (@set.preimage.{u_1 v} α β f B)) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) (@has_neg.neg.{u_1} (set.{u_1} α) (@set.has_neg.{u_1} α) s) (@set.preimage.{u_1 v} α β (λ (a : α), @has_zero.zero.{v} β _inst_1) B)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@set.preimage.{u_1 v} α β
       (@set.indicator.{u_1 v} α β _inst_3
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
          f)
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_union.union.{u_1} (set.{u_1} α) (@set.has_union.{u_1} α)
       (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
          (@set.preimage.{u_1 v} α β f s))
       (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
          (@has_neg.neg.{u_1} (set.{u_1} α) (@set.has_neg.{u_1} α)
             (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a))
          (@set.preimage.{u_1 v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    refine is_measurable.union _ (is_measurable_singleton.compl.inter $ measurable_const.preimage hs),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_measurable.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='is_measurable_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measurable_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 143, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α] {s₁ s₂ : set.{u_1} α}, @is_measurable.{u_1} α _inst_1 s₁ → @is_measurable.{u_1} α _inst_1 s₂ → @is_measurable.{u_1} α _inst_1 (@has_union.union.{u_1} (set.{u_1} α) (@set.has_union.{u_1} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] [_inst_2 : @t1_space.{u_1} α _inst_1] {x : α}, @is_measurable.{u_1} α (@borel.{u_1} α _inst_1) (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type u_1} [_inst_1 : measurable_space.{v} α] [_inst_2 : measurable_space.{u_1} β] {a : α}, @measurable.{u_1 v} β α _inst_2 _inst_1 (λ (b : β), a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_space.is_measurable.{v} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_union.union.{u_1} (set.{u_1} α) (@set.has_union.{u_1} α)
       (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
          (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
          (@set.preimage.{u_1 v} α β f s))
       (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
          (@has_neg.neg.{u_1} (set.{u_1} α) (@set.has_neg.{u_1} α)
             (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a))
          (@set.preimage.{u_1 v} α β (λ (a : α), @has_zero.zero.{v} β _inst_3) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    by_cases h : a ∈ f⁻¹&#x27; s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type v}, (α → β) → set.{v} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))

β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s))
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    { rw inter_eq_self_of_subset_left,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.inter_eq_self_of_subset_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 411, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {s t : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s t → @eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))

β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s))
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)

β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α)
    (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
    (@set.preimage.{u_1 v} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90      { exact is_measurable_singleton },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='is_measurable_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 143, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] [_inst_2 : @t1_space.{u_1} α _inst_1] {x : α}, @is_measurable.{u_1} α (@borel.{u_1} α _inst_1) (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)

β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α)
    (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
    (@set.preimage.{u_1 v} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α)
    (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
    (@set.preimage.{u_1 v} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91      rwa singleton_subset_iff },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.singleton_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 535, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} {s : set.{u_1} α}, iff (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a) s) (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s)
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α)
    (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
    (@set.preimage.{u_1 v} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s))
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    rw [singleton_inter_eq_empty.2 h],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.singleton_inter_eq_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 547, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} {s : set.{u_1} α}, iff (@eq.{u_1+1} (set.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a) s) (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))) (not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s))
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α)
       (@singleton.{u_1 u_1} α (set.{u_1} α) (@set.has_emptyc.{u_1} α) (@set.has_insert.{u_1} α) a)
       (@set.preimage.{u_1 v} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s))
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    exact is_measurable.empty</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable.empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : measurable_space.{u_1} α], @is_measurable.{u_1} α _inst_1 (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_2 : measurable_space.{v} β,
_inst_3 : has_zero.{v} β,
α : Type u_1,
_inst_4 : topological_space.{u_1} α,
_inst_5 : @t1_space.{u_1} α _inst_4,
a : α,
f : α → β,
s : set.{v} β,
hs : @measurable_space.is_measurable.{v} β _inst_2 s,
h : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.preimage.{u_1 v} α β f s))
⊢ @is_measurable.{u_1} α (@borel.{u_1} α _inst_4)
    (@has_emptyc.emptyc.{u_1} (set.{u_1} α) (@set.has_emptyc.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  end measurable_on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  section integrable_on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  variables [measure_space α] [normed_group β] {s t : set α} {f g : α → β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.measure_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 801, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A measure space is a measurable space equipped with a
 measure, referred to as `volume`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  /-- `integrable_on s f` means `f` is integrable over the set `s`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  @[reducible]</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  def integrable_on (s : set α) (f : α → β) : Prop := integrable (indicator s f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='measure_theory.integrable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='A function is `integrable` if the integral of its pointwise norm is less than infinity.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  lemma integrable_on_congr (h : ∀x, x ∈ s → f x = g x) : integrable_on s f ↔ integrable_on s g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  by simp only [integrable_on, indicator_congr h]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β] {s : set.{u} α} {f g : α → β}, (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @eq.{v+1} β (f a) (g a)) → @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β _inst_1 s f) (@set.indicator.{u v} α β _inst_1 s g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
h : ∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x)
⊢ iff (@integrable_on.{u v} α β _inst_1 _inst_2 s f) (@integrable_on.{u v} α β _inst_1 _inst_2 s g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
h : ∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x)
⊢ iff (@integrable_on.{u v} α β _inst_1 _inst_2 s f) (@integrable_on.{u v} α β _inst_1 _inst_2 s g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  lemma integrable_on_congr_ae (h : ∀ₘx, x ∈ s → f x = g x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    integrable_on s f ↔ integrable_on s g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  by { apply integrable_congr_ae, exact indicator_congr_ae h }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.integrable_congr_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='indicator_congr_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] {f g : α → β}, @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @eq.{v+1} β (f a) (g a)) → iff (@measure_theory.integrable.{u v} α _inst_1 β _inst_2 f) (@measure_theory.integrable.{u v} α _inst_1 β _inst_2 g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β] {s : set.{u} α} {f g : α → β} [_inst_2 : measure_theory.measure_space.{u} α], @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @eq.{v+1} β (f a) (g a)) → @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), @eq.{v+1} β (@set.indicator.{u v} α β _inst_1 s f a) (@set.indicator.{u v} α β _inst_1 s g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.all_ae.{u} α _inst_1 (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x))
⊢ iff (@integrable_on.{u v} α β _inst_1 _inst_2 s f) (@integrable_on.{u v} α β _inst_1 _inst_2 s g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @eq.{v+1} β
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            g
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  lemma integrable_on_empty : integrable_on ∅ f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  by { simp only [integrable_on, indicator_empty], apply integrable_zero }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_empty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.integrable_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 150, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : has_zero.{?l_2} β] (f : α → β), @eq.{(max (?l_1+1) (?l_2+1))} (α → β) (@set.indicator.{?l_1 ?l_2} α β _inst_1 (@has_emptyc.emptyc.{?l_1} (set.{?l_1} α) (@set.has_emptyc.{?l_1} α)) f) (λ (a : α), @has_zero.zero.{?l_2} β _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type u) [_inst_1 : measure_theory.measure_space.{u} α] (β : Type v) [_inst_2 : normed_group.{v} β], @measure_theory.integrable.{u v} α _inst_1 β _inst_2 (λ (a : α), @has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
f : α → β
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
f : α → β
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @has_zero.zero.{v} β
         (@add_monoid.to_has_zero.{v} β
            (@add_group.to_add_monoid.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  lemma integrable_on_of_integrable (s : set α) (hf : integrable f) : integrable_on s f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.integrable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='A function is `integrable` if the integral of its pointwise norm is less than infinity.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  by { refine integrable_of_le (λa, _) hf, apply norm_indicator_le_norm_self }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='measure_theory.integrable_of_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='norm_indicator_le_norm_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 116, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] {γ : Type v} [_inst_3 : normed_group.{v} γ] {f : α → β} {g : α → γ}, (∀ (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)) (@has_norm.norm.{v} γ (@normed_group.to_has_norm.{v} γ _inst_3) (g a))) → @measure_theory.integrable.{u v} α _inst_1 γ _inst_3 g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.integrable.{u v} α _inst_1 β _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : normed_group.{v} β] {s : set.{u} α} (f : α → β) (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) s f a)) (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
f : α → β,
s : set.{u} α,
hf : @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
f : α → β,
s : set.{u} α,
hf : @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          f
          a))
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  lemma integrable_on.subset (h : s ⊆ t) : integrable_on t f → integrable_on s f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  by { apply integrable_of_le_ae, filter_upwards [] norm_indicator_le_of_subset h _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.integrable_of_le_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='norm_indicator_le_of_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] {γ : Type v} [_inst_3 : normed_group.{v} γ] {f : α → β} {g : α → γ}, @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)) (@has_norm.norm.{v} γ (@normed_group.to_has_norm.{v} γ _inst_3) (g a))) → @measure_theory.integrable.{u v} α _inst_1 γ _inst_3 g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : normed_group.{v} β] {s t : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → ∀ (f : α → β) (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) s f a)) (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) t f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 t f → @integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
h : @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_le.le.{0} real real.has_le
         (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               s
               f
               a))
         (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               t
               f
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  variables {𝕜 : Type*} [normed_field 𝕜] [normed_space 𝕜 β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) (β : Type v) [_inst_1 : normed_field.{u_1} α] [_inst_2 : normed_group.{v} β], Type (max u_1 v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A normed field is a field with a norm satisfying ∥x y∥ = ∥x∥ ∥y∥.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  lemma integrable_on.smul (s : set α) (c : 𝕜) {f : α → β} : integrable_on s f → integrable_on s (λa, c • f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='𝕜'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {γ : Type v} [c : has_scalar.{u_1 v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  by { simp only [integrable_on, indicator_smul], apply integrable.smul }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.integrable.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 361, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_monoid.{?l_2} β] {𝕜 : Type ?l_3} [_inst_2 : monoid.{?l_3} 𝕜] [_inst_3 : @distrib_mul_action.{?l_3 ?l_2} 𝕜 β _inst_2 _inst_1] (s : set.{?l_1} α) (r : 𝕜) (f : α → β), @eq.{(max (?l_1+1) (?l_2+1))} (α → β) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β _inst_1) s (λ (x : α), @has_scalar.smul.{?l_3 ?l_2} 𝕜 β (@mul_action.to_has_scalar.{?l_3 ?l_2} 𝕜 β _inst_2 (@distrib_mul_action.to_mul_action.{?l_3 ?l_2} 𝕜 β _inst_2 _inst_1 _inst_3)) r (f x))) (λ (x : α), @has_scalar.smul.{?l_3 ?l_2} 𝕜 β (@mul_action.to_has_scalar.{?l_3 ?l_2} 𝕜 β _inst_2 (@distrib_mul_action.to_mul_action.{?l_3 ?l_2} 𝕜 β _inst_2 _inst_1 _inst_3)) r (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β _inst_1) s f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] {𝕜 : Type u_1} [_inst_4 : normed_field.{u_1} 𝕜] [_inst_5 : @normed_space.{u_1 v} 𝕜 β _inst_4 _inst_2] (c : 𝕜) {f : α → β}, @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 (λ (a : α), @has_scalar.smul.{u_1 v} 𝕜 β (@mul_action.to_has_scalar.{u_1 v} 𝕜 β (@ring.to_monoid.{u_1} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_4))) (@distrib_mul_action.to_mul_action.{u_1 v} 𝕜 β (@ring.to_monoid.{u_1} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_4))) (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))) (@semimodule.to_distrib_mul_action.{u_1 v} 𝕜 β (@ring.to_semiring.{u_1} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_4))) (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)) (@module.to_semimodule.{u_1 v} 𝕜 β (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_4)) (@normed_group.to_add_comm_group.{v} β _inst_2) (@normed_space.to_module.{u_1 v} 𝕜 β _inst_4 _inst_2 _inst_5))))) c (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
𝕜 : Type u_1,
_inst_3 : normed_field.{u_1} 𝕜,
_inst_4 : @normed_space.{u_1 v} 𝕜 β _inst_3 _inst_2,
s : set.{u} α,
c : 𝕜,
f : α → β
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 s f →
  @integrable_on.{u v} α β _inst_1 _inst_2 s
    (λ (a : α),
       @has_scalar.smul.{u_1 v} 𝕜 β
         (@mul_action.to_has_scalar.{u_1 v} 𝕜 β
            (@ring.to_monoid.{u_1} 𝕜
               (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3)))
            (@distrib_mul_action.to_mul_action.{u_1 v} 𝕜 β
               (@ring.to_monoid.{u_1} 𝕜
                  (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3)))
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
               (@semimodule.to_distrib_mul_action.{u_1 v} 𝕜 β
                  (@ring.to_semiring.{u_1} 𝕜
                     (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3)))
                  (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                  (@module.to_semimodule.{u_1 v} 𝕜 β
                     (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3))
                     (@normed_group.to_add_comm_group.{v} β _inst_2)
                     (@normed_space.to_module.{u_1 v} 𝕜 β _inst_3 _inst_2 _inst_4)))))
         c
         (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
𝕜 : Type u_1,
_inst_3 : normed_field.{u_1} 𝕜,
_inst_4 : @normed_space.{u_1 v} 𝕜 β _inst_3 _inst_2,
s : set.{u} α,
c : 𝕜,
f : α → β
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (@set.indicator.{u v} α β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
       s
       f) →
  @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (x : α),
       @has_scalar.smul.{u_1 v} 𝕜 β
         (@mul_action.to_has_scalar.{u_1 v} 𝕜 β
            (@ring.to_monoid.{u_1} 𝕜
               (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3)))
            (@distrib_mul_action.to_mul_action.{u_1 v} 𝕜 β
               (@ring.to_monoid.{u_1} 𝕜
                  (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3)))
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
               (@semimodule.to_distrib_mul_action.{u_1 v} 𝕜 β
                  (@ring.to_semiring.{u_1} 𝕜
                     (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3)))
                  (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                  (@module.to_semimodule.{u_1 v} 𝕜 β
                     (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 _inst_3))
                     (@normed_group.to_add_comm_group.{v} β _inst_2)
                     (@normed_space.to_module.{u_1 v} 𝕜 β _inst_3 _inst_2 _inst_4)))))
         c
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  lemma integrable_on.mul_left (s : set α) (r : ℝ) {f : α → ℝ} (hf : integrable_on s f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    integrable_on s (λa, r * f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  by { simp only [smul_eq_mul.symm], exact hf.smul s r }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 123, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{?l_1+1} ?m_2 (@has_mul.mul.{?l_1} ?m_2 (@mul_zero_class.to_has_mul.{?l_1} ?m_2 (@semiring.to_mul_zero_class.{?l_1} ?m_2 ?m_3)) ?m_4 ?m_5) (@has_scalar.smul.{?l_1 ?l_1} ?m_2 ?m_2 (@mul_action.to_has_scalar.{?l_1 ?l_1} ?m_2 ?m_2 (@semiring.to_monoid.{?l_1} ?m_2 ?m_3) (@distrib_mul_action.to_mul_action.{?l_1 ?l_1} ?m_2 ?m_2 (@semiring.to_monoid.{?l_1} ?m_2 ?m_3) (@add_comm_monoid.to_add_monoid.{?l_1} ?m_2 (@semiring.to_add_comm_monoid.{?l_1} ?m_2 ?m_3)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_1} ?m_2 ?m_2 ?m_3 (@semiring.to_add_comm_monoid.{?l_1} ?m_2 ?m_3) (@semiring.to_semimodule.{?l_1} ?m_2 ?m_3)))) ?m_4 ?m_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real,
hf :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    (λ (a : α),
       @has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
         r
         (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real,
hf :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    (λ (a : α),
       @has_scalar.smul.{0 0} real real
         (@mul_action.to_has_scalar.{0 0} real real (@semiring.to_monoid.{0} real real.semiring)
            (@distrib_mul_action.to_mul_action.{0 0} real real (@semiring.to_monoid.{0} real real.semiring)
               (@add_comm_monoid.to_add_monoid.{0} real (@semiring.to_add_comm_monoid.{0} real real.semiring))
               (@semimodule.to_distrib_mul_action.{0 0} real real real.semiring
                  (@semiring.to_add_comm_monoid.{0} real real.semiring)
                  (@semiring.to_semimodule.{0} real real.semiring))))
         r
         (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  lemma integrable_on.mul_right (s : set α) (r : ℝ) {f : α → ℝ} (hf : integrable_on s f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    integrable_on s (λa, f a * r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  by { simp only [mul_comm], exact hf.mul_left _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a b) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real,
hf :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    (λ (a : α),
       @has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
         (f a)
         r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real,
hf :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    (λ (a : α),
       @has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
         r
         (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  lemma integrable_on.divide (s : set α) (r : ℝ) {f : α → ℝ} (hf : integrable_on s f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    integrable_on s (λa, f a / r) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  by { simp only [div_eq_mul_inv], exact hf.mul_right _ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='div_eq_mul_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 130, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [s : division_ring.{?l_1} α] {a b : α}, @eq.{?l_1+1} α (@has_div.div.{?l_1} α (@division_ring_has_div&#x27;.{?l_1} α s) a b) (@has_mul.mul.{?l_1} α (@no_zero_divisors.to_has_mul.{?l_1} α (@domain.to_no_zero_divisors.{?l_1} α (@division_ring.to_domain.{?l_1} α s))) a (@has_inv.inv.{?l_1} α (@division_ring.to_has_inv.{?l_1} α s) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real,
hf :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    (λ (a : α), @has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) (f a) r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real,
hf :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    (λ (a : α),
       @has_mul.mul.{0} real
         (@no_zero_divisors.to_has_mul.{0} real
            (@domain.to_no_zero_divisors.{0} real (@division_ring.to_domain.{0} real real.division_ring)))
         (f a)
         (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  lemma integrable_on.add (hfm : measurable_on s f) (hfi : integrable_on s f) (hgm : measurable_on s g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    (hgi : integrable_on s g) : integrable_on s (λa, f a + g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  by { rw [integrable_on, indicator_add], exact hfi.add hfm hgm hgi }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hfi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 158, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_monoid.{v} β] (s : set.{u} α) (f g : α → β), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) s (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β _inst_1)) (f a) (g a))) (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β _inst_1)) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) s f a) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) s g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 s
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (f a)
         (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (@set.indicator.{u v} α β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
       s
       (λ (a : α),
          @has_add.add.{v} β
            (@add_semigroup.to_has_add.{v} β
               (@add_monoid.to_add_semigroup.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
            (f a)
            (g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            (λ (a : α), f a)
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            (λ (a : α), g a)
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  lemma integrable_on.neg (hf : integrable_on s f) : integrable_on s (λa, -f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  by { rw [integrable_on, indicator_neg], exact hf.neg }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 120, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 183, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_group.{v} β] (s : set.{u} α) (f : α → β), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β _inst_1)) s (λ (a : α), @has_neg.neg.{v} β (@add_group.to_has_neg.{v} β _inst_1) (f a))) (λ (a : α), @has_neg.neg.{v} β (@add_group.to_has_neg.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β _inst_1)) s f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β,
hf : @integrable_on.{u v} α β _inst_1 _inst_2 s f
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 s
    (λ (a : α),
       @has_neg.neg.{v} β
         (@add_group.to_has_neg.{v} β
            (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
         (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β,
hf : @integrable_on.{u v} α β _inst_1 _inst_2 s f
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (@set.indicator.{u v} α β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
       s
       (λ (a : α),
          @has_neg.neg.{v} β
            (@add_group.to_has_neg.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
            (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β,
hf : @integrable_on.{u v} α β _inst_1 _inst_2 s f
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @has_neg.neg.{v} β
         (@add_group.to_has_neg.{v} β
            (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            (λ (a : α), f a)
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  lemma integrable_on.sub (hfm : measurable_on s f) (hfi : integrable_on s f) (hgm : measurable_on s g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    (hgi : integrable_on s g) : integrable_on s (λa, f a - g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  by { rw [integrable_on, indicator_sub], exact hfi.sub hfm hgm hgi }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hfi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_group.{v} β] (s : set.{u} α) (f g : α → β), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β _inst_1)) s (λ (a : α), @has_sub.sub.{v} β (@add_group_has_sub.{v} β _inst_1) (f a) (g a))) (λ (a : α), @has_sub.sub.{v} β (@add_group_has_sub.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β _inst_1)) s f a) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β _inst_1)) s g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 s
    (λ (a : α),
       @has_sub.sub.{v} β
         (@add_group_has_sub.{v} β
            (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
         (f a)
         (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (@set.indicator.{u v} α β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
       s
       (λ (a : α),
          @has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
            (f a)
            (g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @has_sub.sub.{v} β
         (@add_group_has_sub.{v} β
            (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            (λ (a : α), f a)
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            (λ (a : α), g a)
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  lemma integrable_on.union (hs : is_measurable s) (ht : is_measurable t) (hsm : measurable_on s f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    (hsi : integrable_on s f) (htm : measurable_on t f) (hti : integrable_on t f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    integrable_on (s ∪ t) f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153    rw ← union_diff_self,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.union_diff_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 789, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α}, @eq.{u+1} (set.{u} α) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @integrable_on.{u v} α β _inst_1 _inst_2
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s
       (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    rw [integrable_on, indicator_union_of_disjoint],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_union_of_disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_monoid.{v} β] {s t : set.{u} α}, @disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t → ∀ (f : α → β), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f) (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β _inst_1)) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) s f a) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) t f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @integrable_on.{u v} α β _inst_1 _inst_2
    (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s
       (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (@set.indicator.{u v} α β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
       (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s
          (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s))
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
            f
            a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155    { refine integrable.add hsm hsi (htm.subset _ _) (hti.subset _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.integrable.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='htm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='hti'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 158, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
            f
            a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156      { exact ht.diff hs },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 157, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157      { exact diff_subset _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.diff_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 729, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      { exact diff_subset _ _ } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.diff_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 729, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (s t : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) s t) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α)
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)
    t'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    exact disjoint_diff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.disjoint_diff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 805, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : set.{u} α}, @disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) a (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f
⊢ @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    (@has_sdiff.sdiff.{u} (set.{u} α) (@set.has_sdiff.{u} α) t s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  lemma integrable_on_norm_iff (s : set α) (f : α → β) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163    integrable_on s (λa, ∥f a∥) ↔ integrable_on s f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β
⊢ iff
    (@integrable_on.{u 0} α real _inst_1
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       s
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))
    (@integrable_on.{u v} α β _inst_1 _inst_2 s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165    simp only [integrable_on],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β
⊢ iff
    (@integrable_on.{u 0} α real _inst_1
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       s
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))
    (@integrable_on.{u v} α β _inst_1 _inst_2 s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β
⊢ iff
    (@measure_theory.integrable.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       (@set.indicator.{u 0} α real
          (@add_monoid.to_has_zero.{0} real
             (@add_group.to_add_monoid.{0} real
                (@add_comm_group.to_add_group.{0} real
                   (@normed_group.to_add_comm_group.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
          s
          (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))))
    (@measure_theory.integrable.{u v} α _inst_1 β _inst_2
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166    convert integrable_norm_iff (indicator s f),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.integrable_norm_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/l1_space.lean&#x27;, &#x27;line&#x27;: 204, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] (f : α → β), iff (@measure_theory.integrable.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))) (@measure_theory.integrable.{u v} α _inst_1 β _inst_2 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β
⊢ iff
    (@measure_theory.integrable.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       (@set.indicator.{u 0} α real
          (@add_monoid.to_has_zero.{0} real
             (@add_group.to_add_monoid.{0} real
                (@add_comm_group.to_add_group.{0} real
                   (@normed_group.to_add_comm_group.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
          s
          (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))))
    (@measure_theory.integrable.{u v} α _inst_1 β _inst_2
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β
⊢ @eq.{(max (u+1) 1)} (α → real)
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       s
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))
    (λ (a : α),
       @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    funext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β
⊢ @eq.{(max (u+1) 1)} (α → real)
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       s
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))
    (λ (a : α),
       @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β,
x : α
⊢ @eq.{1} real
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       s
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       x)
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          f
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    rw norm_indicator_eq_indicator_norm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='norm_indicator_eq_indicator_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : normed_group.{v} β] {s : set.{u} α} (f : α → β) (a : α), @eq.{1} real (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) s f a)) (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (f a)) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
s : set.{u} α,
f : α → β,
x : α
⊢ @eq.{1} real
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       s
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       x)
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          f
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  end integrable_on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  section integral_on</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  variables [measure_space α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='measure_theory.measure_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 801, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A measure space is a measurable space equipped with a
 measure, referred to as `volume`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175    [normed_group β] [second_countable_topology β] [normed_space ℝ β] [complete_space β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='topological_space.second_countable_topology'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/bases.lean&#x27;, &#x27;line&#x27;: 261, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type v) [t : topological_space.{v} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type) (β : Type v) [_inst_1 : normed_field.{0} α] [_inst_2 : normed_group.{v} β], Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type v) [_inst_2 : uniform_space.{v} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A second-countable space is one with a countable basis.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176    {s t : set α} {f g : α → β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    {a b : ℝ} {h : ℝ → β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  notation `∫` binders ` in ` s `, ` r:(scoped f, integral (indicator s f)) := r</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  variables (β)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  @[simp] lemma integral_on_zero (s : set α) : (∫ a in s, (0:β)) = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  by rw [indicator_zero, integral_zero]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.indicator_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1054, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (β : Type v) [_inst_1 : has_zero.{v} β] (s : set.{u} α), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β _inst_1 s (λ (x : α), @has_zero.zero.{v} β _inst_1)) (λ (x : α), @has_zero.zero.{v} β _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type u) [_inst_1 : measure_theory.measure_space.{u} α] (β : Type v) [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@has_zero.zero.{v} β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (x : α),
          @has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
    (@has_zero.zero.{v} β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@has_zero.zero.{v} β
       (@add_monoid.to_has_zero.{v} β
          (@add_group.to_add_monoid.{v} β
             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  variables {β}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  lemma integral_on_congr (h : ∀ x ∈ s, f x = g x) : (∫ a in s, f a) = (∫ a in s, g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α γ : Type} [c : has_mem.{0 0} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  by simp only [indicator_congr h]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.indicator_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β] {s : set.{u} α} {f g : α → β}, (∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @eq.{v+1} β (f a) (g a)) → @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β _inst_1 s f) (@set.indicator.{u v} α β _inst_1 s g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
f g : α → β,
h : ∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x)
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α), f a)))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
f g : α → β,
h : ∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x)
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α), f a)))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  lemma integral_on_congr_of_ae_eq (hf : measurable_on s f) (hg : measurable_on s g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    (h : ∀ₘ x, x ∈ s → f x = g x) : (∫ a in s, f a) = (∫ a in s, g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  integral_congr_ae hf hg (indicator_congr_ae h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral_congr_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='indicator_congr_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1099, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @eq.{v+1} β (f a) (g a)) → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β] {s : set.{u} α} {f g : α → β} [_inst_2 : measure_theory.measure_space.{u} α], @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @eq.{v+1} β (f a) (g a)) → @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), @eq.{v+1} β (@set.indicator.{u v} α β _inst_1 s f a) (@set.indicator.{u v} α β _inst_1 s g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.all_ae.{u} α _inst_1 (λ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s → @eq.{v+1} β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  lemma integral_on_congr_of_set (hsm : measurable_on s f) (htm : measurable_on t f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    (h : ∀ₘ x, x ∈ s ↔ x ∈ t) : (∫ a in s, f a) = (∫ a in t, f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  integral_congr_ae hsm htm $ indicator_congr_of_set h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral_congr_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='indicator_congr_of_set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1099, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @eq.{v+1} β (f a) (g a)) → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : has_zero.{v} β] {s t : set.{u} α} {f : α → β} [_inst_2 : measure_theory.measure_space.{u} α], @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a t)) → @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), @eq.{v+1} β (@set.indicator.{u v} α β _inst_1 s f a) (@set.indicator.{u v} α β _inst_1 t f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measure_theory.all_ae.{u} α _inst_1 (λ (x : α), iff (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s) (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  variables (s t)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  lemma integral_on_smul (r : ℝ) (f : α → β) : (∫ a in s, r • (f a)) = r • (∫ a in s, f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type v} [c : has_scalar.{0 v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type v} [c : has_scalar.{0 v} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  by rw [← integral_smul, indicator_smul]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.integral_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1079, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] (r : real) (f : α → β), @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @has_scalar.smul.{0 v} real β (@mul_action.to_has_scalar.{0 v} real β real.monoid (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))) (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)) (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2) (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4))))) r (f a))) (@has_scalar.smul.{0 v} real β (@mul_action.to_has_scalar.{0 v} real β real.monoid (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))) (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)) (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2) (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4))))) r (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_monoid.{v} β] {𝕜 : Type} [_inst_2 : monoid.{0} 𝕜] [_inst_3 : @distrib_mul_action.{0 v} 𝕜 β _inst_2 _inst_1] (s : set.{u} α) (r : 𝕜) (f : α → β), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) s (λ (x : α), @has_scalar.smul.{0 v} 𝕜 β (@mul_action.to_has_scalar.{0 v} 𝕜 β _inst_2 (@distrib_mul_action.to_mul_action.{0 v} 𝕜 β _inst_2 _inst_1 _inst_3)) r (f x))) (λ (x : α), @has_scalar.smul.{0 v} 𝕜 β (@mul_action.to_has_scalar.{0 v} 𝕜 β _inst_2 (@distrib_mul_action.to_mul_action.{0 v} 𝕜 β _inst_2 _inst_1 _inst_3)) r (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) s f x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
r : real,
f : α → β
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_scalar.smul.{0 v} real β
               (@mul_action.to_has_scalar.{0 v} real β real.monoid
                  (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
                     (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                        (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                        (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                           (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
               r
               (f a))))
    (@has_scalar.smul.{0 v} real β
       (@mul_action.to_has_scalar.{0 v} real β real.monoid
          (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
             (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                   (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
       r
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
r : real,
f : α → β
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_scalar.smul.{0 v} real β
               (@mul_action.to_has_scalar.{0 v} real β real.monoid
                  (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
                     (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                        (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                        (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                           (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
               r
               (f a))))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          @has_scalar.smul.{0 v} real β
            (@mul_action.to_has_scalar.{0 v} real β real.monoid
               (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
                  (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                     (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                     (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                        (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
            r
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s)
               (@set.decidable_mem.{u} α s (λ (a : α), classical.prop_decidable (s a)) a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
r : real,
f : α → β
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_scalar.smul.{0 v} real β
               (@mul_action.to_has_scalar.{0 v} real β real.monoid
                  (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
                     (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                        (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                        (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                           (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
               r
               (f a))))
    (@has_scalar.smul.{0 v} real β
       (@mul_action.to_has_scalar.{0 v} real β real.monoid
          (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
             (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                   (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
       r
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
r : real,
f : α → β
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_scalar.smul.{0 v} real β
               (@mul_action.to_has_scalar.{0 v} real β real.monoid
                  (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
                     (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                        (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                        (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                           (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
               r
               (f a))))
    (@has_scalar.smul.{0 v} real β
       (@mul_action.to_has_scalar.{0 v} real β real.monoid
          (@distrib_mul_action.to_mul_action.{0 v} real β real.monoid
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
             (@semimodule.to_distrib_mul_action.{0 v} real β real.semiring
                (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
                (@module.to_semimodule.{0 v} real β real.ring (@normed_group.to_add_comm_group.{v} β _inst_2)
                   (@normed_space.to_module.{0 v} real β normed_field.normed_field _inst_2 _inst_4)))))
       r
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  lemma integral_on_mul_left (r : ℝ) (f : α → ℝ) : (∫ a in s, r * (f a)) = r * (∫ a in s, f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  integral_on_smul s r f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='integral_on_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 199, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))] (s : set.{u} α) (r : real) (f : α → β), @eq.{1} β (@measure_theory.integral.{u 0} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (@set.indicator.{u 0} α β (@add_monoid.to_has_zero.{0} β (@add_group.to_add_monoid.{0} β (@add_comm_group.to_add_group.{0} β (@normed_group.to_add_comm_group.{0} β _inst_2)))) s (λ (a : α), @has_scalar.smul.{0 0} real β (@mul_action.to_has_scalar.{0 0} real β real.monoid (@distrib_mul_action.to_mul_action.{0 0} real β real.monoid (@add_group.to_add_monoid.{0} β (@add_comm_group.to_add_group.{0} β (@normed_group.to_add_comm_group.{0} β _inst_2))) (@semimodule.to_distrib_mul_action.{0 0} real β real.semiring (@add_comm_group.to_add_comm_monoid.{0} β (@normed_group.to_add_comm_group.{0} β _inst_2)) (@module.to_semimodule.{0 0} real β real.ring (@normed_group.to_add_comm_group.{0} β _inst_2) (@normed_space.to_module.{0 0} real β normed_field.normed_field _inst_2 _inst_4))))) r (f a)))) (@has_scalar.smul.{0 0} real β (@mul_action.to_has_scalar.{0 0} real β real.monoid (@distrib_mul_action.to_mul_action.{0 0} real β real.monoid (@add_group.to_add_monoid.{0} β (@add_comm_group.to_add_group.{0} β (@normed_group.to_add_comm_group.{0} β _inst_2))) (@semimodule.to_distrib_mul_action.{0 0} real β real.semiring (@add_comm_group.to_add_comm_monoid.{0} β (@normed_group.to_add_comm_group.{0} β _inst_2)) (@module.to_semimodule.{0 0} real β real.ring (@normed_group.to_add_comm_group.{0} β _inst_2) (@normed_space.to_module.{0 0} real β normed_field.normed_field _inst_2 _inst_4))))) r (@measure_theory.integral.{u 0} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (@set.indicator.{u 0} α β (@add_monoid.to_has_zero.{0} β (@add_group.to_add_monoid.{0} β (@add_comm_group.to_add_group.{0} β (@normed_group.to_add_comm_group.{0} β _inst_2)))) s (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  lemma integral_on_mul_right (r : ℝ) (f : α → ℝ) : (∫ a in s, (f a) * r) = (∫ a in s, f a) * r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_mul.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  by { simp only [mul_comm], exact integral_on_mul_left s r f }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integral_on_mul_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 202, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a b) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] (s : set.{u} α) (r : real) (f : α → real), @eq.{1} real (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), @has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r (f a)))) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real
⊢ @eq.{1} real
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α),
             @has_mul.mul.{0} real
               (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
               (f a)
               r)))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@measure_theory.integral.{u 0} α _inst_1 real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          real.topological_space.second_countable_topology
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          real.complete_space
          (@set.indicator.{u 0} α real
             (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             s
             (λ (a : α), f a)))
       r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real
⊢ @eq.{1} real
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α),
             @has_mul.mul.{0} real
               (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
               r
               (f a))))
    (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) r
       (@measure_theory.integral.{u 0} α _inst_1 real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          real.topological_space.second_countable_topology
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          real.complete_space
          (@set.indicator.{u 0} α real
             (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             s
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  lemma integral_on_div (r : ℝ) (f : α → ℝ) : (∫ a in s, (f a) / r) = (∫ a in s, f a) / r :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_div.div'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_div.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  by { simp only [div_eq_mul_inv], apply integral_on_mul_right }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='div_eq_mul_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integral_on_mul_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/field.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 205, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [s : division_ring.{?l_1} α] {a b : α}, @eq.{?l_1+1} α (@has_div.div.{?l_1} α (@division_ring_has_div&#x27;.{?l_1} α s) a b) (@has_mul.mul.{?l_1} α (@no_zero_divisors.to_has_mul.{?l_1} α (@domain.to_no_zero_divisors.{?l_1} α (@division_ring.to_domain.{?l_1} α s))) a (@has_inv.inv.{?l_1} α (@division_ring.to_has_inv.{?l_1} α s) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] (s : set.{u} α) (r : real) (f : α → real), @eq.{1} real (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), @has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (f a) r))) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), f a))) r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real
⊢ @eq.{1} real
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α), @has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring) (f a) r)))
    (@has_div.div.{0} real (@division_ring_has_div&#x27;.{0} real real.division_ring)
       (@measure_theory.integral.{u 0} α _inst_1 real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          real.topological_space.second_countable_topology
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          real.complete_space
          (@set.indicator.{u 0} α real
             (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             s
             (λ (a : α), f a)))
       r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
r : real,
f : α → real
⊢ @eq.{1} real
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α),
             @has_mul.mul.{0} real
               (@no_zero_divisors.to_has_mul.{0} real
                  (@domain.to_no_zero_divisors.{0} real (@division_ring.to_domain.{0} real real.division_ring)))
               (f a)
               (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) r))))
    (@has_mul.mul.{0} real
       (@no_zero_divisors.to_has_mul.{0} real
          (@domain.to_no_zero_divisors.{0} real (@division_ring.to_domain.{0} real real.division_ring)))
       (@measure_theory.integral.{u 0} α _inst_1 real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          real.topological_space.second_countable_topology
          (@normed_field.to_normed_space.{0} real normed_field.normed_field)
          real.complete_space
          (@set.indicator.{u 0} α real
             (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
             s
             f))
       (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) r))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  lemma integral_on_neg (f : α → β) : (∫ a in s, -f a) = - (∫ a in s, f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_neg.{v} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  by { simp only [indicator_neg], exact integral_neg _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.indicator_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.integral_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 120, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1064, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_group.{?l_2} β] (s : set.{?l_1} α) (f : α → β), @eq.{(max (?l_1+1) (?l_2+1))} (α → β) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β (@add_group.to_add_monoid.{?l_2} β _inst_1)) s (λ (a : α), @has_neg.neg.{?l_2} β (@add_group.to_has_neg.{?l_2} β _inst_1) (f a))) (λ (a : α), @has_neg.neg.{?l_2} β (@add_group.to_has_neg.{?l_2} β _inst_1) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β (@add_group.to_add_monoid.{?l_2} β _inst_1)) s f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] (f : α → β), @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))) (f a))) (@has_neg.neg.{v} β (@add_group.to_has_neg.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
f : α → β
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_neg.neg.{v} β
               (@add_group.to_has_neg.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
               (f a))))
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
f : α → β
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          @has_neg.neg.{v} β
            (@add_group.to_has_neg.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               s
               f
               a)))
    (@has_neg.neg.{v} β
       (@add_group.to_has_neg.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  variables {s t}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  lemma integral_on_add {s : set α} (hfm : measurable_on s f) (hfi : integrable_on s f) (hgm : measurable_on s g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217    (hgi : integrable_on s g) : (∫ a in s, f a + g a) = (∫ a in s, f a) + (∫ a in s, g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  by { simp only [indicator_add], exact integral_add hfm hfi hgm hgi }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.indicator_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.integral_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1059, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_monoid.{?l_2} β] (s : set.{?l_1} α) (f g : α → β), @eq.{(max (?l_1+1) (?l_2+1))} (α → β) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β _inst_1) s (λ (a : α), @has_add.add.{?l_2} β (@add_semigroup.to_has_add.{?l_2} β (@add_monoid.to_add_semigroup.{?l_2} β _inst_1)) (f a) (g a))) (λ (a : α), @has_add.add.{?l_2} β (@add_semigroup.to_has_add.{?l_2} β (@add_monoid.to_add_semigroup.{?l_2} β _inst_1)) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β _inst_1) s f a) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β _inst_1) s g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 g → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (f a) (g a))) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
f g : α → β,
s : set.{u} α,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_add.add.{v} β
               (@add_semigroup.to_has_add.{v} β
                  (@add_monoid.to_add_semigroup.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
               (f a)
               (g a))))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), g a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
f g : α → β,
s : set.{u} α,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          @has_add.add.{v} β
            (@add_semigroup.to_has_add.{v} β
               (@add_monoid.to_add_semigroup.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               s
               f
               a)
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               s
               g
               a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             f))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  lemma integral_on_sub (hfm : measurable_on s f) (hfi : integrable_on s f) (hgm : measurable_on s g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221    (hgi : integrable_on s g) : (∫ a in s, f a - g a) = (∫ a in s, f a) - (∫ a in s, g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_sub.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  by { simp only [indicator_sub], exact integral_sub hfm hfi hgm hgi }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='set.indicator_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.integral_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1074, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : add_group.{?l_2} β] (s : set.{?l_1} α) (f g : α → β), @eq.{(max (?l_1+1) (?l_2+1))} (α → β) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β (@add_group.to_add_monoid.{?l_2} β _inst_1)) s (λ (a : α), @has_sub.sub.{?l_2} β (@add_group_has_sub.{?l_2} β _inst_1) (f a) (g a))) (λ (a : α), @has_sub.sub.{?l_2} β (@add_group_has_sub.{?l_2} β _inst_1) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β (@add_group.to_add_monoid.{?l_2} β _inst_1)) s f a) (@set.indicator.{?l_1 ?l_2} α β (@add_monoid.to_has_zero.{?l_2} β (@add_group.to_add_monoid.{?l_2} β _inst_1)) s g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 g → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))) (f a) (g a))) (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          s
          (λ (a : α),
             @has_sub.sub.{v} β
               (@add_group_has_sub.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
               (f a)
               (g a))))
    (@has_sub.sub.{v} β
       (@add_group_has_sub.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), g a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : set.{u} α,
f g : α → β,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
hgm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    g,
hgi : @integrable_on.{u v} α β _inst_1 _inst_2 s g
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          @has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               s
               f
               a)
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               s
               g
               a)))
    (@has_sub.sub.{v} β
       (@add_group_has_sub.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             f))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  lemma integral_on_le_integral_on_ae {f g : α → ℝ} (hfm : measurable_on s f) (hfi : integrable_on s f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225    (hgm : measurable_on s g) (hgi : integrable_on s g) (h : ∀ₘ a, a ∈ s → f a ≤ g a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    (∫ a in s, f a) ≤ (∫ a in s, g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))
⊢ @has_le.le.{0} real real.has_le
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α), f a)))
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    apply integral_le_integral_ae hfm hfi hgm hgi,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.integral_le_integral_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1270, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {f g : α → real}, @measurable.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) f → @measure_theory.integrable.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) f → @measurable.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) g → @measure_theory.integrable.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) g → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @has_le.le.{0} real real.has_le (f a) (g a)) → @has_le.le.{0} real real.has_le (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (λ (a : α), f a)) (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (λ (a : α), g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))
⊢ @has_le.le.{0} real real.has_le
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α), f a)))
    (@measure_theory.integral.{u 0} α _inst_1 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       real.topological_space.second_countable_topology
       (@normed_field.to_normed_space.{0} real normed_field.normed_field)
       real.complete_space
       (@set.indicator.{u 0} α real
          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
          s
          (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_le.le.{0} real real.has_le
         (@set.indicator.{u 0} α real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
            s
            f
            a)
         (@set.indicator.{u 0} α real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
            s
            g
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229    apply indicator_le_indicator_ae,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='indicator_le_indicator_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : has_zero.{0} β] [_inst_2 : preorder.{0} β] {s : set.{u} α} {f g : α → β} [_inst_3 : measure_theory.measure_space.{u} α], @measure_theory.all_ae.{u} α _inst_3 (λ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} β (@preorder.to_has_le.{0} β _inst_2) (f a) (g a)) → @measure_theory.all_ae.{u} α _inst_3 (λ (a : α), @has_le.le.{0} β (@preorder.to_has_le.{0} β _inst_2) (@set.indicator.{u 0} α β _inst_1 s f a) (@set.indicator.{u 0} α β _inst_1 s g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_le.le.{0} real real.has_le
         (@set.indicator.{u 0} α real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
            s
            f
            a)
         (@set.indicator.{u 0} α real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
            s
            g
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s →
       @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    exact h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s →
       @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  lemma integral_on_le_integral_on {f g : α → ℝ} (hfm : measurable_on s f) (hfi : integrable_on s f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    (hgm : measurable_on s g) (hgi : integrable_on s g) (h : ∀ a, a ∈ s → f a ≤ g a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235    (∫ a in s, f a) ≤ (∫ a in s, g a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type} [_inst_2 : normed_group.{0} β] [_inst_3 : @topological_space.second_countable_topology.{0} β (@uniform_space.to_topological_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2)))] [_inst_4 : @normed_space.{0 0} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{0} β (@metric_space.to_uniform_space&#x27;.{0} β (@normed_group.to_metric_space.{0} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  integral_on_le_integral_on_ae hfm hfi hgm hgi $ by filter_upwards [] h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='integral_on_le_integral_on_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hgi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 224, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {s : set.{u} α} {f g : α → real}, @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s f → @integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s f → @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s g → @integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s g → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a)) → @has_le.le.{0} real real.has_le (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), f a))) (@measure_theory.integral.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) real.topological_space.second_countable_topology (@normed_field.to_normed_space.{0} real normed_field.normed_field) real.complete_space (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))) (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  ∀ (a : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a)
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : measure_theory.measure_space.{u} α,
s : set.{u} α,
f g : α → real,
hfm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    f,
hfi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    f,
hgm :
  @measurable_on.{u 0} α real (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{0} real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)))
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    s
    g,
hgi :
  @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    s
    g,
h :
  ∀ (a : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a)
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a s → @has_le.le.{0} real real.has_le (f a) (g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  lemma integral_on_union (hsm : measurable_on s f) (hsi : integrable_on s f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    (htm : measurable_on t f) (hti : integrable_on t f) (h : disjoint s t) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 758, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Two elements of a lattice are disjoint if their inf is the bottom element.
 (This generalizes disjoint sets, viewed as members of the subset lattice.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240    (∫ a in (s ∪ t), f a) = (∫ a in s, f a) + (∫ a in t, f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  by { rw [indicator_union_of_disjoint h, integral_add hsm hsi htm hti] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.indicator_union_of_disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hti'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1059, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_monoid.{v} β] {s t : set.{u} α}, @disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t → ∀ (f : α → β), @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f) (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β _inst_1)) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) s f a) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_1) t f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@disjoint.{u} (set.{u} α) (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 g → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (f a) (g a))) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    t
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (λ (a : α), f a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    t
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          @has_add.add.{v} β
            (@add_semigroup.to_has_add.{v} β
               (@add_monoid.to_add_semigroup.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               s
               (λ (a : α), f a)
               a)
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               t
               (λ (a : α), f a)
               a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @disjoint.{u} (set.{u} α)
    (@lattice.semilattice_inf_bot_of_bounded_lattice.{u} (set.{u} α)
       (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))
    s
    t
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (λ (a : α), f a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  lemma integral_on_union_ae (hs : is_measurable s) (ht : is_measurable t) (hsm : measurable_on s f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    (hsi : integrable_on s f) (htm : measurable_on t f) (hti : integrable_on t f) (h : ∀ₘ a, a ∉ s ∩ t) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.all_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 871, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α], (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `∀ₘ a:α, p a` states that the property `p` is almost everywhere true in the measure space
associated with `α`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245    (∫ a in (s ∪ t), f a) = (∫ a in s, f a) + (∫ a in t, f a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_add.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (λ (a : α), f a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247    have := integral_congr_ae _ _ (indicator_union_ae h f),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.integral_congr_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='indicator_union_ae'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1099, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @eq.{v+1} β (f a) (g a)) → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), g a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {s t : set.{u} α} [_inst_2 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_3 : add_monoid.{v} β], @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t))) → ∀ (f : α → β), @measure_theory.all_ae.{u} α _inst_2 (λ (a : α), @eq.{v+1} β (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_3) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f a) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β _inst_3)) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_3) s f a) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β _inst_3) t f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measure_theory.all_ae.{u} α _inst_1 (λ (a : α), not (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (λ (a : α), f a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t))),
this :
  @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          (λ (a : α),
             @set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
               f
               a)
            a))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          (λ (a : α),
             @has_add.add.{v} β
               (@add_semigroup.to_has_add.{v} β
                  (@add_monoid.to_add_semigroup.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  s
                  f
                  a)
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  t
                  f
                  a))
            a))
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (λ (a : α), f a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @set.indicator.{u v} α β
         (@add_monoid.to_has_zero.{v} β
            (@add_group.to_add_monoid.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
         (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
         f
         a)

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            t
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    rw [this, integral_add hsm hsi htm hti],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral_add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hti'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1059, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), (λ (a : α), @set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t) f a) a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f a) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) t f a)) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {f g : α → β}, @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 f → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) g → @measure_theory.integrable.{u v} α _inst_1 β _inst_2 g → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (f a) (g a))) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), g a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t))),
this :
  @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          (λ (a : α),
             @set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
               f
               a)
            a))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          (λ (a : α),
             @has_add.add.{v} β
               (@add_semigroup.to_has_add.{v} β
                  (@add_monoid.to_add_semigroup.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  s
                  f
                  a)
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  t
                  f
                  a))
            a))
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
          (λ (a : α), f a)))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @set.indicator.{u v} α β
         (@add_monoid.to_has_zero.{v} β
            (@add_group.to_add_monoid.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
         (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
         f
         a)

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            t
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t))),
this :
  @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          (λ (a : α),
             @set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
               f
               a)
            a))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          (λ (a : α),
             @has_add.add.{v} β
               (@add_semigroup.to_has_add.{v} β
                  (@add_monoid.to_add_semigroup.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  s
                  f
                  a)
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  t
                  f
                  a))
            a))
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          (λ (a : α),
             @has_add.add.{v} β
               (@add_semigroup.to_has_add.{v} β
                  (@add_monoid.to_add_semigroup.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  s
                  f
                  a)
               (@set.indicator.{u v} α β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                  t
                  f
                  a))
            a))
    (@has_add.add.{v} β
       (@add_semigroup.to_has_add.{v} β
          (@add_monoid.to_add_semigroup.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             s
             (λ (a : α), f a)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             t
             (λ (a : α), f a))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @set.indicator.{u v} α β
         (@add_monoid.to_has_zero.{v} β
            (@add_group.to_add_monoid.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
         (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
         f
         a)

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            t
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @set.indicator.{u v} α β
         (@add_monoid.to_has_zero.{v} β
            (@add_group.to_add_monoid.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
         (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
         f
         a)

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            t
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249    { exact hsm.union hs ht htm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @set.indicator.{u v} α β
         (@add_monoid.to_has_zero.{v} β
            (@add_group.to_add_monoid.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
         (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
         f
         a)

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            t
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @set.indicator.{u v} α β
         (@add_monoid.to_has_zero.{v} β
            (@add_group.to_add_monoid.{v} β
               (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
         (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s t)
         f
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            t
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250    { exact hsm.add htm }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/borel_space.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s t : set.{u} α,
f : α → β,
hs : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) s,
ht : @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) t,
hsm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    s
    f,
hsi : @integrable_on.{u v} α β _inst_1 _inst_2 s f,
htm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    t
    f,
hti : @integrable_on.{u v} α β _inst_1 _inst_2 t f,
h :
  @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       not
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
            (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) s t)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @has_add.add.{v} β
         (@add_semigroup.to_has_add.{v} β
            (@add_monoid.to_add_semigroup.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            s
            f
            a)
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            t
            f
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  lemma tendsto_integral_on_of_monotone {s : ℕ → set α} {f : α → β} (hsm : ∀i, is_measurable (s i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254    (h_mono : monotone s) (hfm : measurable_on (Union s) f) (hfi : integrable_on (Union s) f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='monotone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : preorder.{u} α] [_inst_2 : preorder.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A function between preorders is monotone if
 `a ≤ b` implies `f a ≤ f b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255    tendsto (λi, ∫ a in (s i), f a) at_top (nhds (∫ a in (Union s), f a)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  let bound : α → ℝ := indicator (Union s) (λa, ∥f a∥) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bound'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type} [_inst_1 : has_zero.{0} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @filter.tendsto.{0 v} nat β
    (λ (i : nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (s i)
            (λ (a : α), f a)))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258    apply tendsto_integral_of_dominated_convergence,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.tendsto_integral_of_dominated_convergence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1121, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {F : nat → α → β} {f : α → β} (bound : α → real), (∀ (n : nat), @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (F n)) → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measure_theory.integrable.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) bound → (∀ (n : nat), @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (F n a)) (bound a))) → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @filter.tendsto.{0 v} nat β (λ (n : nat), F n a) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))) (f a))) → @filter.tendsto.{0 v} nat β (λ (n : nat), @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), F n a)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Lebesgue dominated convergence theorem provides sufficient conditions under which almost
 everywhere convergence of a sequence of functions implies the convergence of their integrals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @filter.tendsto.{0 v} nat β
    (λ (i : nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (s i)
            (λ (a : α), f a)))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='6 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
           (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259    { assume i, exact hfm.subset (hsm i) (subset_Union _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (@set.Union.{u 1} α nat s) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u} {ι : Type} (s : ι → set.{u} β) (i : ι), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (s i) (@set.Union.{u 1} β ι (λ (i : ι), s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='6 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
           (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
           (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
         (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260    { assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261    { show integrable_on (Union s) (λa, ∥f a∥), rwa integrable_on_norm_iff },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='integrable_on_norm_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{0} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β] (s : set.{u} α) (f : α → β), iff (@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))) (@integrable_on.{u v} α β _inst_1 _inst_2 s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (@set.indicator.{u 0} α real
              (@add_monoid.to_has_zero.{0} real
                 (@add_group.to_add_monoid.{0} real
                    (@add_comm_group.to_add_group.{0} real
                       (@normed_group.to_add_comm_group.{0} real
                          (@normed_ring.to_normed_group.{0} real
                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
              (@set.Union.{u 1} α nat s)
              (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
              a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262    { assume i, apply all_ae_of_all,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='measure_theory.all_ae_of_all'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 883, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {p : α → Prop}, (∀ (a : α), p a) → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (@set.indicator.{u 0} α real
              (@add_monoid.to_has_zero.{0} real
                 (@add_group.to_add_monoid.{0} real
                    (@add_comm_group.to_add_group.{0} real
                       (@normed_group.to_add_comm_group.{0} real
                          (@normed_ring.to_normed_group.{0} real
                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
              (@set.Union.{u 1} α nat s)
              (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
              a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (@set.indicator.{u 0} α real
              (@add_monoid.to_has_zero.{0} real
                 (@add_group.to_add_monoid.{0} real
                    (@add_comm_group.to_add_group.{0} real
                       (@normed_group.to_add_comm_group.{0} real
                          (@normed_ring.to_normed_group.{0} real
                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
              (@set.Union.{u 1} α nat s)
              (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
              a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_le.le.{0} real real.has_le
         (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
               (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
         (@set.indicator.{u 0} α real
            (@add_monoid.to_has_zero.{0} real
               (@add_group.to_add_monoid.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
            (@set.Union.{u 1} α nat s)
            (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ ∀ (a : α),
    @has_le.le.{0} real real.has_le
      (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
            (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
            β
            ((λ (a : α), f a) a)
            (@has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
      (@set.indicator.{u 0} α real
         (@add_monoid.to_has_zero.{0} real
            (@add_group.to_add_monoid.{0} real
               (@add_comm_group.to_add_group.{0} real
                  (@normed_group.to_add_comm_group.{0} real
                     (@normed_ring.to_normed_group.{0} real
                        (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
         (@set.Union.{u 1} α nat s)
         (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263      assume a,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ ∀ (a : α),
    @has_le.le.{0} real real.has_le
      (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
            (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
            β
            ((λ (a : α), f a) a)
            (@has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
      (@set.indicator.{u 0} α real
         (@add_monoid.to_has_zero.{0} real
            (@add_group.to_add_monoid.{0} real
               (@add_comm_group.to_add_group.{0} real
                  (@normed_group.to_add_comm_group.{0} real
                     (@normed_ring.to_normed_group.{0} real
                        (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
         (@set.Union.{u 1} α nat s)
         (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
          (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
          β
          ((λ (a : α), f a) a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264      rw [norm_indicator_eq_indicator_norm],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='norm_indicator_eq_indicator_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : normed_group.{v} β] {s : set.{u} α} (f : α → β) (a : α), @eq.{1} real (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) s f a)) (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (f a)) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
          (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
          β
          ((λ (a : α), f a) a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (s i)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) ((λ (a : α), f a) a))
       a)
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265      exact indicator_le_indicator_of_subset (subset_Union _ _) (λa, norm_nonneg _) _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.indicator_le_indicator_of_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='norm_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 135, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : has_zero.{0} β] [_inst_2 : preorder.{0} β] {s t : set.{u} α} {f : α → β}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → (∀ (a : α), @has_le.le.{0} β (@preorder.to_has_le.{0} β _inst_2) (@has_zero.zero.{0} β _inst_1) (f a)) → ∀ (a : α), @has_le.le.{0} β (@preorder.to_has_le.{0} β _inst_2) (@set.indicator.{u 0} α β _inst_1 s f a) (@set.indicator.{u 0} α β _inst_1 t f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u} {ι : Type} (s : ι → set.{u} β) (i : ι), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (s i) (@set.Union.{u 1} β ι (λ (i : ι), s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : normed_group.{v} α] (g : α), @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (@has_norm.norm.{v} α (@normed_group.to_has_norm.{v} α _inst_1) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (s i)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) ((λ (a : α), f a) a))
       a)
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266    { filter_upwards [] λa, le_trans (tendsto_indicator_of_monotone _ h_mono _ _) (pure_le_nhds _) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tendsto_indicator_of_monotone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pure_le_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 116, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b c : α}, @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b c → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {ι : Type} [_inst_1 : lattice.semilattice_sup.{0} ι] [_inst_2 : has_zero.{v} β] [_inst_3 : nonempty.{1} ι] (s : ι → set.{u} α), @monotone.{0 u} ι (set.{u} α) (@partial_order.to_preorder.{0} ι (@lattice.semilattice_sup.to_partial_order.{0} ι _inst_1)) (@partial_order.to_preorder.{u} (set.{u} α) (@lattice.order_bot.to_partial_order.{u} (set.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))))) s → ∀ (f : α → β) (a : α), @filter.tendsto.{0 v} ι β (λ (i : ι), @set.indicator.{u v} α β _inst_2 (s i) f a) (@filter.at_top.{0} ι (@partial_order.to_preorder.{0} ι (@lattice.semilattice_sup.to_partial_order.{0} ι _inst_1))) (@has_pure.pure.{v v} filter.{v} filter.has_pure.{v} β (@set.indicator.{u v} α β _inst_2 (@set.Union.{u 1} α ι s) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@monotone.{0 u} nat (set.{u} α) (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))) (@partial_order.to_preorder.{u} (set.{u} α) (@lattice.order_bot.to_partial_order.{u} (set.{u} α) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α))))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : topological_space.{v} α], @has_le.le.{v} (α → filter.{v} α) (@preorder.to_has_le.{v} (α → filter.{v} α) (@pi.preorder.{v v} α (λ (a : α), filter.{v} α) (λ (i : α), @partial_order.to_preorder.{v} (filter.{v} α) (@filter.partial_order.{v} α)))) (@has_pure.pure.{v v} (λ {α : Type v}, filter.{v} α) filter.has_pure.{v} α) (@nhds.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  @monotone.{0 u} nat (set.{u} α)
    (@partial_order.to_preorder.{0} nat
       (@ordered_comm_monoid.to_partial_order.{0} nat
          (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
             (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))
    (@partial_order.to_preorder.{u} (set.{u} α)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} α)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} α) (@set.lattice_set.{u} α)))))
    s,
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  lemma tendsto_integral_on_of_antimono (s : ℕ → set α) (f : α → β) (hsm : ∀i, is_measurable (s i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                             </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270    (h_mono : ∀i j, i ≤ j → s j ⊆ s i) (hfm : measurable_on (s 0) f) (hfi : integrable_on (s 0) f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271    tendsto (λi, ∫ a in (s i), f a) at_top (nhds (∫ a in (Inter s), f a)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed intersection of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  let bound : α → ℝ := indicator (s 0) (λa, ∥f a∥) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='bound'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type} [_inst_1 : has_zero.{0} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @filter.tendsto.{0 v} nat β
    (λ (i : nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (s i)
            (λ (a : α), f a)))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Inter.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    apply tendsto_integral_of_dominated_convergence,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='measure_theory.tendsto_integral_of_dominated_convergence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1121, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {F : nat → α → β} {f : α → β} (bound : α → real), (∀ (n : nat), @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (F n)) → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @measure_theory.integrable.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) bound → (∀ (n : nat), @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (F n a)) (bound a))) → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @filter.tendsto.{0 v} nat β (λ (n : nat), F n a) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))) (f a))) → @filter.tendsto.{0 v} nat β (λ (n : nat), @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), F n a)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Lebesgue dominated convergence theorem provides sufficient conditions under which almost
 everywhere convergence of a sequence of functions implies the convergence of their integrals.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @filter.tendsto.{0 v} nat β
    (λ (i : nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (s i)
            (λ (a : α), f a)))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Inter.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='6 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
           (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275    { assume i, refine hfm.subset (hsm i) (h_mono _ _ (zero_le _)) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (s (@has_zero.zero.{0} nat nat.has_zero)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : canonically_ordered_monoid.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='6 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
           (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
           (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
         (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276    { exact hfm.subset (is_measurable.Inter hsm) (Inter_subset _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable.Inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hsm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Inter_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (s (@has_zero.zero.{0} nat nat.has_zero)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : measurable_space.{u} α] [_inst_2 : encodable.{0} β] {f : β → set.{u} α}, (∀ (b : β), @is_measurable.{u} α _inst_1 (f b)) → @is_measurable.{u} α _inst_1 (@set.Inter.{u 1} α β (λ (b : β), f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u} {ι : Type} (s : ι → set.{u} β) (i : ι), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (@set.Inter.{u 1} β ι (λ (i : ι), s i)) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
            a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277    { show integrable_on (s 0) (λa, ∥f a∥), rwa integrable_on_norm_iff },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='integrable_on_norm_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{0} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β] (s : set.{u} α) (f : α → β), iff (@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))) (@integrable_on.{u v} α β _inst_1 _inst_2 s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (?m_1 a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (@set.indicator.{u 0} α real
              (@add_monoid.to_has_zero.{0} real
                 (@add_group.to_add_monoid.{0} real
                    (@add_comm_group.to_add_group.{0} real
                       (@normed_group.to_add_comm_group.{0} real
                          (@normed_ring.to_normed_group.{0} real
                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
              (s (@has_zero.zero.{0} nat nat.has_zero))
              (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
              a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278    { assume i, apply all_ae_of_all,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='measure_theory.all_ae_of_all'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measure_space.lean&#x27;, &#x27;line&#x27;: 883, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {p : α → Prop}, (∀ (a : α), p a) → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (@set.indicator.{u 0} α real
              (@add_monoid.to_has_zero.{0} real
                 (@add_group.to_add_monoid.{0} real
                    (@add_comm_group.to_add_group.{0} real
                       (@normed_group.to_add_comm_group.{0} real
                          (@normed_ring.to_normed_group.{0} real
                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
              (s (@has_zero.zero.{0} nat nat.has_zero))
              (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
              a))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ ∀ (n : nat),
    @measure_theory.all_ae.{u} α _inst_1
      (λ (a : α),
         @has_le.le.{0} real real.has_le
           (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
              (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
                 (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
           (@set.indicator.{u 0} α real
              (@add_monoid.to_has_zero.{0} real
                 (@add_group.to_add_monoid.{0} real
                    (@add_comm_group.to_add_group.{0} real
                       (@normed_group.to_add_comm_group.{0} real
                          (@normed_ring.to_normed_group.{0} real
                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
              (s (@has_zero.zero.{0} nat nat.has_zero))
              (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
              a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @has_le.le.{0} real real.has_le
         (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
               (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
         (@set.indicator.{u 0} α real
            (@add_monoid.to_has_zero.{0} real
               (@add_group.to_add_monoid.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
            (s (@has_zero.zero.{0} nat nat.has_zero))
            (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ ∀ (a : α),
    @has_le.le.{0} real real.has_le
      (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
            (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
            β
            ((λ (a : α), f a) a)
            (@has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
      (@set.indicator.{u 0} α real
         (@add_monoid.to_has_zero.{0} real
            (@add_group.to_add_monoid.{0} real
               (@add_comm_group.to_add_group.{0} real
                  (@normed_group.to_add_comm_group.{0} real
                     (@normed_ring.to_normed_group.{0} real
                        (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
         (s (@has_zero.zero.{0} nat nat.has_zero))
         (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279      assume a,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat
⊢ ∀ (a : α),
    @has_le.le.{0} real real.has_le
      (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
            (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
            β
            ((λ (a : α), f a) a)
            (@has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
      (@set.indicator.{u 0} α real
         (@add_monoid.to_has_zero.{0} real
            (@add_group.to_add_monoid.{0} real
               (@add_comm_group.to_add_group.{0} real
                  (@normed_group.to_add_comm_group.{0} real
                     (@normed_ring.to_normed_group.{0} real
                        (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
         (s (@has_zero.zero.{0} nat nat.has_zero))
         (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
          (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
          β
          ((λ (a : α), f a) a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (s (@has_zero.zero.{0} nat nat.has_zero))
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280      rw [norm_indicator_eq_indicator_norm],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='norm_indicator_eq_indicator_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : normed_group.{v} β] {s : set.{u} α} (f : α → β) (a : α), @eq.{1} real (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) s f a)) (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (f a)) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
          (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
          β
          ((λ (a : α), f a) a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (s (@has_zero.zero.{0} nat nat.has_zero))
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (s i)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) ((λ (a : α), f a) a))
       a)
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (s (@has_zero.zero.{0} nat nat.has_zero))
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281      refine indicator_le_indicator_of_subset (h_mono _ _ (zero_le _)) (λa, norm_nonneg _) _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.indicator_le_indicator_of_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='norm_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 355, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 135, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : has_zero.{0} β] [_inst_2 : preorder.{0} β] {s t : set.{u} α} {f : α → β}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → (∀ (a : α), @has_le.le.{0} β (@preorder.to_has_le.{0} β _inst_2) (@has_zero.zero.{0} β _inst_1) (f a)) → ∀ (a : α), @has_le.le.{0} β (@preorder.to_has_le.{0} β _inst_2) (@set.indicator.{u 0} α β _inst_1 s f a) (@set.indicator.{u 0} α β _inst_1 t f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : canonically_ordered_monoid.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1)))) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_comm_monoid.to_add_monoid.{0} α (@ordered_comm_monoid.to_add_comm_monoid.{0} α (@canonically_ordered_monoid.to_ordered_comm_monoid.{0} α _inst_1))))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : normed_group.{v} α] (g : α), @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (@has_norm.norm.{v} α (@normed_group.to_has_norm.{v} α _inst_1) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)),
i : nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (s i)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) ((λ (a : α), f a) a))
       a)
    (@set.indicator.{u 0} α real
       (@add_monoid.to_has_zero.{0} real
          (@add_group.to_add_monoid.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))))
       (s (@has_zero.zero.{0} nat nat.has_zero))
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282    { filter_upwards [] λa, le_trans (tendsto_indicator_of_antimono _ h_mono _ _) (pure_le_nhds _) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tendsto_indicator_of_antimono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pure_le_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b c : α}, @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b c → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {ι : Type} [_inst_1 : lattice.semilattice_sup.{0} ι] [_inst_2 : has_zero.{v} β] [_inst_3 : nonempty.{1} ι] (s : ι → set.{u} α), (∀ (i j : ι), @has_le.le.{0} ι (@preorder.to_has_le.{0} ι (@partial_order.to_preorder.{0} ι (@lattice.semilattice_sup.to_partial_order.{0} ι _inst_1))) i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i)) → ∀ (f : α → β) (a : α), @filter.tendsto.{0 v} ι β (λ (i : ι), @set.indicator.{u v} α β _inst_2 (s i) f a) (@filter.at_top.{0} ι (@partial_order.to_preorder.{0} ι (@lattice.semilattice_sup.to_partial_order.{0} ι _inst_1))) (@has_pure.pure.{v v} filter.{v} filter.has_pure.{v} β (@set.indicator.{u v} α β _inst_2 (@set.Inter.{u 1} α ι s) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j : nat), @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : topological_space.{v} α], @has_le.le.{v} (α → filter.{v} α) (@preorder.to_has_le.{v} (α → filter.{v} α) (@pi.preorder.{v v} α (λ (a : α), filter.{v} α) (λ (i : α), @partial_order.to_preorder.{v} (filter.{v} α) (@filter.partial_order.{v} α)))) (@has_pure.pure.{v v} (λ {α : Type v}, filter.{v} α) filter.has_pure.{v} α) (@nhds.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hsm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
h_mono :
  ∀ (i j : nat),
    @has_le.le.{0} nat nat.has_le i j → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) (s j) (s i),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (s (@has_zero.zero.{0} nat nat.has_zero)) f,
bound : α → real :=
  @set.indicator.{u 0} α real
    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
    (s (@has_zero.zero.{0} nat nat.has_zero))
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} nat β
         (λ (n : nat),
            @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s n))
              (@set.decidable_mem.{u} α (s n) (λ (a : α), classical.prop_decidable (s n a)) a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Inter.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Inter.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Inter.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  -- TODO : prove this for an encodable type</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286  -- by proving an encodable version of `filter.has_countable_basis_at_top_finset_nat`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  lemma integral_on_Union (s : ℕ → set α) (f : α → β) (hm : ∀i, is_measurable (s i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measurable_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='orange'><a title='`is_measurable s` means that `s` is measurable (in the ambient measure space on `α`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288    (hd : ∀ i j, i ≠ j → s i ∩ s j = ∅) (hfm : measurable_on (Union s) f) (hfi : integrable_on (Union s) f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_emptyc.emptyc'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measurable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 332, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inter.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [c : has_emptyc.{u} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measurable_space.{u} α] [_inst_2 : measurable_space.{v} β] [_inst_3 : has_zero.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β], set.{u} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='`measurable_on s f` means `f` is measurable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289    (∫ a in (Union s), f a) = ∑i, ∫ a in s i, f a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tsum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type v} {ι : Sort x}, (ι → set.{v} β) → set.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} {β : Type} [_inst_1 : add_comm_monoid.{v} α] [_inst_2 : topological_space.{v} α], (β → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} {β : Type} [_inst_1 : add_comm_monoid.{v} α] [_inst_2 : topological_space.{v} α], (β → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`tsum f` is the sum of `f` it exists, or 0 otherwise'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`tsum f` is the sum of `f` it exists, or 0 otherwise'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  suffices h : tendsto (λn:finset ℕ, n.sum (λ i, ∫ a in s i, f a)) at_top (𝓝 $ (∫ a in (Union s), f a)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {α : Type} {β : Type v}, (α → β) → filter.{0} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{0} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [_inst_1 : topological_space.{v} α], α → filter.{v} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`finset α` is the type of finite sets of elements of `α`. It is implemented
 as a multiset (a list up to permutation) which has no duplicate elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291    by { rwa tsum_eq_has_sum },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='tsum_eq_has_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/infinite_sum.lean&#x27;, &#x27;line&#x27;: 292, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type} [_inst_1 : add_comm_monoid.{v} α] [_inst_2 : topological_space.{v} α] [_inst_3 : @t2_space.{v} α _inst_2] {f : β → α} {a : α}, @has_sum.{v 0} α β _inst_1 _inst_2 f a → @eq.{v+1} α (@tsum.{v 0} α β _inst_1 _inst_2 (λ (b : β), f b)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
h :
  @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@set.Union.{u 1} α nat s)
          (λ (a : α), f a)))
    (@tsum.{v 0} β nat (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (λ (i : nat),
          @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               (s i)
               (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293    have : (λn:finset ℕ, n.sum (λ i, ∫ a in s i, f a)) = λn:finset ℕ, ∫ a in (⋃i∈n, s i), f a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='measure_theory.integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1027, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='finset.{0} nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{0} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))], (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`finset α` is the type of finite sets of elements of `α`. It is implemented
 as a multiset (a list up to permutation) which has no duplicate elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The Bochner integral'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f
⊢ @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294    { funext,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1489, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Apply function extensionality and introduce new hypotheses.
The tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to
```lean
  |-  ((fun x, ...) = (fun x, ...))
```
The variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='funext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f
⊢ @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f
⊢ @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ @eq.{v+1} β
    (@finset.sum.{0 v} nat β
       (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
       n
       (λ (i : nat),
          @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               (s i)
               (λ (a : α), f a))))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@set.Union.{u 1} α nat
             (λ (i : nat),
                @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                  (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
          (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295      rw [← integral_finset_sum, indicator_finset_bUnion],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='measure_theory.integral_finset_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.indicator_finset_bUnion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1298, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {ι : Type} (s : finset.{0} ι) {f : ι → α → β}, (∀ (i : ι), @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (f i)) → (∀ (i : ι), @measure_theory.integrable.{u v} α _inst_1 β _inst_2 (f i)) → @eq.{v+1} β (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), @finset.sum.{0 v} ι β (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)) s (λ (i : ι), f i a))) (@finset.sum.{0 v} ι β (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)) s (λ (i : ι), @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f i a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_2 : add_comm_monoid.{v} β] {ι : Type} (I : finset.{0} ι) (s : ι → set.{u} α) {f : α → β}, (∀ (i : ι), @has_mem.mem.{0 0} ι (finset.{0} ι) (@finset.has_mem.{0} ι) i I → ∀ (j : ι), @has_mem.mem.{0 0} ι (finset.{0} ι) (@finset.has_mem.{0} ι) j I → @ne.{1} ι i j → @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))) → @eq.{(max (u+1) (v+1))} (α → β) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_2)) (@set.Union.{u 1} α ι (λ (i : ι), @set.Union.{u 0} α (@has_mem.mem.{0 0} ι (finset.{0} ι) (@finset.has_mem.{0} ι) i I) (λ (H : @has_mem.mem.{0 0} ι (finset.{0} ι) (@finset.has_mem.{0} ι) i I), s i))) f) (λ (a : α), @finset.sum.{0 v} ι β _inst_2 I (λ (i : ι), @set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_2)) (s i) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ @eq.{v+1} β
    (@finset.sum.{0 v} nat β
       (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
       n
       (λ (i : nat),
          @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
            (@set.indicator.{u v} α β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
               (s i)
               (λ (a : α), f a))))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@set.Union.{u 1} α nat
             (λ (i : nat),
                @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                  (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
          (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ @eq.{v+1} β
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (λ (a : α),
          @finset.sum.{0 v} nat β
            (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
            n
            (λ (i : nat),
               @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
                 (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
                 β
                 ((λ (a : α), f a) a)
                 (@has_zero.zero.{v} β
                    (@add_monoid.to_has_zero.{v} β
                       (@add_group.to_add_monoid.{v} β
                          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))
    (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@set.Union.{u 1} α nat
             (λ (i : nat),
                @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                  (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
          (λ (a : α), f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measure_theory.integrable.{u v} α _inst_1 β _inst_2
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n →
    ∀ (j : nat),
      @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) j n →
      @ne.{1} nat i j →
      @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measure_theory.integrable.{u v} α _inst_1 β _inst_2
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296      { assume i hi j hj hij, exact hd i j hij },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i j : nat), @ne.{1} nat i j → @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j)) (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{1} nat i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n →
    ∀ (j : nat),
      @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) j n →
      @ne.{1} nat i j →
      @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measure_theory.integrable.{u v} α _inst_1 β _inst_2
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n →
    ∀ (j : nat),
      @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) j n →
      @ne.{1} nat i j →
      @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
        (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat,
i : nat,
hi : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n,
j : nat,
hj : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) j n,
hij : @ne.{1} nat i j
⊢ @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
    (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measure_theory.integrable.{u v} α _inst_1 β _inst_2
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297      { assume i, refine hfm.subset (hm _) (subset_Union _ _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (@set.Union.{u 1} α nat s) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u} {ι : Type} (s : ι → set.{u} β) (i : ι), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (s i) (@set.Union.{u 1} β ι (λ (i : ι), s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measure_theory.integrable.{u v} α _inst_1 β _inst_2
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
      (@borel.{v} β
         (@uniform_space.to_topological_space.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat,
i : nat
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
         (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measure_theory.integrable.{u v} α _inst_1 β _inst_2
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298      { assume i, refine hfi.subset (subset_Union _ _) } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='hfi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {β : Type u} {ι : Type} (s : ι → set.{u} β) (i : ι), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (s i) (@set.Union.{u 1} β ι (λ (i : ι), s i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat
⊢ ∀ (i : nat),
    @measure_theory.integrable.{u v} α _inst_1 β _inst_2
      (λ (a : α),
         @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
           (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
           β
           ((λ (a : α), f a) a)
           (@has_zero.zero.{v} β
              (@add_monoid.to_has_zero.{v} β
                 (@add_group.to_add_monoid.{v} β
                    (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
n : finset.{0} nat,
i : nat
⊢ @measure_theory.integrable.{u v} α _inst_1 β _inst_2
    (λ (a : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (s i))
         (@set.decidable_mem.{u} α (s i) (λ (a : α), classical.prop_decidable (s i a)) a)
         β
         ((λ (a : α), f a) a)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299    rw this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max 1 (v+1))} (finset.{0} nat → β) (λ (n : finset.{0} nat), @finset.sum.{0 v} nat β (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)) n (λ (i : nat), @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (s i) (λ (a : α), f a)))) (λ (n : finset.{0} nat), @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (@set.Union.{u 1} α nat (λ (i : nat), @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n) (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))) (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300    refine tendsto_integral_filter_of_dominated_convergence _ _ _ _ _ _ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='measure_theory.tendsto_integral_filter_of_dominated_convergence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/bochner_integration.lean&#x27;, &#x27;line&#x27;: 1154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measure_theory.measure_space.{u} α] {β : Type v} [_inst_2 : normed_group.{v} β] [_inst_3 : @topological_space.second_countable_topology.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))] [_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2] [_inst_5 : @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))] {ι : Type} {l : filter.{0} ι} {F : ι → α → β} {f : α → β} (bound : α → real), @filter.has_countable_basis.{0} ι l → @filter.eventually.{0} ι (λ (n : ι), @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (F n)) l → @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) f → @filter.eventually.{0} ι (λ (n : ι), @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (F n a)) (bound a))) l → @measure_theory.integrable.{u 0} α _inst_1 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) bound → @measure_theory.all_ae.{u} α _inst_1 (λ (a : α), @filter.tendsto.{0 v} ι β (λ (n : ι), F n a) l (@nhds.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))) (f a))) → @filter.tendsto.{0 v} ι β (λ (n : ι), @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), F n a)) l (@nhds.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))) (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5 (λ (a : α), f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Lebesgue dominated convergence theorem for filters with a countable basis'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.tendsto.{0 v} (finset.{0} nat) β
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
       (@measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
          (@set.indicator.{u v} α β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
             (@set.Union.{u 1} α nat s)
             (λ (a : α), f a))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='7 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ α → real

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.has_countable_basis.{0} (finset.{0} nat)
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
         (@borel.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
         (λ (x : α),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 x)
              β
              ((λ (a : α), f a) x)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (?m_1 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301    { exact indicator (Union s) (λ a, ∥f a∥) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.indicator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/indicator_function.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type} [_inst_1 : has_zero.{0} β], set.{u} α → (α → β) → α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {β : Type u} {ι : Type}, (ι → set.{u} β) → set.{u} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Indexed union of a family of sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='7 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ α → real

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.has_countable_basis.{0} (finset.{0} nat)
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
         (@borel.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
         (λ (x : α),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 x)
              β
              ((λ (a : α), f a) x)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (?m_1 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    ?m_1

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='6 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.has_countable_basis.{0} (finset.{0} nat)
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
         (@borel.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
         (λ (x : α),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 x)
              β
              ((λ (a : α), f a) x)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302    { exact has_countable_basis_at_top_finset_nat },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.has_countable_basis_at_top_finset_nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/bases.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.has_countable_basis.{0} (finset.{0} nat) (@filter.at_top.{0} (finset.{0} nat) (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='6 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.has_countable_basis.{0} (finset.{0} nat)
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
         (@borel.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
         (λ (x : α),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 x)
              β
              ((λ (a : α), f a) x)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.has_countable_basis.{0} (finset.{0} nat)
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
         (@borel.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
         (λ (x : α),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 x)
              β
              ((λ (a : α), f a) x)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303    { refine univ_mem_sets&#x27; (λ n, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.univ_mem_sets&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f : filter.{0} α} {s : set.{0} α}, (∀ (a : α), @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) a s) → @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
         (@borel.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
         (λ (x : α),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 x)
              β
              ((λ (a : α), f a) x)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
         (@borel.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
         (λ (x : α),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 x)
              β
              ((λ (a : α), f a) x)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) n
    (@set_of.{0} (finset.{0} nat)
       (λ (x : finset.{0} nat),
          (λ (n : finset.{0} nat),
             @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
               (@borel.{v} β
                  (@uniform_space.to_topological_space.{v} β
                     (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
               (λ (x : α),
                  @ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       x)
                    β
                    ((λ (a : α), f a) x)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304      simp only [mem_set_of_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ @has_mem.mem.{0 0} (finset.{0} nat) (set.{0} (finset.{0} nat)) (@set.has_mem.{0} (finset.{0} nat)) n
    (@set_of.{0} (finset.{0} nat)
       (λ (x : finset.{0} nat),
          (λ (n : finset.{0} nat),
             @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
               (@borel.{v} β
                  (@uniform_space.to_topological_space.{v} β
                     (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
               (λ (x : α),
                  @ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       x)
                    β
                    ((λ (a : α), f a) x)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1}
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
         (@set.decidable_mem.{u} α
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α),
               classical.prop_decidable
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                    a))
            x)
         β
         (f x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305      refine hfm.subset (is_measurable.Union (λ i, is_measurable.Union_Prop (λh, hm _)))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hfm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_measurable.Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_measurable.Union_Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 62, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 106, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/measurable_space.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (@borel.{v} β (@uniform_space.to_topological_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))) (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))) (@set.Union.{u 1} α nat s) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : measurable_space.{u} α] [_inst_2 : encodable.{0} β] {f : β → set.{u} α}, (∀ (b : β), @is_measurable.{u} α _inst_1 (f b)) → @is_measurable.{u} α _inst_1 (@set.Union.{u 1} α β (λ (b : β), f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : measurable_space.{u} α] {p : Prop} {f : p → set.{u} α}, (∀ (b : p), @is_measurable.{u} α _inst_1 (f b)) → @is_measurable.{u} α _inst_1 (@set.Union.{u 0} α p (λ (b : p), f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1}
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
         (@set.decidable_mem.{u} α
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α),
               classical.prop_decidable
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                    a))
            x)
         β
         (f x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306        (bUnion_subset_Union _ _), },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.bUnion_subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 468, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {β : Type u} (s : set.{0} α) (t : α → set.{u} β), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (@set.Union.{u 1} β α (λ (x : α), @set.Union.{u 0} β (@has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x s) (λ (H : @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x s), t x))) (@set.Union.{u 1} β α (λ (x : α), t x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1}
         (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
         (@set.decidable_mem.{u} α
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α),
               classical.prop_decidable
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                    a))
            x)
         β
         (f x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307    { assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measurable.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (λ (x : α),
       @ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.Union.{u 1} α nat s))
         (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
            (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
            x)
         β
         ((λ (a : α), f a) x)
         (@has_zero.zero.{v} β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308    { refine univ_mem_sets&#x27; (λ n, univ_mem_sets&#x27; $ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='filter.univ_mem_sets&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f : filter.{0} α} {s : set.{0} α}, (∀ (a : α), @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) a s) → @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @filter.eventually.{0} (finset.{0} nat)
    (λ (n : finset.{0} nat),
       @measure_theory.all_ae.{u} α _inst_1
         (λ (a : α),
            @has_le.le.{0} real real.has_le
              (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                 (@ite.{v+1}
                    (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
                    (@set.decidable_mem.{u} α
                       (@set.Union.{u 1} α nat
                          (λ (i : nat),
                             @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                               (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                       (λ (a : α),
                          classical.prop_decidable
                            (@set.Union.{u 1} α nat
                               (λ (i : nat),
                                  @set.Union.{u 0} α
                                    (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                       s i))
                               a))
                       a)
                    β
                    ((λ (a : α), f a) a)
                    (@has_zero.zero.{v} β
                       (@add_monoid.to_has_zero.{v} β
                          (@add_group.to_add_monoid.{v} β
                             (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
              (@set.indicator.{u 0} α real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                 (@set.Union.{u 1} α nat s)
                 (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                 a)))
    (@filter.at_top.{0} (finset.{0} nat)
       (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ ∀ (a : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
      (@set_of.{u} α
         (λ (x : α),
            (λ (a : α),
               (λ (a : α),
                  @has_le.le.{0} real real.has_le
                    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                       (@ite.{v+1}
                          (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                             (@set.Union.{u 1} α nat
                                (λ (i : nat),
                                   @set.Union.{u 0} α
                                     (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                        s i))))
                          (@set.decidable_mem.{u} α
                             (@set.Union.{u 1} α nat
                                (λ (i : nat),
                                   @set.Union.{u 0} α
                                     (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                        s i)))
                             (λ (a : α),
                                classical.prop_decidable
                                  (@set.Union.{u 1} α nat
                                     (λ (i : nat),
                                        @set.Union.{u 0} α
                                          (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                          (λ
                                           (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                             s i))
                                     a))
                             a)
                          β
                          ((λ (a : α), f a) a)
                          (@has_zero.zero.{v} β
                             (@add_monoid.to_has_zero.{v} β
                                (@add_group.to_add_monoid.{v} β
                                   (@add_comm_group.to_add_group.{v} β
                                      (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
                    (@set.indicator.{u 0} α real
                       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                       (@set.Union.{u 1} α nat s)
                       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                       a))
                 a)
              x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309      simp only [mem_set_of_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ ∀ (a : α),
    @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
      (@set_of.{u} α
         (λ (x : α),
            (λ (a : α),
               (λ (a : α),
                  @has_le.le.{0} real real.has_le
                    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
                       (@ite.{v+1}
                          (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                             (@set.Union.{u 1} α nat
                                (λ (i : nat),
                                   @set.Union.{u 0} α
                                     (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                        s i))))
                          (@set.decidable_mem.{u} α
                             (@set.Union.{u 1} α nat
                                (λ (i : nat),
                                   @set.Union.{u 0} α
                                     (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                        s i)))
                             (λ (a : α),
                                classical.prop_decidable
                                  (@set.Union.{u 1} α nat
                                     (λ (i : nat),
                                        @set.Union.{u 0} α
                                          (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                                          (λ
                                           (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n),
                                             s i))
                                     a))
                             a)
                          β
                          ((λ (a : α), f a) a)
                          (@has_zero.zero.{v} β
                             (@add_monoid.to_has_zero.{v} β
                                (@add_group.to_add_monoid.{v} β
                                   (@add_comm_group.to_add_group.{v} β
                                      (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
                    (@set.indicator.{u 0} α real
                       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
                       (@set.Union.{u 1} α nat s)
                       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
                       a))
                 a)
              x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ ∀ (a : α),
    @has_le.le.{0} real real.has_le
      (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@ite.{v+1}
            (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
               (@set.Union.{u 1} α nat
                  (λ (i : nat),
                     @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                       (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
            (@set.decidable_mem.{u} α
               (@set.Union.{u 1} α nat
                  (λ (i : nat),
                     @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                       (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
               (λ (a : α),
                  classical.prop_decidable
                    (@set.Union.{u 1} α nat
                       (λ (i : nat),
                          @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                            (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                       a))
               a)
            β
            (f a)
            (@has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
      (@set.indicator.{u 0} α real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
         (@set.Union.{u 1} α nat s)
         (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310      assume a,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat
⊢ ∀ (a : α),
    @has_le.le.{0} real real.has_le
      (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
         (@ite.{v+1}
            (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
               (@set.Union.{u 1} α nat
                  (λ (i : nat),
                     @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                       (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
            (@set.decidable_mem.{u} α
               (@set.Union.{u 1} α nat
                  (λ (i : nat),
                     @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                       (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
               (λ (a : α),
                  classical.prop_decidable
                    (@set.Union.{u 1} α nat
                       (λ (i : nat),
                          @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                            (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                       a))
               a)
            β
            (f a)
            (@has_zero.zero.{v} β
               (@add_monoid.to_has_zero.{v} β
                  (@add_group.to_add_monoid.{v} β
                     (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
      (@set.indicator.{u 0} α real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
         (@set.Union.{u 1} α nat s)
         (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1}
          (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
          (@set.decidable_mem.{u} α
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
             (λ (a : α),
                classical.prop_decidable
                  (@set.Union.{u 1} α nat
                     (λ (i : nat),
                        @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                          (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                     a))
             a)
          β
          (f a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311      rw ← norm_indicator_eq_indicator_norm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='norm_indicator_eq_indicator_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : normed_group.{v} β] {s : set.{u} α} (f : α → β) (a : α), @eq.{1} real (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) s f a)) (@set.indicator.{u 0} α real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) s (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (f a)) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1}
          (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
          (@set.decidable_mem.{u} α
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
             (λ (a : α),
                classical.prop_decidable
                  (@set.Union.{u 1} α nat
                     (λ (i : nat),
                        @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                          (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                     a))
             a)
          β
          (f a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1}
          (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
          (@set.decidable_mem.{u} α
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
             (λ (a : α),
                classical.prop_decidable
                  (@set.Union.{u 1} α nat
                     (λ (i : nat),
                        @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                          (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                     a))
             a)
          β
          (f a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@set.Union.{u 1} α nat s)
          (λ (a : α), f a)
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312      refine norm_indicator_le_of_subset (bUnion_subset_Union _ _) _ _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='norm_indicator_le_of_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.bUnion_subset_Union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 468, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : normed_group.{v} β] {s t : set.{u} α}, @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s t → ∀ (f : α → β) (a : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) s f a)) (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_1) (@set.indicator.{u v} α β (@add_monoid.to_has_zero.{v} β (@add_group.to_add_monoid.{v} β (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_1)))) t f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {β : Type u} (s : set.{0} α) (t : α → set.{u} β), @has_subset.subset.{u} (set.{u} β) (@set.has_subset.{u} β) (@set.Union.{u 1} β α (λ (x : α), @set.Union.{u 0} β (@has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x s) (λ (H : @has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) x s), t x))) (@set.Union.{u 1} β α (λ (x : α), t x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a))),
n : finset.{0} nat,
a : α
⊢ @has_le.le.{0} real real.has_le
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@ite.{v+1}
          (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
          (@set.decidable_mem.{u} α
             (@set.Union.{u 1} α nat
                (λ (i : nat),
                   @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                     (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
             (λ (a : α),
                classical.prop_decidable
                  (@set.Union.{u 1} α nat
                     (λ (i : nat),
                        @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                          (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                     a))
             a)
          β
          (f a)
          (@has_zero.zero.{v} β
             (@add_monoid.to_has_zero.{v} β
                (@add_group.to_add_monoid.{v} β
                   (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2)))))))
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2)
       (@set.indicator.{u v} α β
          (@add_monoid.to_has_zero.{v} β
             (@add_group.to_add_monoid.{v} β
                (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
          (@set.Union.{u 1} α nat s)
          (λ (a : α), f a)
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313    { rw [← integrable_on, integrable_on_norm_iff], assumption },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='integrable_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='integrable_on_norm_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 162, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : measure_theory.measure_space.{?l_1} α] [_inst_2 : normed_group.{?l_2} β], set.{?l_1} α → (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : measure_theory.measure_space.{u} α] [_inst_2 : normed_group.{v} β] (s : set.{u} α) (f : α → β), iff (@integrable_on.{u 0} α real _inst_1 (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) s (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))) (@integrable_on.{u v} α β _inst_1 _inst_2 s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`integrable_on s f` means `f` is integrable over the set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))

α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.integrable.{u 0} α _inst_1 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.indicator.{u 0} α real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))
       (@set.Union.{u 1} α nat s)
       (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @integrable_on.{u 0} α real _inst_1
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@set.Union.{u 1} α nat s)
    (λ (a : α), @has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β _inst_2) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) (λ (a : α), f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314    { filter_upwards [] λa, le_trans (tendsto_indicator_bUnion_finset _ _ _) (pure_le_nhds _) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tendsto_indicator_bUnion_finset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='pure_le_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/measure_theory/indicator_function.lean&#x27;, &#x27;line&#x27;: 152, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : preorder.{v} α] {a b c : α}, @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a b → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) b c → @has_le.le.{v} α (@preorder.to_has_le.{v} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {ι : Type} [_inst_1 : lattice.semilattice_sup.{0} ι] [_inst_2 : has_zero.{v} β] (s : ι → set.{u} α) (f : α → β) (a : α), @filter.tendsto.{0 v} (finset.{0} ι) β (λ (n : finset.{0} ι), @set.indicator.{u v} α β _inst_2 (@set.Union.{u 1} α ι (λ (i : ι), @set.Union.{u 0} α (@has_mem.mem.{0 0} ι (finset.{0} ι) (@finset.has_mem.{0} ι) i n) (λ (H : @has_mem.mem.{0 0} ι (finset.{0} ι) (@finset.has_mem.{0} ι) i n), s i))) f a) (@filter.at_top.{0} (finset.{0} ι) (@partial_order.to_preorder.{0} (finset.{0} ι) (@finset.partial_order.{0} ι))) (@has_pure.pure.{v v} filter.{v} filter.has_pure.{v} β (@set.indicator.{u v} α β _inst_2 (@set.Union.{u 1} α ι s) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : topological_space.{v} α], @has_le.le.{v} (α → filter.{v} α) (@preorder.to_has_le.{v} (α → filter.{v} α) (@pi.preorder.{v v} α (λ (a : α), filter.{v} α) (λ (i : α), @partial_order.to_preorder.{v} (filter.{v} α) (@filter.partial_order.{v} α)))) (@has_pure.pure.{v v} (λ {α : Type v}, filter.{v} α) filter.has_pure.{v} α) (@nhds.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
β : Type v,
_inst_1 : measure_theory.measure_space.{u} α,
_inst_2 : normed_group.{v} β,
_inst_3 :
  @topological_space.second_countable_topology.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))),
_inst_4 : @normed_space.{0 v} real β normed_field.normed_field _inst_2,
_inst_5 :
  @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)),
s : nat → set.{u} α,
f : α → β,
hm : ∀ (i : nat), @is_measurable.{u} α (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1) (s i),
hd :
  ∀ (i j : nat),
    @ne.{1} nat i j →
    @eq.{u+1} (set.{u} α) (@has_inter.inter.{u} (set.{u} α) (@set.has_inter.{u} α) (s i) (s j))
      (@has_emptyc.emptyc.{u} (set.{u} α) (@set.has_emptyc.{u} α)),
hfm :
  @measurable_on.{u v} α β (@measure_theory.measure_space.to_measurable_space.{u} α _inst_1)
    (@borel.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2))))
    (@add_monoid.to_has_zero.{v} β
       (@add_group.to_add_monoid.{v} β
          (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
    (@set.Union.{u 1} α nat s)
    f,
hfi : @integrable_on.{u v} α β _inst_1 _inst_2 (@set.Union.{u 1} α nat s) f,
this :
  @eq.{(max 1 (v+1))} (finset.{0} nat → β)
    (λ (n : finset.{0} nat),
       @finset.sum.{0 v} nat β
         (@add_comm_group.to_add_comm_monoid.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))
         n
         (λ (i : nat),
            @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
              (@set.indicator.{u v} α β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
                 (s i)
                 (λ (a : α), f a))))
    (λ (n : finset.{0} nat),
       @measure_theory.integral.{u v} α _inst_1 β _inst_2 _inst_3 _inst_4 _inst_5
         (@set.indicator.{u v} α β
            (@add_monoid.to_has_zero.{v} β
               (@add_group.to_add_monoid.{v} β
                  (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))
            (@set.Union.{u 1} α nat
               (λ (i : nat),
                  @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                    (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
            (λ (a : α), f a)))
⊢ @measure_theory.all_ae.{u} α _inst_1
    (λ (a : α),
       @filter.tendsto.{0 v} (finset.{0} nat) β
         (λ (n : finset.{0} nat),
            @ite.{v+1}
              (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))))
              (@set.decidable_mem.{u} α
                 (@set.Union.{u 1} α nat
                    (λ (i : nat),
                       @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                         (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i)))
                 (λ (a : α),
                    classical.prop_decidable
                      (@set.Union.{u 1} α nat
                         (λ (i : nat),
                            @set.Union.{u 0} α (@has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n)
                              (λ (H : @has_mem.mem.{0 0} nat (finset.{0} nat) (@finset.has_mem.{0} nat) i n), s i))
                         a))
                 a)
              β
              ((λ (a : α), f a) a)
              (@has_zero.zero.{v} β
                 (@add_monoid.to_has_zero.{v} β
                    (@add_group.to_add_monoid.{v} β
                       (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))
         (@filter.at_top.{0} (finset.{0} nat)
            (@partial_order.to_preorder.{0} (finset.{0} nat) (@finset.partial_order.{0} nat)))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_group.to_metric_space.{v} β _inst_2)))
            (@ite.{v+1} (@has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) a (@set.Union.{u 1} α nat s))
               (@set.decidable_mem.{u} α (@set.Union.{u 1} α nat s)
                  (λ (a : α), classical.prop_decidable (@set.Union.{u 1} α nat s a))
                  a)
               β
               ((λ (a : α), f a) a)
               (@has_zero.zero.{v} β
                  (@add_monoid.to_has_zero.{v} β
                     (@add_group.to_add_monoid.{v} β
                        (@add_comm_group.to_add_group.{v} β (@normed_group.to_add_comm_group.{v} β _inst_2))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317  end integral_on</code></pre>
</body>