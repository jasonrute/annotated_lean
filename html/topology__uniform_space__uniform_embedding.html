<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Johannes Hölzl. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Johannes Hölzl, Sébastien Gouëzel, Patrick Massot</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  Uniform embeddings of uniform spaces. Extension of uniform continuous functions.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import topology.uniform_space.cauchy topology.uniform_space.separation</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/separation.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  import topology.dense_embedding</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open filter topological_space lattice set classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open_locale classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  open_locale uniformity topological_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {α : Type*} {β : Type*} {γ : Type*}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17            [uniform_space α] [uniform_space β] [uniform_space γ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='uniform_space.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='uniform_space.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  universe u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  structure uniform_inducing (f : α → β) : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  (comap_uniformity : comap (λx:α×α, (f x.1, f x.2)) (𝓤 β) = 𝓤 α)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{v} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : uniform_space.{u_2} α], filter.{u_2} (prod.{u_2 u_2} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  lemma uniform_inducing.mk&#x27; {f : α → β} (h : ∀ s, s ∈ 𝓤 α ↔</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24      ∃ t ∈ 𝓤 β, ∀ x y : α, (f x, f y) ∈ t → (x, y) ∈ s) : uniform_inducing f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : uniform_space.{u_2} α], filter.{u_2} (prod.{u_2 u_2} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  ⟨by simp [eq_comm, filter.ext_iff, subset_def, h]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 111, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {a b : α}, iff (@eq.{?l_1} α a b) (@eq.{?l_1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {f g : filter.{?l_1} α}, iff (@eq.{?l_1+1} (filter.{?l_1} α) f g) (∀ (s : set.{?l_1} α), iff (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s f) (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, @eq.{1} Prop (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) s t) (∀ (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{u_1} (prod.{u_1 u_1} α α)), iff (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1)) (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), @Exists.{0} (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t (@uniformity.{u_2} β _inst_2)) (λ (H : @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t (@uniformity.{u_2} β _inst_2)), ∀ (x y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  lemma uniform_inducing.comp {g : β → γ} (hg : uniform_inducing g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    {f : α → β} (hf : uniform_inducing f) : uniform_inducing (g ∘ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  ⟨ by rw [show (λ (x : α × α), ((g ∘ f) x.1, (g ∘ f) x.2)) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u_1 u_3)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f (@prod.fst.{u_1 u_1} α α x))
            (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_3} γ _inst_3))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30           (λ y : β × β, (g y.1, g y.2)) ∘ (λ x : α × α, (f x.1, f x.2)), by ext ; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f (@prod.fst.{u_1 u_1} α α x))
            (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_3} γ _inst_3))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @eq.{(max (u_1+1) (u_3+1))} (prod.{u_1 u_1} α α → prod.{u_3 u_3} γ γ)
    (λ (x : prod.{u_1 u_1} α α),
       @prod.mk.{u_3 u_3} γ γ (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f (@prod.fst.{u_1 u_1} α α x))
         (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f (@prod.snd.{u_1 u_1} α α x)))
    (@function.comp.{u_1+1 u_2+1 u_3+1} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (y : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (g (@prod.fst.{u_2 u_2} β β y)) (g (@prod.snd.{u_2 u_2} β β y)))
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (@function.comp.{u_1+1 u_2+1 u_3+1} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
          (λ (y : prod.{u_2 u_2} β β),
             @prod.mk.{u_3 u_3} γ γ (g (@prod.fst.{u_2 u_2} β β y)) (g (@prod.snd.{u_2 u_2} β β y)))
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))))
       (@uniformity.{u_3} γ _inst_3))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31          ← filter.comap_comap_comp, hg.1, hf.1]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.comap_comap_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 914, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} {β : Type u_2} {γ : Type u_1} {f : filter.{u_3} α} {m : γ → β} {n : β → α}, @eq.{u_1+1} (filter.{u_1} γ) (@filter.comap.{u_1 u_2} γ β m (@filter.comap.{u_2 u_3} β α n f)) (@filter.comap.{u_1 u_3} γ α (@function.comp.{u_1+1 u_2+1 u_3+1} γ β α n m) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (@function.comp.{u_1+1 u_2+1 u_3+1} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
          (λ (y : prod.{u_2 u_2} β β),
             @prod.mk.{u_3 u_3} γ γ (g (@prod.fst.{u_2 u_2} β β y)) (g (@prod.snd.{u_2 u_2} β β y)))
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))))
       (@uniformity.{u_3} γ _inst_3))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@filter.comap.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
          (λ (y : prod.{u_2 u_2} β β),
             @prod.mk.{u_3 u_3} γ γ (g (@prod.fst.{u_2 u_2} β β y)) (g (@prod.snd.{u_2 u_2} β β y)))
          (@uniformity.{u_3} γ _inst_3)))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  structure uniform_embedding (f : α → β) extends uniform_inducing f : Prop :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  (inj : function.injective f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  lemma uniform_embedding.comp {g : β → γ} (hg : uniform_embedding g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    {f : α → β} (hf : uniform_embedding f) : uniform_embedding (g ∘ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  { inj := function.injective_comp hg.inj hf.inj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='function.injective_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {φ : Type u_3} {g : β → φ} {f : α → β}, @function.injective.{u_2+1 u_3+1} β φ g → @function.injective.{u_1+1 u_2+1} α β f → @function.injective.{u_1+1 u_3+1} α φ (@function.comp.{u_1+1 u_2+1 u_3+1} α β φ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_embedding.{u_2 u_3} β γ _inst_2 _inst_3 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_3} β] {f : α → β}, @uniform_embedding.{u_2 u_3} α β _inst_1 _inst_2 f → @function.injective.{u_2+1 u_3+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @function.injective.{u_1+1 u_2+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39    ..hg.to_uniform_inducing.comp hf.to_uniform_inducing }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.to_uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.to_uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 27, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@uniform_embedding.{u_2 u_3} β γ _inst_2 _inst_3 g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_3} β] {f : α → β}, @uniform_embedding.{u_2 u_3} α β _inst_1 _inst_2 f → @uniform_inducing.{u_2 u_3} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] [_inst_3 : uniform_space.{u_3} γ] {g : β → γ}, @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g → ∀ {f : α → β}, @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f → @uniform_inducing.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  theorem uniform_embedding_def {f : α → β} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    uniform_embedding f ↔ function.injective f ∧ ∀ s, s ∈ 𝓤 α ↔</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43      ∃ t ∈ 𝓤 β, ∀ x y : α, (f x, f y) ∈ t → (x, y) ∈ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : uniform_space.{u_2} α], filter.{u_2} (prod.{u_2 u_2} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ iff (@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f)
    (and (@function.injective.{u_1+1 u_2+1} α β f)
       (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
          iff
            (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
               (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
               s
               (@uniformity.{u_1} α _inst_1))
            (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
               (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
                  @Exists.{0}
                    (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                       (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                       t
                       (@uniformity.{u_2} β _inst_2))
                    (λ
                     (H :
                       @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                         (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                         t
                         (@uniformity.{u_2} β _inst_2)),
                       ∀ (x y : α),
                         @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                           (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                           (@prod.mk.{u_2 u_2} β β (f x) (f y))
                           t →
                         @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                           (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                           (@prod.mk.{u_1 u_1} α α x y)
                           s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ iff (@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f)
    (and (@function.injective.{u_1+1 u_2+1} α β f)
       (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
          iff
            (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
               (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
               s
               (@uniformity.{u_1} α _inst_1))
            (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
               (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
                  @Exists.{0}
                    (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                       (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                       t
                       (@uniformity.{u_2} β _inst_2))
                    (λ
                     (H :
                       @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                         (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                         t
                         (@uniformity.{u_2} β _inst_2)),
                       ∀ (x y : α),
                         @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                           (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                           (@prod.mk.{u_2 u_2} β β (f x) (f y))
                           t →
                         @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                           (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                           (@prod.mk.{u_1 u_1} α α x y)
                           s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f →
  and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s)))) →
  @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    { rintro ⟨⟨h⟩, h&#x27;⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f →
  and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s)))) →
  @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f →
  and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h&#x27; : @function.injective.{u_1+1 u_2+1} α β f,
h :
  @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47      rw [eq_comm, filter.ext_iff] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 111, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, iff (@eq.{u_1+1} α a b) (@eq.{u_1+1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {f g : filter.{u_1} α}, iff (@eq.{u_1+1} (filter.{u_1} α) f g) (∀ (s : set.{u_1} α), iff (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f) (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h&#x27; : @function.injective.{u_1+1 u_2+1} α β f,
h :
  @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h&#x27; : @function.injective.{u_1+1 u_2+1} α β f,
h :
  @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@uniformity.{u_1} α _inst_1)
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h&#x27; : @function.injective.{u_1+1 u_2+1} α β f,
h :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
            (λ (x : prod.{u_1 u_1} α α),
               @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
            (@uniformity.{u_2} β _inst_2)))
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h&#x27; : @function.injective.{u_1+1 u_2+1} α β f,
h :
  @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h&#x27; : @function.injective.{u_1+1 u_2+1} α β f,
h :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
            (λ (x : prod.{u_1 u_1} α α),
               @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
            (@uniformity.{u_2} β _inst_2)))
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48      simp [*, subset_def] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.subset_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, @eq.{1} Prop (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) s t) (∀ (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h&#x27; : @function.injective.{u_1+1 u_2+1} α β f,
h :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
            (λ (x : prod.{u_1 u_1} α α),
               @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
            (@uniformity.{u_2} β _inst_2)))
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s)))) →
  @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    { rintro ⟨h, h&#x27;⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ and (@function.injective.{u_1+1 u_2+1} α β f)
    (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       iff
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            s
            (@uniformity.{u_1} α _inst_1))
         (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
            (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
               @Exists.{0}
                 (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    t
                    (@uniformity.{u_2} β _inst_2))
                 (λ
                  (H :
                    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      t
                      (@uniformity.{u_2} β _inst_2)),
                    ∀ (x y : α),
                      @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                        (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                        (@prod.mk.{u_2 u_2} β β (f x) (f y))
                        t →
                      @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                        (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                        (@prod.mk.{u_1 u_1} α α x y)
                        s)))) →
  @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @function.injective.{u_1+1 u_2+1} α β f,
h&#x27; :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50      refine uniform_embedding.mk ⟨_⟩ h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='uniform_embedding.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f → @function.injective.{u_1+1 u_2+1} α β f → @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@function.injective.{u_1+1 u_2+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @function.injective.{u_1+1 u_2+1} α β f,
h&#x27; :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @function.injective.{u_1+1 u_2+1} α β f,
h&#x27; :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      rw [eq_comm, filter.ext_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 111, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, iff (@eq.{u_1+1} α a b) (@eq.{u_1+1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {f g : filter.{u_1} α}, iff (@eq.{u_1+1} (filter.{u_1} α) f g) (∀ (s : set.{u_1} α), iff (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f) (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @function.injective.{u_1+1 u_2+1} α β f,
h&#x27; :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @function.injective.{u_1+1 u_2+1} α β f,
h&#x27; :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@uniformity.{u_1} α _inst_1)
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @function.injective.{u_1+1 u_2+1} α β f,
h&#x27; :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
            (λ (x : prod.{u_1 u_1} α α),
               @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
            (@uniformity.{u_2} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52      simp [*, subset_def] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.subset_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, @eq.{1} Prop (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) s t) (∀ (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @function.injective.{u_1+1 u_2+1} α β f,
h&#x27; :
  ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
         (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
            @Exists.{0}
              (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                 (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 t
                 (@uniformity.{u_2} β _inst_2))
              (λ
               (H :
                 @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                   (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   t
                   (@uniformity.{u_2} β _inst_2)),
                 ∀ (x y : α),
                   @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                     (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                     (@prod.mk.{u_2 u_2} β β (f x) (f y))
                     t →
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α x y)
                     s)))
⊢ ∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
    iff
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@uniformity.{u_1} α _inst_1))
      (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
         (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
         s
         (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
            (λ (x : prod.{u_1 u_1} α α),
               @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
            (@uniformity.{u_2} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  theorem uniform_embedding_def&#x27; {f : α → β} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='_fun_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='and (@function.injective.{u_1+1 u_2+1} α β f) (and (∀ (r : set.{u_2} (prod.{u_2 u_2} β β)), @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) r (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2)) → @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set.has_mem.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set_of.{u_1} (prod.{u_1 u_1} α α) (λ (x : prod.{u_1 u_1} α α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) r)) (@filter.sets.{u_1} (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1))) (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)), @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set.has_mem.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) s (@filter.sets.{u_1} (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1)) → @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), and (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) t (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2))) (∀ (x y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)))) → and (@function.injective.{u_1+1 u_2+1} α β f) (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)), iff (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set.has_mem.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) s (@filter.sets.{u_1} (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1))) (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), and (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) t (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2))) (∀ (x y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    uniform_embedding f ↔ function.injective f ∧ uniform_continuous f ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (@function.injective.{u_1+1 u_2+1} α β f) (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)), iff (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set.has_mem.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) s (@filter.sets.{u_1} (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1))) (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), and (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) t (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2))) (∀ (x y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57      ∀ s, s ∈ 𝓤 α →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58        ∃ t ∈ 𝓤 β, ∀ x y : α, (f x, f y) ∈ t → (x, y) ∈ s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : uniform_space.{u_2} α], filter.{u_2} (prod.{u_2 u_2} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  by simp [uniform_embedding_def, uniform_continuous_def]; exact</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_embedding_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_continuous_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 41, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 430, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β] {f : α → β}, iff (@uniform_embedding.{?l_1 ?l_2} α β _inst_1 _inst_2 f) (and (@function.injective.{?l_1+1 ?l_2+1} α β f) (∀ (s : set.{?l_1} (prod.{?l_1 ?l_1} α α)), iff (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} (prod.{?l_1 ?l_1} α α)) (filter.{?l_1} (prod.{?l_1 ?l_1} α α)) (@filter.has_mem.{?l_1} (prod.{?l_1 ?l_1} α α)) s (@uniformity.{?l_1} α _inst_1)) (@Exists.{?l_2+1} (set.{?l_2} (prod.{?l_2 ?l_2} β β)) (λ (t : set.{?l_2} (prod.{?l_2 ?l_2} β β)), @Exists.{0} (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (prod.{?l_2 ?l_2} β β)) (filter.{?l_2} (prod.{?l_2 ?l_2} β β)) (@filter.has_mem.{?l_2} (prod.{?l_2 ?l_2} β β)) t (@uniformity.{?l_2} β _inst_2)) (λ (H : @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (prod.{?l_2 ?l_2} β β)) (filter.{?l_2} (prod.{?l_2 ?l_2} β β)) (@filter.has_mem.{?l_2} (prod.{?l_2 ?l_2} β β)) t (@uniformity.{?l_2} β _inst_2)), ∀ (x y : α), @has_mem.mem.{?l_2 ?l_2} (prod.{?l_2 ?l_2} β β) (set.{?l_2} (prod.{?l_2 ?l_2} β β)) (@set.has_mem.{?l_2} (prod.{?l_2 ?l_2} β β)) (@prod.mk.{?l_2 ?l_2} β β (f x) (f y)) t → @has_mem.mem.{?l_1 ?l_1} (prod.{?l_1 ?l_1} α α) (set.{?l_1} (prod.{?l_1 ?l_1} α α)) (@set.has_mem.{?l_1} (prod.{?l_1 ?l_1} α α)) (@prod.mk.{?l_1 ?l_1} α α x y) s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β] {f : α → β}, iff (@uniform_continuous.{?l_1 ?l_2} α β _inst_1 _inst_2 f) (∀ (r : set.{?l_2} (prod.{?l_2 ?l_2} β β)), @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} (prod.{?l_2 ?l_2} β β)) (filter.{?l_2} (prod.{?l_2 ?l_2} β β)) (@filter.has_mem.{?l_2} (prod.{?l_2 ?l_2} β β)) r (@uniformity.{?l_2} β _inst_2) → @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} (prod.{?l_1 ?l_1} α α)) (filter.{?l_1} (prod.{?l_1 ?l_1} α α)) (@filter.has_mem.{?l_1} (prod.{?l_1 ?l_1} α α)) (@set_of.{?l_1} (prod.{?l_1 ?l_1} α α) (λ (x : prod.{?l_1 ?l_1} α α), @has_mem.mem.{?l_2 ?l_2} (prod.{?l_2 ?l_2} β β) (set.{?l_2} (prod.{?l_2 ?l_2} β β)) (@set.has_mem.{?l_2} (prod.{?l_2 ?l_2} β β)) (@prod.mk.{?l_2 ?l_2} β β (f (@prod.fst.{?l_1 ?l_1} α α x)) (f (@prod.snd.{?l_1 ?l_1} α α x))) r)) (@uniformity.{?l_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ iff (@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f)
    (and (@function.injective.{u_1+1 u_2+1} α β f)
       (and (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
          (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
             @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
               (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
               s
               (@uniformity.{u_1} α _inst_1) →
             @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
               (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
                  @Exists.{0}
                    (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                       (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                       t
                       (@uniformity.{u_2} β _inst_2))
                    (λ
                     (H :
                       @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                         (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                         t
                         (@uniformity.{u_2} β _inst_2)),
                       ∀ (x y : α),
                         @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                           (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                           (@prod.mk.{u_2 u_2} β β (f x) (f y))
                           t →
                         @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                           (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                           (@prod.mk.{u_1 u_1} α α x y)
                           s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  ⟨λ ⟨I, H⟩, ⟨I, λ s su, (H _).2 ⟨s, su, λ x y, id⟩, λ s, (H s).1⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@function.injective.{u_1+1 u_2+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{u_1} (prod.{u_1 u_1} α α)), iff (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set.has_mem.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) s (@filter.sets.{u_1} (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1))) (@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), and (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) t (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2))) (∀ (x y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Prop}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ iff (@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f)
    (and (@function.injective.{u_1+1 u_2+1} α β f)
       (and (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
          (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
             @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
               (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
               s
               (@uniformity.{u_1} α _inst_1) →
             @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
               (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
                  @Exists.{0}
                    (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                       (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                       t
                       (@uniformity.{u_2} β _inst_2))
                    (λ
                     (H :
                       @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                         (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                         t
                         (@uniformity.{u_2} β _inst_2)),
                       ∀ (x y : α),
                         @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                           (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                           (@prod.mk.{u_2 u_2} β β (f x) (f y))
                           t →
                         @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                           (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                           (@prod.mk.{u_1 u_1} α α x y)
                           s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61   λ ⟨I, H₁, H₂⟩, ⟨I, λ s, ⟨H₂ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='H₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@function.injective.{u_1+1 u_2+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (r : set.{u_2} (prod.{u_2 u_2} β β)), @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) r (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2)) → @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set.has_mem.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set_of.{u_1} (prod.{u_1 u_1} α α) (λ (x : prod.{u_1 u_1} α α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) r)) (@filter.sets.{u_1} (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{u_1} (prod.{u_1 u_1} α α)), @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) (@set.has_mem.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))) s (@filter.sets.{u_1} (prod.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1)) → @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), and (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) t (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2))) (∀ (x y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ iff (@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f)
    (and (@function.injective.{u_1+1 u_2+1} α β f)
       (and (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
          (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
             @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
               (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
               s
               (@uniformity.{u_1} α _inst_1) →
             @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
               (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
                  @Exists.{0}
                    (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                       (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                       t
                       (@uniformity.{u_2} β _inst_2))
                    (λ
                     (H :
                       @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                         (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                         t
                         (@uniformity.{u_2} β _inst_2)),
                       ∀ (x y : α),
                         @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                           (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                           (@prod.mk.{u_2 u_2} β β (f x) (f y))
                           t →
                         @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                           (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                           (@prod.mk.{u_1 u_1} α α x y)
                           s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62     λ ⟨t, tu, h⟩, sets_of_superset _ (H₁ t tu) (λ ⟨a, b⟩, h a b)⟩⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) (@set.has_mem.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))) t (@filter.sets.{u_2} (prod.{u_2 u_2} β β) (@uniformity.{u_2} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} (c : filter.{u_1} α) {x y : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) x (@filter.sets.{u_1} α c) → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) x y → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) y (@filter.sets.{u_1} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ iff (@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f)
    (and (@function.injective.{u_1+1 u_2+1} α β f)
       (and (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
          (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
             @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
               (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
               s
               (@uniformity.{u_1} α _inst_1) →
             @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
               (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
                  @Exists.{0}
                    (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                       (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                       t
                       (@uniformity.{u_2} β _inst_2))
                    (λ
                     (H :
                       @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                         (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                         t
                         (@uniformity.{u_2} β _inst_2)),
                       ∀ (x y : α),
                         @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                           (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                           (@prod.mk.{u_2 u_2} β β (f x) (f y))
                           t →
                         @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                           (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                           (@prod.mk.{u_1 u_1} α α x y)
                           s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β
⊢ iff (@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f)
    (and (@function.injective.{u_1+1 u_2+1} α β f)
       (and (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
          (∀ (s : set.{u_1} (prod.{u_1 u_1} α α)),
             @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
               (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
               s
               (@uniformity.{u_1} α _inst_1) →
             @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
               (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
                  @Exists.{0}
                    (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                       (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                       t
                       (@uniformity.{u_2} β _inst_2))
                    (λ
                     (H :
                       @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
                         (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
                         t
                         (@uniformity.{u_2} β _inst_2)),
                       ∀ (x y : α),
                         @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                           (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                           (@prod.mk.{u_2 u_2} β β (f x) (f y))
                           t →
                         @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                           (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                           (@prod.mk.{u_1 u_1} α α x y)
                           s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  lemma uniform_inducing.uniform_continuous {f : α → β}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    (hf : uniform_inducing f) : uniform_continuous f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  by simp [uniform_continuous, hf.comap_uniformity.symm, tendsto_comap]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='filter.tendsto_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1419, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@uniformity.{u_1} α _inst_1) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {x : filter.{?l_2} β}, @filter.tendsto.{?l_1 ?l_2} α β f (@filter.comap.{?l_1 ?l_2} α β f x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
hf : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  lemma uniform_inducing.uniform_continuous_iff {f : α → β} {g : β → γ} (hg : uniform_inducing g) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                            </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69    uniform_continuous f ↔ uniform_continuous (g ∘ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  by simp [uniform_continuous, tendsto]; rw [← hg.comap_uniformity, ← map_le_iff_le_comap, filter.map_map]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='filter.map_le_iff_le_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.map_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 925, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 795, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2}, (α → β) → filter.{?l_1} α → filter.{?l_2} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.comap.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ) (λ (x : prod.{u_2 u_2} β β), @prod.mk.{u_3 u_3} γ γ (g (@prod.fst.{u_2 u_2} β β x)) (g (@prod.snd.{u_2 u_2} β β x))) (@uniformity.{u_3} γ _inst_3)) (@uniformity.{u_2} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {f : filter.{u_2} α} {g : filter.{u_3} β} {m : α → β}, iff (@has_le.le.{u_3} (filter.{u_3} β) (@preorder.to_has_le.{u_3} (filter.{u_3} β) (@partial_order.to_preorder.{u_3} (filter.{u_3} β) (@filter.partial_order.{u_3} β))) (@filter.map.{u_2 u_3} α β m f) g) (@has_le.le.{u_2} (filter.{u_2} α) (@preorder.to_has_le.{u_2} (filter.{u_2} α) (@partial_order.to_preorder.{u_2} (filter.{u_2} α) (@filter.partial_order.{u_2} α))) f (@filter.comap.{u_2 u_3} α β m g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : filter.{u_1} α} {m : α → β} {m&#x27; : β → γ}, @eq.{u_3+1} (filter.{u_3} γ) (@filter.map.{u_2 u_3} β γ m&#x27; (@filter.map.{u_1 u_2} α β m f)) (@filter.map.{u_1 u_3} α γ (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ m&#x27; m) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
f : α → β,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g
⊢ iff (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
    (@uniform_continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
f : α → β,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g
⊢ iff
    (@has_le.le.{u_2} (filter.{u_2} (prod.{u_2 u_2} β β))
       (@preorder.to_has_le.{u_2} (filter.{u_2} (prod.{u_2 u_2} β β))
          (@partial_order.to_preorder.{u_2} (filter.{u_2} (prod.{u_2 u_2} β β))
             (@filter.partial_order.{u_2} (prod.{u_2 u_2} β β))))
       (@filter.map.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
          (@uniformity.{u_1} α _inst_1))
       (@uniformity.{u_2} β _inst_2))
    (@has_le.le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
       (@preorder.to_has_le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
          (@partial_order.to_preorder.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
             (@filter.partial_order.{u_3} (prod.{u_3 u_3} γ γ))))
       (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_3 u_3} γ γ (g (f (@prod.fst.{u_1 u_1} α α x))) (g (f (@prod.snd.{u_1 u_1} α α x))))
          (@uniformity.{u_1} α _inst_1))
       (@uniformity.{u_3} γ _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
f : α → β,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g
⊢ iff
    (@has_le.le.{u_2} (filter.{u_2} (prod.{u_2 u_2} β β))
       (@preorder.to_has_le.{u_2} (filter.{u_2} (prod.{u_2 u_2} β β))
          (@partial_order.to_preorder.{u_2} (filter.{u_2} (prod.{u_2 u_2} β β))
             (@filter.partial_order.{u_2} (prod.{u_2 u_2} β β))))
       (@filter.map.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
          (@uniformity.{u_1} α _inst_1))
       (@filter.comap.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
          (λ (x : prod.{u_2 u_2} β β),
             @prod.mk.{u_3 u_3} γ γ (g (@prod.fst.{u_2 u_2} β β x)) (g (@prod.snd.{u_2 u_2} β β x)))
          (@uniformity.{u_3} γ _inst_3)))
    (@has_le.le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
       (@preorder.to_has_le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
          (@partial_order.to_preorder.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
             (@filter.partial_order.{u_3} (prod.{u_3 u_3} γ γ))))
       (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_3 u_3} γ γ (g (f (@prod.fst.{u_1 u_1} α α x))) (g (f (@prod.snd.{u_1 u_1} α α x))))
          (@uniformity.{u_1} α _inst_1))
       (@uniformity.{u_3} γ _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
f : α → β,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g
⊢ iff
    (@has_le.le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
       (@preorder.to_has_le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
          (@partial_order.to_preorder.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
             (@filter.partial_order.{u_3} (prod.{u_3 u_3} γ γ))))
       (@filter.map.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
          (λ (x : prod.{u_2 u_2} β β),
             @prod.mk.{u_3 u_3} γ γ (g (@prod.fst.{u_2 u_2} β β x)) (g (@prod.snd.{u_2 u_2} β β x)))
          (@filter.map.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
             (λ (x : prod.{u_1 u_1} α α),
                @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
             (@uniformity.{u_1} α _inst_1)))
       (@uniformity.{u_3} γ _inst_3))
    (@has_le.le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
       (@preorder.to_has_le.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
          (@partial_order.to_preorder.{u_3} (filter.{u_3} (prod.{u_3 u_3} γ γ))
             (@filter.partial_order.{u_3} (prod.{u_3 u_3} γ γ))))
       (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_3 u_3} γ γ (g (f (@prod.fst.{u_1 u_1} α α x))) (g (f (@prod.snd.{u_1 u_1} α α x))))
          (@uniformity.{u_1} α _inst_1))
       (@uniformity.{u_3} γ _inst_3))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
f : α → β,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g
⊢ iff (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
    (@uniform_continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
f : α → β,
g : β → γ,
hg : @uniform_inducing.{u_2 u_3} β γ _inst_2 _inst_3 g
⊢ iff (@uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 f)
    (@uniform_continuous.{u_1 u_3} α γ _inst_1 _inst_3 (@function.comp.{u_1+1 u_2+1 u_3+1} α β γ g f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  lemma uniform_inducing.inducing {f : α → β} (h : uniform_inducing f) : inducing f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/maps.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    refine ⟨eq_of_nhds_eq_nhds $ assume a, _ ⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eq_of_nhds_eq_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 219, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {t₁ t₂ : topological_space.{u_1} α}, (∀ (x : α), @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α t₁ x) (@nhds.{u_1} α t₂ x)) → @eq.{u_1+1} (topological_space.{u_1} α) t₁ t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f
⊢ @inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)
    (@nhds.{u_1} α
       (@topological_space.induced.{u_1 u_2} α β f (@uniform_space.to_topological_space.{u_2} β _inst_2))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    rw [nhds_induced, nhds_eq_uniformity, nhds_eq_uniformity, ← h.comap_uniformity,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nhds_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds_eq_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds_eq_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [T : topological_space.{u_2} α] (f : β → α) (a : β), @eq.{u_1+1} (filter.{u_1} β) (@nhds.{u_1} β (@topological_space.induced.{u_1 u_2} β α f T) a) (@filter.comap.{u_1 u_2} β α f (@nhds.{u_2} α T (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {x : α}, @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x) (@filter.lift&#x27;.{u_1 u_1} (prod.{u_1 u_1} α α) α (@uniformity.{u_1} α _inst_1) (λ (s : set.{u_1} (prod.{u_1 u_1} α α)), @set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] {x : α}, @eq.{u_2+1} (filter.{u_2} α) (@nhds.{u_2} α (@uniform_space.to_topological_space.{u_2} α _inst_1) x) (@filter.lift&#x27;.{u_2 u_2} (prod.{u_2 u_2} α α) α (@uniformity.{u_2} α _inst_1) (λ (s : set.{u_2} (prod.{u_2 u_2} α α)), @set_of.{u_2} α (λ (y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α x y) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2)) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)
    (@nhds.{u_1} α
       (@topological_space.induced.{u_1 u_2} α β f (@uniform_space.to_topological_space.{u_2} β _inst_2))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)
    (@filter.comap.{u_1 u_2} α β f (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α)
    (@filter.lift&#x27;.{u_1 u_1} (prod.{u_1 u_1} α α) α (@uniformity.{u_1} α _inst_1)
       (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
          @set_of.{u_1} α
            (λ (y : α),
               @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                 (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                 (@prod.mk.{u_1 u_1} α α a y)
                 s)))
    (@filter.comap.{u_1 u_2} α β f (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α)
    (@filter.lift&#x27;.{u_1 u_1} (prod.{u_1 u_1} α α) α (@uniformity.{u_1} α _inst_1)
       (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
          @set_of.{u_1} α
            (λ (y : α),
               @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                 (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                 (@prod.mk.{u_1 u_1} α α a y)
                 s)))
    (@filter.comap.{u_1 u_2} α β f
       (@filter.lift&#x27;.{u_2 u_2} (prod.{u_2 u_2} β β) β (@uniformity.{u_2} β _inst_2)
          (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
             @set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β (f a) y)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α)
    (@filter.lift&#x27;.{u_1 u_1} (prod.{u_1 u_1} α α) α
       (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
          (@uniformity.{u_2} β _inst_2))
       (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
          @set_of.{u_1} α
            (λ (y : α),
               @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                 (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                 (@prod.mk.{u_1 u_1} α α a y)
                 s)))
    (@filter.comap.{u_1 u_2} α β f
       (@filter.lift&#x27;.{u_2 u_2} (prod.{u_2 u_2} β β) β (@uniformity.{u_2} β _inst_2)
          (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
             @set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β (f a) y)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76      comap_lift&#x27;_eq, comap_lift&#x27;_eq2];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.comap_lift&#x27;_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap_lift&#x27;_eq2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 209, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_2} {γ : Type u_1} {f : filter.{u_2} α} {h : set.{u_2} α → set.{u_2} β} {m : γ → β}, @monotone.{u_2 u_2} (set.{u_2} α) (set.{u_2} β) (@partial_order.to_preorder.{u_2} (set.{u_2} α) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} α) (@set.lattice_set.{u_2} α))))) (@partial_order.to_preorder.{u_2} (set.{u_2} β) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β))))) h → @eq.{u_1+1} (filter.{u_1} γ) (@filter.comap.{u_1 u_2} γ β m (@filter.lift&#x27;.{u_2 u_2} α β f h)) (@filter.lift&#x27;.{u_2 u_1} α γ f (@function.comp.{(max (u_2+1) 1) (max (u_2+1) 1) (max (u_1+1) 1)} (set.{u_2} α) (set.{u_2} β) (set.{u_1} γ) (@set.preimage.{u_1 u_2} γ β m) h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β γ : Type u_1} {f : filter.{u_2} α} {m : β → α} {g : set.{u_1} β → set.{u_1} γ}, @monotone.{u_1 u_1} (set.{u_1} β) (set.{u_1} γ) (@partial_order.to_preorder.{u_1} (set.{u_1} β) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} β) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} β) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} β) (@set.lattice_set.{u_1} β))))) (@partial_order.to_preorder.{u_1} (set.{u_1} γ) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} γ) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} γ) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} γ) (@set.lattice_set.{u_1} γ))))) g → @eq.{u_1+1} (filter.{u_1} γ) (@filter.lift&#x27;.{u_1 u_1} β γ (@filter.comap.{u_1 u_2} β α m f) g) (@filter.lift&#x27;.{u_2 u_1} α γ f (@function.comp.{(max (u_2+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (set.{u_2} α) (set.{u_1} β) (set.{u_1} γ) g (@set.preimage.{u_1 u_2} β α m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α)
    (@filter.lift&#x27;.{u_1 u_1} (prod.{u_1 u_1} α α) α
       (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
          (@uniformity.{u_2} β _inst_2))
       (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
          @set_of.{u_1} α
            (λ (y : α),
               @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                 (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                 (@prod.mk.{u_1 u_1} α α a y)
                 s)))
    (@filter.comap.{u_1 u_2} α β f
       (@filter.lift&#x27;.{u_2 u_2} (prod.{u_2 u_2} β β) β (@uniformity.{u_2} β _inst_2)
          (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
             @set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β (f a) y)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α)
    (@filter.lift&#x27;.{u_1 u_1} (prod.{u_1 u_1} α α) α
       (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
          (λ (x : prod.{u_1 u_1} α α),
             @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
          (@uniformity.{u_2} β _inst_2))
       (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
          @set_of.{u_1} α
            (λ (y : α),
               @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                 (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                 (@prod.mk.{u_1 u_1} α α a y)
                 s)))
    (@filter.lift&#x27;.{u_2 u_1} (prod.{u_2 u_2} β β) α (@uniformity.{u_2} β _inst_2)
       (@function.comp.{(max (u_2+1) 1) (max (u_2+1) 1) (max (u_1+1) 1)} (set.{u_2} (prod.{u_2 u_2} β β))
          (set.{u_2} β)
          (set.{u_1} α)
          (@set.preimage.{u_1 u_2} α β f)
          (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
             @set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β (f a) y)
                    s))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @monotone.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} β)
    (@partial_order.to_preorder.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                (@set.lattice_set.{u_2} (prod.{u_2 u_2} β β))))))
    (@partial_order.to_preorder.{u_2} (set.{u_2} β)
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β)))))
    (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
       @set_of.{u_2} β
         (λ (y : β),
            @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
              (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
              (@prod.mk.{u_2 u_2} β β (f a) y)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α)
    (@filter.lift&#x27;.{u_2 u_1} (prod.{u_2 u_2} β β) α (@uniformity.{u_2} β _inst_2)
       (@function.comp.{(max (u_2+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (set.{u_2} (prod.{u_2 u_2} β β))
          (set.{u_1} (prod.{u_1 u_1} α α))
          (set.{u_1} α)
          (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
             @set_of.{u_1} α
               (λ (y : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a y)
                    s))
          (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
             (λ (x : prod.{u_1 u_1} α α),
                @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))))))
    (@filter.lift&#x27;.{u_2 u_1} (prod.{u_2 u_2} β β) α (@uniformity.{u_2} β _inst_2)
       (@function.comp.{(max (u_2+1) 1) (max (u_2+1) 1) (max (u_1+1) 1)} (set.{u_2} (prod.{u_2 u_2} β β))
          (set.{u_2} β)
          (set.{u_1} α)
          (@set.preimage.{u_1 u_2} α β f)
          (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
             @set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β (f a) y)
                    s))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @monotone.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} α)
    (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
       (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
          (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
                (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α))))))
    (@partial_order.to_preorder.{u_1} (set.{u_1} α)
       (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
    (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
       @set_of.{u_1} α
         (λ (y : α),
            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
              (@prod.mk.{u_1 u_1} α α a y)
              s))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @monotone.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} β)
    (@partial_order.to_preorder.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                (@set.lattice_set.{u_2} (prod.{u_2 u_2} β β))))))
    (@partial_order.to_preorder.{u_2} (set.{u_2} β)
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β)))))
    (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
       @set_of.{u_2} β
         (λ (y : β),
            @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
              (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
              (@prod.mk.{u_2 u_2} β β (f a) y)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)
    (@nhds.{u_1} α
       (@topological_space.induced.{u_1 u_2} α β f (@uniform_space.to_topological_space.{u_2} β _inst_2))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77      { refl &lt;|&gt; exact monotone_preimage }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='set.monotone_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} {f : α → β}, @monotone.{u_1 u_1} (set.{u_1} β) (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} β) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} β) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} β) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} β) (@set.lattice_set.{u_1} β))))) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (@set.preimage.{u_1 u_1} α β f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)
    (@nhds.{u_1} α
       (@topological_space.induced.{u_1 u_2} α β f (@uniform_space.to_topological_space.{u_2} β _inst_2))
       a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
h : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f,
a : α
⊢ @eq.{u_1+1} (filter.{u_1} α)
    (@filter.lift&#x27;.{u_2 u_1} (prod.{u_2 u_2} β β) α (@uniformity.{u_2} β _inst_2)
       (@function.comp.{(max (u_2+1) 1) (max (u_1+1) 1) (max (u_1+1) 1)} (set.{u_2} (prod.{u_2 u_2} β β))
          (set.{u_1} (prod.{u_1 u_1} α α))
          (set.{u_1} α)
          (λ (s : set.{u_1} (prod.{u_1 u_1} α α)),
             @set_of.{u_1} α
               (λ (y : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a y)
                    s))
          (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
             (λ (x : prod.{u_1 u_1} α α),
                @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))))))
    (@filter.lift&#x27;.{u_2 u_1} (prod.{u_2 u_2} β β) α (@uniformity.{u_2} β _inst_2)
       (@function.comp.{(max (u_2+1) 1) (max (u_2+1) 1) (max (u_1+1) 1)} (set.{u_2} (prod.{u_2 u_2} β β))
          (set.{u_2} β)
          (set.{u_1} α)
          (@set.preimage.{u_1 u_2} α β f)
          (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
             @set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β (f a) y)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  lemma uniform_inducing.prod {α&#x27; : Type*} {β&#x27; : Type*} [uniform_space α&#x27;] [uniform_space β&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    {e₁ : α → α&#x27;} {e₂ : β → β&#x27;} (h₁ : uniform_inducing e₁) (h₂ : uniform_inducing e₂) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    uniform_inducing (λp:α×β, (e₁ p.1, e₂ p.2)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_4}, α → β → prod.{u_3 u_4} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, prod.{u_1 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, prod.{u_1 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  ⟨by simp [(∘), uniformity_prod, h₁.comap_uniformity.symm, h₂.comap_uniformity.symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniformity_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 682, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β], @eq.{(max ?l_1 ?l_2)+1} (filter.{(max ?l_1 ?l_2)} (prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β))) (@uniformity.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (@prod.uniform_space.{?l_1 ?l_2} α β _inst_1 _inst_2)) (@lattice.has_inf.inf.{(max ?l_1 ?l_2)} (filter.{(max ?l_1 ?l_2)} (prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β))) (@filter.lattice.has_inf.{(max ?l_1 ?l_2)} (prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β))) (@filter.comap.{(max ?l_1 ?l_2) ?l_1} (prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β)) (prod.{?l_1 ?l_1} α α) (λ (p : prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β)), @prod.mk.{?l_1 ?l_1} α α (@prod.fst.{?l_1 ?l_2} α β (@prod.fst.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β) p)) (@prod.fst.{?l_1 ?l_2} α β (@prod.snd.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β) p))) (@uniformity.{?l_1} α _inst_1)) (@filter.comap.{(max ?l_1 ?l_2) ?l_2} (prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β)) (prod.{?l_2 ?l_2} β β) (λ (p : prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β)), @prod.mk.{?l_2 ?l_2} β β (@prod.snd.{?l_1 ?l_2} α β (@prod.fst.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β) p)) (@prod.snd.{?l_1 ?l_2} α β (@prod.snd.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β) p))) (@uniformity.{?l_2} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@uniformity.{u_1} α _inst_1) (@filter.comap.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} α&#x27; α&#x27;) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_3 u_3} α&#x27; α&#x27; (e₁ (@prod.fst.{u_1 u_1} α α x)) (e₁ (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_3} α&#x27; _inst_4))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} (filter.{u_2} (prod.{u_2 u_2} β β)) (@uniformity.{u_2} β _inst_2) (@filter.comap.{u_2 u_4} (prod.{u_2 u_2} β β) (prod.{u_4 u_4} β&#x27; β&#x27;) (λ (x : prod.{u_2 u_2} β β), @prod.mk.{u_4 u_4} β&#x27; β&#x27; (e₂ (@prod.fst.{u_2 u_2} β β x)) (e₂ (@prod.snd.{u_2 u_2} β β x))) (@uniformity.{u_4} β&#x27; _inst_5))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
α&#x27; : Type u_3,
β&#x27; : Type u_4,
_inst_4 : uniform_space.{u_3} α&#x27;,
_inst_5 : uniform_space.{u_4} β&#x27;,
e₁ : α → α&#x27;,
e₂ : β → β&#x27;,
h₁ : @uniform_inducing.{u_1 u_3} α α&#x27; _inst_1 _inst_4 e₁,
h₂ : @uniform_inducing.{u_2 u_4} β β&#x27; _inst_2 _inst_5 e₂
⊢ @eq.{(max u_1 u_2)+1}
    (filter.{(max u_1 u_2)} (prod.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β)))
    (@filter.comap.{(max u_1 u_2) (max u_3 u_4)}
       (prod.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β))
       (prod.{(max u_3 u_4) (max u_3 u_4)} (prod.{u_3 u_4} α&#x27; β&#x27;) (prod.{u_3 u_4} α&#x27; β&#x27;))
       (λ (x : prod.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β)),
          @prod.mk.{(max u_3 u_4) (max u_3 u_4)} (prod.{u_3 u_4} α&#x27; β&#x27;) (prod.{u_3 u_4} α&#x27; β&#x27;)
            (@prod.mk.{u_3 u_4} α&#x27; β&#x27;
               (e₁
                  (@prod.fst.{u_1 u_2} α β
                     (@prod.fst.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x)))
               (e₂
                  (@prod.snd.{u_1 u_2} α β
                     (@prod.fst.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x))))
            (@prod.mk.{u_3 u_4} α&#x27; β&#x27;
               (e₁
                  (@prod.fst.{u_1 u_2} α β
                     (@prod.snd.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x)))
               (e₂
                  (@prod.snd.{u_1 u_2} α β
                     (@prod.snd.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x)))))
       (@uniformity.{(max u_3 u_4)} (prod.{u_3 u_4} α&#x27; β&#x27;) (@prod.uniform_space.{u_3 u_4} α&#x27; β&#x27; _inst_4 _inst_5)))
    (@uniformity.{(max u_1 u_2)} (prod.{u_1 u_2} α β) (@prod.uniform_space.{u_1 u_2} α β _inst_1 _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84             comap_inf, comap_comap_comp]⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.comap_inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap_comap_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 940, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 914, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {g₁ g₂ : filter.{?l_2} β} {m : α → β}, @eq.{?l_1+1} (filter.{?l_1} α) (@filter.comap.{?l_1 ?l_2} α β m (@lattice.has_inf.inf.{?l_2} (filter.{?l_2} β) (@filter.lattice.has_inf.{?l_2} β) g₁ g₂)) (@lattice.has_inf.inf.{?l_1} (filter.{?l_1} α) (@filter.lattice.has_inf.{?l_1} α) (@filter.comap.{?l_1 ?l_2} α β m g₁) (@filter.comap.{?l_1 ?l_2} α β m g₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} {f : filter.{?l_1} α} {m : γ → β} {n : β → α}, @eq.{?l_3+1} (filter.{?l_3} γ) (@filter.comap.{?l_3 ?l_2} γ β m (@filter.comap.{?l_2 ?l_1} β α n f)) (@filter.comap.{?l_3 ?l_1} γ α (@function.comp.{?l_3+1 ?l_2+1 ?l_1+1} γ β α n m) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
α&#x27; : Type u_3,
β&#x27; : Type u_4,
_inst_4 : uniform_space.{u_3} α&#x27;,
_inst_5 : uniform_space.{u_4} β&#x27;,
e₁ : α → α&#x27;,
e₂ : β → β&#x27;,
h₁ : @uniform_inducing.{u_1 u_3} α α&#x27; _inst_1 _inst_4 e₁,
h₂ : @uniform_inducing.{u_2 u_4} β β&#x27; _inst_2 _inst_5 e₂
⊢ @eq.{(max u_1 u_2)+1}
    (filter.{(max u_1 u_2)} (prod.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β)))
    (@filter.comap.{(max u_1 u_2) (max u_3 u_4)}
       (prod.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β))
       (prod.{(max u_3 u_4) (max u_3 u_4)} (prod.{u_3 u_4} α&#x27; β&#x27;) (prod.{u_3 u_4} α&#x27; β&#x27;))
       (λ (x : prod.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β)),
          @prod.mk.{(max u_3 u_4) (max u_3 u_4)} (prod.{u_3 u_4} α&#x27; β&#x27;) (prod.{u_3 u_4} α&#x27; β&#x27;)
            (@prod.mk.{u_3 u_4} α&#x27; β&#x27;
               (e₁
                  (@prod.fst.{u_1 u_2} α β
                     (@prod.fst.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x)))
               (e₂
                  (@prod.snd.{u_1 u_2} α β
                     (@prod.fst.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x))))
            (@prod.mk.{u_3 u_4} α&#x27; β&#x27;
               (e₁
                  (@prod.fst.{u_1 u_2} α β
                     (@prod.snd.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x)))
               (e₂
                  (@prod.snd.{u_1 u_2} α β
                     (@prod.snd.{(max u_1 u_2) (max u_1 u_2)} (prod.{u_1 u_2} α β) (prod.{u_1 u_2} α β) x)))))
       (@uniformity.{(max u_3 u_4)} (prod.{u_3 u_4} α&#x27; β&#x27;) (@prod.uniform_space.{u_3 u_4} α&#x27; β&#x27; _inst_4 _inst_5)))
    (@uniformity.{(max u_1 u_2)} (prod.{u_1 u_2} α β) (@prod.uniform_space.{u_1 u_2} α β _inst_1 _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  lemma uniform_inducing.dense_inducing {f : α → β} (h : uniform_inducing f) (hd : dense_range f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='dense_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                 </code><font color='orange'><a title='`f : α → β` has dense range if its range (image) is a dense subset of β.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    dense_inducing f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dense_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 77, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`i : α → β` is &quot;dense inducing&quot; if it has dense range and the topology on `α`
 is the one induced by `i` from the topology on `β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  { dense   := hd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@dense_range.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    induced := h.inducing.induced }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='inducing.induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/maps.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f → @inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β] {f : α → β}, @inducing.{u_1 u_2} α β tα tβ f → @eq.{u_1+1} (topological_space.{u_1} α) tα (@topological_space.induced.{u_1 u_2} α β f tβ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  lemma uniform_embedding.embedding {f : α → β} (h : uniform_embedding f) : embedding f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/maps.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='orange'><a title='A function between topological spaces is an embedding if it is injective,
 and for all `s : set α`, `s` is open iff it is the preimage of an open set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  { induced := h.to_uniform_inducing.inducing.induced,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.to_uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='inducing.induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 72, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/maps.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f → @inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β] {f : α → β}, @inducing.{u_1 u_2} α β tα tβ f → @eq.{u_1+1} (topological_space.{u_1} α) tα (@topological_space.induced.{u_1 u_2} α β f tβ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    inj := h.inj }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @function.injective.{u_1+1 u_2+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  lemma uniform_embedding.dense_embedding {f : α → β} (h : uniform_embedding f) (hd : dense_range f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='dense_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                    </code><font color='orange'><a title='`f : α → β` has dense range if its range (image) is a dense subset of β.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    dense_embedding f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dense_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 230, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A dense embedding is an embedding with dense image.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  { dense   := hd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@dense_range.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    inj     := h.inj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @function.injective.{u_1+1 u_2+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    induced := h.embedding.induced }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='inducing.induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/maps.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [tα : topological_space.{u_1} α] [tβ : topological_space.{u_2} β] {f : α → β}, @inducing.{u_1 u_2} α β tα tβ f → @eq.{u_1+1} (topological_space.{u_1} α) tα (@topological_space.induced.{u_1 u_2} α β f tβ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  lemma closure_image_mem_nhds_of_uniform_inducing</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    {s : set (α×α)} {e : α → β} (b : β)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    (he₁ : uniform_inducing e) (he₂ : dense_inducing e) (hs : s ∈ 𝓤 α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='dense_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 77, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`i : α → β` is &quot;dense inducing&quot; if it has dense range and the topology on `α`
 is the one induced by `i` from the topology on `β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104    ∃a, closure (e &#x27;&#x27; {a&#x27; | (a, a&#x27;) ∈ s}) ∈ 𝓝 b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  have s ∈ comap (λp:α×α, (e p.1, e p.2)) (𝓤 β),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : uniform_space.{u_2} α], filter.{u_2} (prod.{u_2 u_2} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    from he₁.comap_uniformity.symm ▸ hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='he₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.comap_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f → @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2)) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{u_1+1} α a b → @eq.{u_1+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {P : α → Prop} {a b : α}, @eq.{u_1+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  let ⟨t₁, ht₁u, ht₁⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₁u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (p : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p))) (@uniformity.{u_2} β _inst_2)) → @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s)))) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t₁ (@uniformity.{u_2} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (p : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p))) t₁) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (p : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p))) (@uniformity.{u_2} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  have ht₁ : ∀p:α×α, (e p.1, e p.2) ∈ t₁ → p ∈ s, from ht₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  let ⟨t₂, ht₂u, ht₂s, ht₂c⟩ := comp_symm_of_uniformity ht₁u in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₂u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₂s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht₂c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='comp_symm_of_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 196, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), @Exists.{0} (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t (@uniformity.{u_2} β _inst_2)) (λ (H : @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t (@uniformity.{u_2} β _inst_2)), and (∀ {a b : β}, @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β a b) t → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b a) t) (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β)) (@comp_rel.{u_2} β t t) t₁))) → @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s)))) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t₂ (@uniformity.{u_2} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : β}, @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β a b) t₂ → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b a) t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β)) (@comp_rel.{u_2} β t₂ t₂) t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] {s : set.{u_2} (prod.{u_2 u_2} α α)}, @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) s (@uniformity.{u_2} α _inst_1) → @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} α α)) (λ (t : set.{u_2} (prod.{u_2 u_2} α α)), @Exists.{0} (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) t (@uniformity.{u_2} α _inst_1)) (λ (H : @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) t (@uniformity.{u_2} α _inst_1)), and (∀ {a b : α}, @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α a b) t → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α b a) t) (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_subset.{u_2} (prod.{u_2 u_2} α α)) (@comp_rel.{u_2} α t t) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  let ⟨t, htu, hts, htc⟩ := comp_symm_of_uniformity ht₂u in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='htu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='htc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='comp_symm_of_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 196, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β)) (λ (t : set.{u_2} (prod.{u_2 u_2} β β)), @Exists.{0} (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t (@uniformity.{u_2} β _inst_2)) (λ (H : @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t (@uniformity.{u_2} β _inst_2)), and (∀ {a b : β}, @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β a b) t → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b a) t) (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β)) (@comp_rel.{u_2} β t t) t₂))) → @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s)))) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t (@uniformity.{u_2} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β)) (@comp_rel.{u_2} β t t) t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] {s : set.{u_2} (prod.{u_2 u_2} α α)}, @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) s (@uniformity.{u_2} α _inst_1) → @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} α α)) (λ (t : set.{u_2} (prod.{u_2 u_2} α α)), @Exists.{0} (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) t (@uniformity.{u_2} α _inst_1)) (λ (H : @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) t (@uniformity.{u_2} α _inst_1)), and (∀ {a b : α}, @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α a b) t → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α b a) t) (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_subset.{u_2} (prod.{u_2 u_2} α α)) (@comp_rel.{u_2} α t t) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  have preimage e {b&#x27; | (b, b&#x27;) ∈ t₂} ∈ comap e (𝓝 b),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    from preimage_mem_comap $ mem_nhds_left b ht₂u,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.preimage_mem_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_nhds_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 908, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {g : filter.{u_2} β} {m : α → β} {t : set.{u_2} β}, @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t g → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set.preimage.{u_1 u_2} α β m t) (@filter.comap.{u_1 u_2} α β m g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] (x : α) {s : set.{u_2} (prod.{u_2 u_2} α α)}, @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) s (@uniformity.{u_2} α _inst_1) → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) (@set_of.{u_2} α (λ (y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α x y) s)) (@nhds.{u_2} α (@uniform_space.to_topological_space.{u_2} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  let ⟨a, (ha : (b, e a) ∈ t₂)⟩ := nonempty_of_mem_sets (he₂.comap_nhds_ne_bot) this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.nonempty_of_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dense_inducing.comap_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.nonempty.{u_1} α (@set.preimage.{u_1 u_2} α β e (@set_of.{u_2} β (λ (b&#x27; : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t₂))) → @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s)))) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b (e a)) t₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α}, @ne.{u_1+1} (filter.{u_1} α) f (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α))))) → ∀ {s : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @set.nonempty.{u_1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] {i : α → β}, @dense_inducing.{u_1 u_2} α β _inst_1 _inst_2 i → ∀ {b : β}, @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β i (@nhds.{u_2} β _inst_2 b)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set.preimage.{u_1 u_2} α β e (@set_of.{u_2} β (λ (b&#x27; : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t₂))) (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  have ∀b&#x27; (s&#x27; : set (β × β)), (b, b&#x27;) ∈ t → s&#x27; ∈ 𝓤 β →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : uniform_space.{u_2} α], filter.{u_2} (prod.{u_2 u_2} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115    ({y : β | (b&#x27;, y) ∈ s&#x27;} ∩ e &#x27;&#x27; {a&#x27; : α | (a, a&#x27;) ∈ s}).nonempty,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 148, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2}, set.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title=' The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used
in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks
to the dot notation.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    from assume b&#x27; s&#x27; hb&#x27; hs&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) s&#x27; (@uniformity.{u_2} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117    have preimage e {b&#x27;&#x27; | (b&#x27;, b&#x27;&#x27;) ∈ s&#x27; ∩ t} ∈ comap e (𝓝 b&#x27;),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      from preimage_mem_comap $ mem_nhds_left b&#x27; $ inter_mem_sets hs&#x27; htu,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.preimage_mem_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_nhds_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.inter_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 908, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {g : filter.{u_2} β} {m : α → β} {t : set.{u_2} β}, @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t g → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set.preimage.{u_1 u_2} α β m t) (@filter.comap.{u_1 u_2} α β m g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] (x : α) {s : set.{u_2} (prod.{u_2 u_2} α α)}, @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) s (@uniformity.{u_2} α _inst_1) → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) (@set_of.{u_2} α (λ (y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α x y) s)) (@nhds.{u_2} α (@uniform_space.to_topological_space.{u_2} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} {f : filter.{u_2} α} {s t : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s f → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) t f → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) s&#x27; (@uniformity.{u_2} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    let ⟨a₂, ha₂s&#x27;, ha₂t⟩ := nonempty_of_mem_sets (he₂.comap_nhds_ne_bot) this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha₂s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha₂t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.nonempty_of_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dense_inducing.comap_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.nonempty.{u_1} α (@set.preimage.{u_1 u_2} α β e (@set_of.{u_2} β (λ (b&#x27;&#x27; : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b&#x27; b&#x27;&#x27;) (@has_inter.inter.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_inter.{u_2} (prod.{u_2 u_2} β β)) s&#x27; t)))) → @set.nonempty.{u_2} β (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) (@set_of.{u_2} β (λ (y : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b&#x27; y) s&#x27;)) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b&#x27; (e a₂)) s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b&#x27; (e a₂)) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α}, @ne.{u_1+1} (filter.{u_1} α) f (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α))))) → ∀ {s : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @set.nonempty.{u_1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] {i : α → β}, @dense_inducing.{u_1 u_2} α β _inst_1 _inst_2 i → ∀ {b : β}, @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β i (@nhds.{u_2} β _inst_2 b)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set.preimage.{u_1 u_2} α β e (@set_of.{u_2} β (λ (b&#x27;&#x27; : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b&#x27; b&#x27;&#x27;) (@has_inter.inter.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_inter.{u_2} (prod.{u_2 u_2} β β)) s&#x27; t)))) (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    have (e a, e a₂) ∈ t₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121      from ht₂c $ prod_mk_mem_comp_rel (ht₂s ha) $ htc $ prod_mk_mem_comp_rel hb&#x27; ha₂t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='prod_mk_mem_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='prod_mk_mem_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ {α : Type u_2} {a b c : α} {s t : set.{u_2} (prod.{u_2 u_2} α α)}, @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α a c) s → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α c b) t → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α a b) (@comp_rel.{u_2} α s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='∀ {α : Type u_2} {a b c : α} {s t : set.{u_2} (prod.{u_2 u_2} α α)}, @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α a c) s → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α c b) t → @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α a b) (@comp_rel.{u_2} α s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    have e a₂ ∈ {b&#x27;&#x27;:β | (b&#x27;, b&#x27;&#x27;) ∈ s&#x27;} ∩ e &#x27;&#x27; {a&#x27; | (a, a&#x27;) ∈ s},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, (α → Prop) → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} (prod.{u_2 u_2} β β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      from ⟨ha₂s&#x27;, mem_image_of_mem _ $ ht₁ (a, a₂) this⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set.mem_image_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ht₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 899, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} (f : α → β) {x : α} {a : set.{u_1} α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x a → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) (@set.image.{u_1 u_2} α β f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (p : prod.{u_1 u_1} α α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p))) t₁ → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) p s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (e a) (e a₂)) t₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    ⟨_, this⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (e a₂) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) (@set_of.{u_2} β (λ (b&#x27;&#x27; : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b&#x27; b&#x27;&#x27;) s&#x27;)) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  have ∀b&#x27;, (b, b&#x27;) ∈ t → 𝓝 b&#x27; ⊓ principal (e &#x27;&#x27; {a&#x27; | (a, a&#x27;) ∈ s}) ≠ ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : lattice.has_inf.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, set.{u_2} α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_2) [c : lattice.has_bot.{u_2} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))
⊢ ∀ (b&#x27; : β),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @ne.{u_2+1} (filter.{u_2} β)
      (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;)
         (@filter.principal.{u_2} β
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s)))))
      (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
         (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
            (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
               (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                  (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    intros b&#x27; hb&#x27;,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))
⊢ ∀ (b&#x27; : β),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @ne.{u_2+1} (filter.{u_2} β)
      (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;)
         (@filter.principal.{u_2} β
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s)))))
      (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
         (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
            (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
               (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                  (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @ne.{u_2+1} (filter.{u_2} β)
    (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
       (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;)
       (@filter.principal.{u_2} β
          (@set.image.{u_1 u_2} α β e
             (@set_of.{u_1} α
                (λ (a&#x27; : α),
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α a a&#x27;)
                     s)))))
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    rw [nhds_eq_uniformity, lift&#x27;_inf_principal_eq, lift&#x27;_ne_bot_iff],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nhds_eq_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.lift&#x27;_inf_principal_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.lift&#x27;_ne_bot_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] {x : α}, @eq.{u_2+1} (filter.{u_2} α) (@nhds.{u_2} α (@uniform_space.to_topological_space.{u_2} α _inst_1) x) (@filter.lift&#x27;.{u_2 u_2} (prod.{u_2 u_2} α α) α (@uniformity.{u_2} α _inst_1) (λ (s : set.{u_2} (prod.{u_2 u_2} α α)), @set_of.{u_2} α (λ (y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α x y) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_2} {f : filter.{u_2} α} {h : set.{u_2} α → set.{u_2} β} {s : set.{u_2} β}, @eq.{u_2+1} (filter.{u_2} β) (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β) (@filter.lift&#x27;.{u_2 u_2} α β f h) (@filter.principal.{u_2} β s)) (@filter.lift&#x27;.{u_2 u_2} α β f (λ (t : set.{u_2} α), @has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) (h t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_2} {f : filter.{u_2} α} {h : set.{u_2} α → set.{u_2} β}, @monotone.{u_2 u_2} (set.{u_2} α) (set.{u_2} β) (@partial_order.to_preorder.{u_2} (set.{u_2} α) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} α) (@set.lattice_set.{u_2} α))))) (@partial_order.to_preorder.{u_2} (set.{u_2} β) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β))))) h → iff (@ne.{u_2+1} (filter.{u_2} β) (@filter.lift&#x27;.{u_2 u_2} α β f h) (@lattice.has_bot.bot.{u_2} (filter.{u_2} β) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β) (@filter.lattice.complete_lattice.{u_2} β)))))) (∀ (s : set.{u_2} α), @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s f → @set.nonempty.{u_2} β (h s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @ne.{u_2+1} (filter.{u_2} β)
    (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
       (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;)
       (@filter.principal.{u_2} β
          (@set.image.{u_1 u_2} α β e
             (@set_of.{u_1} α
                (λ (a&#x27; : α),
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α a a&#x27;)
                     s)))))
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @ne.{u_2+1} (filter.{u_2} β)
    (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
       (@filter.lift&#x27;.{u_2 u_2} (prod.{u_2 u_2} β β) β (@uniformity.{u_2} β _inst_2)
          (λ (s : set.{u_2} (prod.{u_2 u_2} β β)),
             @set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β b&#x27; y)
                    s)))
       (@filter.principal.{u_2} β
          (@set.image.{u_1 u_2} α β e
             (@set_of.{u_1} α
                (λ (a&#x27; : α),
                   @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                     (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                     (@prod.mk.{u_1 u_1} α α a a&#x27;)
                     s)))))
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @ne.{u_2+1} (filter.{u_2} β)
    (@filter.lift&#x27;.{u_2 u_2} (prod.{u_2 u_2} β β) β (@uniformity.{u_2} β _inst_2)
       (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
          @has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
            (@set_of.{u_2} β
               (λ (y : β),
                  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                    (@prod.mk.{u_2 u_2} β β b&#x27; y)
                    t))
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s)))))
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ ∀ (s_1 : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s_1
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s_1))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @monotone.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} β)
    (@partial_order.to_preorder.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                (@set.lattice_set.{u_2} (prod.{u_2 u_2} β β))))))
    (@partial_order.to_preorder.{u_2} (set.{u_2} β)
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β)))))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 t))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    exact assume s, this b&#x27; s hb&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hb&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t → @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) s&#x27; (@uniformity.{u_2} β _inst_2) → @set.nonempty.{u_2} β (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) (@set_of.{u_2} β (λ (y : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b&#x27; y) s&#x27;)) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ ∀ (s_1 : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s_1
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s_1))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @monotone.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} β)
    (@partial_order.to_preorder.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                (@set.lattice_set.{u_2} (prod.{u_2 u_2} β β))))))
    (@partial_order.to_preorder.{u_2} (set.{u_2} β)
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β)))))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 t))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @monotone.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} β)
    (@partial_order.to_preorder.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                (@set.lattice_set.{u_2} (prod.{u_2 u_2} β β))))))
    (@partial_order.to_preorder.{u_2} (set.{u_2} β)
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β)))))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 t))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    exact monotone_inter monotone_preimage monotone_const</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.monotone_inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.monotone_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monotone_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 625, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 116, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_2} [_inst_1 : preorder.{u_2} β] {f g : β → set.{u_2} α}, @monotone.{u_2 u_2} β (set.{u_2} α) _inst_1 (@partial_order.to_preorder.{u_2} (set.{u_2} α) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} α) (@set.lattice_set.{u_2} α))))) f → @monotone.{u_2 u_2} β (set.{u_2} α) _inst_1 (@partial_order.to_preorder.{u_2} (set.{u_2} α) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} α) (@set.lattice_set.{u_2} α))))) g → @monotone.{u_2 u_2} β (set.{u_2} α) _inst_1 (@partial_order.to_preorder.{u_2} (set.{u_2} α) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} α) (@set.lattice_set.{u_2} α))))) (λ (x : β), @has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_2} {f : α → β}, @monotone.{u_2 u_2} (set.{u_2} β) (set.{u_2} α) (@partial_order.to_preorder.{u_2} (set.{u_2} β) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β))))) (@partial_order.to_preorder.{u_2} (set.{u_2} α) (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} α) (@set.lattice_set.{u_2} α))))) (@set.preimage.{u_2 u_2} α β f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_2} [_inst_1 : preorder.{u_2} α] [_inst_2 : preorder.{u_2} β] {b : β}, @monotone.{u_2 u_2} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @monotone.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (set.{u_2} β)
    (@partial_order.to_preorder.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                (@set.lattice_set.{u_2} (prod.{u_2 u_2} β β))))))
    (@partial_order.to_preorder.{u_2} (set.{u_2} β)
       (@lattice.order_bot.to_partial_order.{u_2} (set.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (set.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (set.{u_2} β) (@set.lattice_set.{u_2} β)))))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 t))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  have ∀b&#x27;, (b, b&#x27;) ∈ t → b&#x27; ∈ closure (e &#x27;&#x27; {a&#x27; | (a, a&#x27;) ∈ s}),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, α → β → prod.{u_2 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    from assume b&#x27; hb&#x27;, by rw [closure_eq_nhds]; exact this b&#x27; hb&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='closure_eq_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 499, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {s : set.{u_2} α}, @eq.{(max (u_2+1) 1)} (set.{u_2} α) (@closure.{u_2} α _inst_1 s) (@set_of.{u_2} α (λ (a : α), @ne.{u_2+1} (filter.{u_2} α) (@lattice.has_inf.inf.{u_2} (filter.{u_2} α) (@filter.lattice.has_inf.{u_2} α) (@nhds.{u_2} α _inst_1 a) (@filter.principal.{u_2} α s)) (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (b&#x27; : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t → @ne.{u_2+1} (filter.{u_2} β) (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;) (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s))))) (@lattice.has_bot.bot.{u_2} (filter.{u_2} β) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β) (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
this :
  ∀ (b&#x27; : β),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @ne.{u_2+1} (filter.{u_2} β)
      (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;)
         (@filter.principal.{u_2} β
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s)))))
      (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
         (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
            (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
               (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                  (@filter.lattice.complete_lattice.{u_2} β))))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b&#x27;
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e
          (@set_of.{u_1} α
             (λ (a&#x27; : α),
                @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                  (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                  (@prod.mk.{u_1 u_1} α α a a&#x27;)
                  s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
this :
  ∀ (b&#x27; : β),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @ne.{u_2+1} (filter.{u_2} β)
      (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;)
         (@filter.principal.{u_2} β
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s)))))
      (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
         (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
            (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
               (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                  (@filter.lattice.complete_lattice.{u_2} β))))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b&#x27;
    (@set_of.{u_2} β
       (λ (a_1 : β),
          @ne.{u_2+1} (filter.{u_2} β)
            (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
               (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) a_1)
               (@filter.principal.{u_2} β
                  (@set.image.{u_1 u_2} α β e
                     (@set_of.{u_1} α
                        (λ (a&#x27; : α),
                           @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                             (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                             (@prod.mk.{u_1 u_1} α α a a&#x27;)
                             s)))))
            (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
               (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
                  (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
                     (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                        (@filter.lattice.complete_lattice.{u_2} β)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
s : set.{u_1} (prod.{u_1 u_1} α α),
e : α → β,
b : β,
he₁ : @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 e,
he₂ :
  @dense_inducing.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
hs :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@uniformity.{u_1} α _inst_1),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)),
_let_match :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    s
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2)) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₁ : set.{u_2} (prod.{u_2 u_2} β β),
ht₁u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₁
    (@uniformity.{u_2} β _inst_2),
ht₁ :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
       t₁)
    s,
ht₁ :
  ∀ (p : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α p)) (e (@prod.snd.{u_1 u_1} α α p)))
      t₁ →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      p
      s,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₁))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t₂ : set.{u_2} (prod.{u_2 u_2} β β),
ht₂u :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t₂
    (@uniformity.{u_2} β _inst_2),
ht₂s :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t₂ →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t₂,
ht₂c :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t₂ t₂)
    t₁,
_let_match :
  @Exists.{u_2+1} (set.{u_2} (prod.{u_2 u_2} β β))
    (λ (t : set.{u_2} (prod.{u_2 u_2} β β)),
       @Exists.{0}
         (@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
            (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
            t
            (@uniformity.{u_2} β _inst_2))
         (λ
          (H :
            @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
              (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
              t
              (@uniformity.{u_2} β _inst_2)),
            and
              (∀ {a b : β},
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β a b)
                   t →
                 @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                   (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                   (@prod.mk.{u_2 u_2} β β b a)
                   t)
              (@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
                 (@comp_rel.{u_2} β t t)
                 t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
t : set.{u_2} (prod.{u_2 u_2} β β),
htu :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t
    (@uniformity.{u_2} β _inst_2),
hts :
  ∀ {a b : β},
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β a b)
      t →
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b a)
      t,
htc :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@comp_rel.{u_2} β t t)
    t₂,
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂)))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
_let_match :
  @set.nonempty.{u_1} α
    (@set.preimage.{u_1 u_2} α β e
       (@set_of.{u_2} β
          (λ (b&#x27; : β),
             @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
               (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
               (@prod.mk.{u_2 u_2} β β b b&#x27;)
               t₂))) →
  @Exists.{u_1+1} α
    (λ (a : α),
       @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
         (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s))))
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)),
a : α,
ha :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b (e a))
    t₂,
this :
  ∀ (b&#x27; : β) (s&#x27; : set.{u_2} (prod.{u_2 u_2} β β)),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
      (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
      s&#x27;
      (@uniformity.{u_2} β _inst_2) →
    @set.nonempty.{u_2} β
      (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β)
         (@set_of.{u_2} β
            (λ (y : β),
               @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                 (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                 (@prod.mk.{u_2 u_2} β β b&#x27; y)
                 s&#x27;))
         (@set.image.{u_1 u_2} α β e
            (@set_of.{u_1} α
               (λ (a&#x27; : α),
                  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                    (@prod.mk.{u_1 u_1} α α a a&#x27;)
                    s)))),
this :
  ∀ (b&#x27; : β),
    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
      (@prod.mk.{u_2 u_2} β β b b&#x27;)
      t →
    @ne.{u_2+1} (filter.{u_2} β)
      (@lattice.has_inf.inf.{u_2} (filter.{u_2} β) (@filter.lattice.has_inf.{u_2} β)
         (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b&#x27;)
         (@filter.principal.{u_2} β
            (@set.image.{u_1 u_2} α β e
               (@set_of.{u_1} α
                  (λ (a&#x27; : α),
                     @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                       (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                       (@prod.mk.{u_1 u_1} α α a a&#x27;)
                       s)))))
      (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
         (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
            (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
               (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                  (@filter.lattice.complete_lattice.{u_2} β))))),
b&#x27; : β,
hb&#x27; :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β b b&#x27;)
    t
⊢ @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b&#x27;
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e
          (@set_of.{u_1} α
             (λ (a&#x27; : α),
                @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                  (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                  (@prod.mk.{u_1 u_1} α α a a&#x27;)
                  s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  ⟨a, (𝓝 b).sets_of_superset (mem_nhds_left b htu) this⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_nhds_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} (c : filter.{u_2} α) {x y : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (set.{u_2} (set.{u_2} α)) (@set.has_mem.{u_2} (set.{u_2} α)) x (@filter.sets.{u_2} α c) → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) x y → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (set.{u_2} (set.{u_2} α)) (@set.has_mem.{u_2} (set.{u_2} α)) y (@filter.sets.{u_2} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] (x : α) {s : set.{u_2} (prod.{u_2 u_2} α α)}, @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) s (@uniformity.{u_2} α _inst_1) → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) (@set_of.{u_2} α (λ (y : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α x y) s)) (@nhds.{u_2} α (@uniform_space.to_topological_space.{u_2} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ (b&#x27; : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β b b&#x27;) t → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b&#x27; (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (a&#x27; : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a a&#x27;) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  lemma uniform_embedding_subtype_emb (p : α → Prop) {e : α → β} (ue : uniform_embedding e)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                     </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137    (de : dense_embedding e) : uniform_embedding (dense_embedding.subtype_emb p e) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='dense_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dense_embedding.subtype_emb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 230, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u_2} [_inst_2 : topological_space.{u_2} β] {α : Type u_1} (p : α → Prop) (e : α → β), @subtype.{u_1+1} α (λ (x : α), p x) → @subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A dense embedding is an embedding with dense image.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The dense embedding of a subtype inside its closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  { comap_uniformity := by simp [comap_comap_comp, (∘), dense_embedding.subtype_emb,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='filter.comap_comap_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='dense_embedding.subtype_emb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 914, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} {f : filter.{?l_1} α} {m : γ → β} {n : β → α}, @eq.{?l_3+1} (filter.{?l_3} γ) (@filter.comap.{?l_3 ?l_2} γ β m (@filter.comap.{?l_2 ?l_1} β α n f)) (@filter.comap.{?l_3 ?l_1} γ α (@function.comp.{?l_3+1 ?l_2+1 ?l_1+1} γ β α n m) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2} {φ : Sort ?l_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {β : Type ?l_1} [_inst_2 : topological_space.{?l_1} β] {α : Type ?l_2} (p : α → Prop) (e : α → β), @subtype.{?l_2+1} α (λ (x : α), p x) → @subtype.{?l_1+1} β (λ (x : β), @has_mem.mem.{?l_1 ?l_1} β (set.{?l_1} β) (@set.has_mem.{?l_1} β) x (@closure.{?l_1} β _inst_2 (@set.image.{?l_2 ?l_1} α β e (@set_of.{?l_2} α (λ (x : α), p x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The dense embedding of a subtype inside its closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
p : α → Prop,
e : α → β,
ue : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e
⊢ @eq.{u_1+1}
    (filter.{u_1} (prod.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))))
    (@filter.comap.{u_1 u_2}
       (prod.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x)))
       (prod.{u_2 u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))))
       (λ (x : prod.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))),
          @prod.mk.{u_2 u_2}
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e
               (@prod.fst.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))
                  x))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e
               (@prod.snd.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))
                  x)))
       (@uniformity.{u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@subtype.uniform_space.{u_2} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             _inst_2)))
    (@uniformity.{u_1} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139             uniformity_subtype, ue.comap_uniformity.symm],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='uniformity_subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 649, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {p : α → Prop} [t : uniform_space.{?l_1} α], @eq.{?l_1+1} (filter.{?l_1} (prod.{?l_1 ?l_1} (@subtype.{?l_1+1} α p) (@subtype.{?l_1+1} α p))) (@uniformity.{?l_1} (@subtype.{?l_1+1} α p) (@subtype.uniform_space.{?l_1} α p t)) (@filter.comap.{?l_1 ?l_1} (prod.{?l_1 ?l_1} (@subtype.{?l_1+1} α p) (@subtype.{?l_1+1} α p)) (prod.{?l_1 ?l_1} α α) (λ (q : prod.{?l_1 ?l_1} (@subtype.{?l_1+1} α p) (@subtype.{?l_1+1} α p)), @prod.mk.{?l_1 ?l_1} α α (@subtype.val.{?l_1+1} α p (@prod.fst.{?l_1 ?l_1} (@subtype.{?l_1+1} α p) (@subtype.{?l_1+1} α p) q)) (@subtype.val.{?l_1+1} α p (@prod.snd.{?l_1 ?l_1} (@subtype.{?l_1+1} α p) (@subtype.{?l_1+1} α p) q))) (@uniformity.{?l_1} α t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@uniformity.{u_1} α _inst_1) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (e (@prod.fst.{u_1 u_1} α α x)) (e (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
p : α → Prop,
e : α → β,
ue : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e
⊢ @eq.{u_1+1}
    (filter.{u_1} (prod.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))))
    (@filter.comap.{u_1 u_2}
       (prod.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x)))
       (prod.{u_2 u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))))
       (λ (x : prod.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))),
          @prod.mk.{u_2 u_2}
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e
               (@prod.fst.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))
                  x))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e
               (@prod.snd.{u_1 u_1} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_1+1} α (λ (x : α), p x))
                  x)))
       (@uniformity.{u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@subtype.uniform_space.{u_2} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             _inst_2)))
    (@uniformity.{u_1} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    inj := (de.subtype p).inj }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='de'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dense_embedding.subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='dense_embedding.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 230, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] {e : α → β}, @dense_embedding.{u_1 u_2} α β _inst_1 _inst_2 e → ∀ (p : α → Prop), @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))) (@subtype.topological_space.{u_1} α (λ (x : α), p x) _inst_1) (@subtype.topological_space.{u_2} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))) _inst_2) (@dense_embedding.subtype_emb.{u_2 u_1} β _inst_2 α p e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] {e : α → β}, @dense_embedding.{u_1 u_2} α β _inst_1 _inst_2 e → @function.injective.{u_1+1 u_2+1} α β e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  lemma uniform_embedding.prod {α&#x27; : Type*} {β&#x27; : Type*} [uniform_space α&#x27;] [uniform_space β&#x27;]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_4 → Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    {e₁ : α → α&#x27;} {e₂ : β → β&#x27;} (h₁ : uniform_embedding e₁) (h₂ : uniform_embedding e₂) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    uniform_embedding (λp:α×β, (e₁ p.1, e₂ p.2)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_2 → Type (max u_1 u_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3} {β : Type u_4}, α → β → prod.{u_3 u_4} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → α&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, prod.{u_1 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → β&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_2} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, prod.{u_1 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  { inj := function.injective_prod h₁.inj h₂.inj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='function.injective_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {f : α → γ} {g : β → δ}, @function.injective.{u_1+1 u_3+1} α γ f → @function.injective.{u_2+1 u_4+1} β δ g → @function.injective.{(max (u_1+1) (u_2+1)) (max (u_3+1) (u_4+1))} (prod.{u_1 u_2} α β) (prod.{u_3 u_4} γ δ) (λ (p : prod.{u_1 u_2} α β), @prod.mk.{u_3 u_4} γ δ (f (@prod.fst.{u_1 u_2} α β p)) (g (@prod.snd.{u_1 u_2} α β p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_embedding.{u_1 u_3} α α&#x27; _inst_1 _inst_4 e₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_3} β] {f : α → β}, @uniform_embedding.{u_1 u_3} α β _inst_1 _inst_2 f → @function.injective.{u_1+1 u_3+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_embedding.{u_2 u_4} β β&#x27; _inst_2 _inst_5 e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_4} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_4} β] {f : α → β}, @uniform_embedding.{u_2 u_4} α β _inst_1 _inst_2 f → @function.injective.{u_2+1 u_4+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    ..h₁.to_uniform_inducing.prod h₂.to_uniform_inducing }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.to_uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.to_uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@uniform_embedding.{u_1 u_3} α α&#x27; _inst_1 _inst_4 e₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_3} β] {f : α → β}, @uniform_embedding.{u_1 u_3} α β _inst_1 _inst_2 f → @uniform_inducing.{u_1 u_3} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {α&#x27; : Type u_3} {β&#x27; : Type u_4} [_inst_4 : uniform_space.{u_3} α&#x27;] [_inst_5 : uniform_space.{u_4} β&#x27;] {e₁ : α → α&#x27;} {e₂ : β → β&#x27;}, @uniform_inducing.{u_1 u_3} α α&#x27; _inst_1 _inst_4 e₁ → @uniform_inducing.{u_2 u_4} β β&#x27; _inst_2 _inst_5 e₂ → @uniform_inducing.{(max u_1 u_2) (max u_3 u_4)} (prod.{u_1 u_2} α β) (prod.{u_3 u_4} α&#x27; β&#x27;) (@prod.uniform_space.{u_1 u_2} α β _inst_1 _inst_2) (@prod.uniform_space.{u_3 u_4} α&#x27; β&#x27; _inst_4 _inst_5) (λ (p : prod.{u_1 u_2} α β), @prod.mk.{u_3 u_4} α&#x27; β&#x27; (e₁ (@prod.fst.{u_1 u_2} α β p)) (e₂ (@prod.snd.{u_1 u_2} α β p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_embedding.{u_2 u_4} β β&#x27; _inst_2 _inst_5 e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_4} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_4} β] {f : α → β}, @uniform_embedding.{u_2 u_4} α β _inst_1 _inst_2 f → @uniform_inducing.{u_2 u_4} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  /-- A set is complete iff its image under a uniform embedding is complete. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  lemma is_complete_image_iff {m : α → β} {s : set α} (hm : uniform_embedding m) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    is_complete (m &#x27;&#x27; s) ↔ is_complete s :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_complete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_complete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : uniform_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : uniform_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A set `s` is called *complete*, if any Cauchy filter `f` such that `s ∈ f`
has a limit in `s` (formally, it satisfies `f ≤ 𝓝 x` for some `x ∈ s`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' A set `s` is called *complete*, if any Cauchy filter `f` such that `s ∈ f`
has a limit in `s` (formally, it satisfies `f ≤ 𝓝 x` for some `x ∈ s`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m
⊢ iff (@is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s)) (@is_complete.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    refine ⟨λ c f hf fs, _, λ c f hf fs, _⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m
⊢ iff (@is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s)) (@is_complete.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153    { let f&#x27; := map m f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_1} α → filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      have cf&#x27; : cauchy f&#x27; := cauchy_map hm.to_uniform_inducing.uniform_continuous hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='cauchy_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : uniform_space.{u_2} α], filter.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : filter.{u_1} α} {m : α → β}, @uniform_continuous.{u_1 u_2} α β _inst_1 _inst_2 m → @cauchy.{u_1} α _inst_1 f → @cauchy.{u_2} β _inst_2 (@filter.map.{u_1 u_2} α β m f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cauchy.{u_1} α _inst_1 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155      have f&#x27;s : f&#x27; ≤ principal (m &#x27;&#x27; s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2}, set.{u_2} α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156      { simp only [filter.le_principal_iff, set.mem_image, filter.mem_map],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 897, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 776, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s : set.{?l_1} α} {f : filter.{?l_1} α}, iff (@has_le.le.{?l_1} (filter.{?l_1} α) (@preorder.to_has_le.{?l_1} (filter.{?l_1} α) (@partial_order.to_preorder.{?l_1} (filter.{?l_1} α) (@filter.partial_order.{?l_1} α))) f (@filter.principal.{?l_1} α s)) (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : α → β) (s : set.{?l_1} α) (y : β), iff (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) y (@set.image.{?l_1 ?l_2} α β f s)) (@Exists.{?l_1+1} α (λ (x : α), and (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s) (@eq.{?l_2+1} β (f x) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : filter.{?l_1} α} {m : α → β} {t : set.{?l_2} β}, iff (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} β) (filter.{?l_2} β) (@filter.has_mem.{?l_2} β) t (@filter.map.{?l_1 ?l_2} α β m f)) (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) (@set_of.{?l_1} α (λ (x : α), @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (m x) t)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@set_of.{u_1} α
       (λ (x : α),
          @Exists.{u_1+1} α
            (λ (x_1 : α),
               and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x_1 s)
                 (@eq.{u_2+1} β (m x_1) (m x)))))
    (@filter.sets.{u_1} α f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157        exact mem_sets_of_superset (filter.le_principal_iff.1 fs) (λx hx, ⟨x, hx, rfl⟩) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='filter.mem_sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α} {x y : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) x f → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) x y → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {s : set.{u_1} α} {f : filter.{u_1} α}, iff (@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@filter.principal.{u_1} α s)) (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@filter.principal.{u_1} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {a : α}, @eq.{u_2+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α))
    (@set_of.{u_1} α
       (λ (x : α),
          @Exists.{u_1+1} α
            (λ (x_1 : α),
               and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x_1 s)
                 (@eq.{u_2+1} β (m x_1) (m x)))))
    (@filter.sets.{u_1} α f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      rcases c f&#x27; cf&#x27; f&#x27;s with ⟨y, yms, hy⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cf&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cauchy.{u_2} β _inst_2 f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_2} (filter.{u_2} β) (@preorder.to_has_le.{u_2} (filter.{u_2} β) (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β))) f&#x27; (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
y : β,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) y)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159      rcases mem_image_iff_bex.1 yms with ⟨x, xs, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.mem_image_iff_bex'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='yms'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 892, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : set.{u_1} α} {y : β}, iff (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y (@set.image.{u_1 u_2} α β f s)) (@Exists.{u_1+1} α (λ (x : α), @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s) (λ (_x : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s), @eq.{u_2+1} β (f x) y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y (@set.image.{u_1 u_2} α β m s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
y : β,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) y)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160      rw [map_le_iff_le_comap, ← nhds_induced, ← (uniform_embedding.embedding hm).induced] at hy,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.map_le_iff_le_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_embedding.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 925, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : filter.{u_1} α} {g : filter.{u_2} β} {m : α → β}, iff (@has_le.le.{u_2} (filter.{u_2} β) (@preorder.to_has_le.{u_2} (filter.{u_2} β) (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β))) (@filter.map.{u_1 u_2} α β m f) g) (@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@filter.comap.{u_1 u_2} α β m g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [T : topological_space.{u_2} α] (f : β → α) (a : β), @eq.{u_1+1} (filter.{u_1} β) (@nhds.{u_1} β (@topological_space.induced.{u_1 u_2} β α f T) a) (@filter.comap.{u_1 u_2} β α f (@nhds.{u_2} α T (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.comap.{u_1 u_2} α β m (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x)))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@nhds.{u_1} α
       (@topological_space.induced.{u_1 u_2} α β m (@uniform_space.to_topological_space.{u_2} β _inst_2))
       x)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161      exact ⟨x, xs, hy⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β m s),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
fs :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@filter.principal.{u_1} α s),
f&#x27; : filter.{u_2} β := @filter.map.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_2} β _inst_2 f&#x27;,
f&#x27;s :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f&#x27;
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s)),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
yms : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m x) (@set.image.{u_1 u_2} α β m s),
hy :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @Exists.{u_1+1} α
    (λ (x : α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s)
         (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s),
            @has_le.le.{u_1} (filter.{u_1} α)
              (@preorder.to_has_le.{u_1} (filter.{u_1} α)
                 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
              f
              (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    { rw filter.le_principal_iff at fs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {s : set.{u_2} α} {f : filter.{u_2} α}, iff (@has_le.le.{u_2} (filter.{u_2} α) (@preorder.to_has_le.{u_2} (filter.{u_2} α) (@partial_order.to_preorder.{u_2} (filter.{u_2} α) (@filter.partial_order.{u_2} α))) f (@filter.principal.{u_2} α s)) (@has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@filter.principal.{u_2} β (@set.image.{u_1 u_2} α β m s))
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163      let f&#x27; := comap m f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164      have cf&#x27; : cauchy f&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], filter.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @cauchy.{u_1} α _inst_1 f&#x27;

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165      { have : comap m f ≠ ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @cauchy.{u_1} α _inst_1 f&#x27;

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @cauchy.{u_1} α _inst_1 f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
this :
  @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @cauchy.{u_1} α _inst_1 f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166        { refine comap_ne_bot (λt ht, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.comap_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1042, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : filter.{u_2} β} {m : α → β}, (∀ (t : set.{u_2} β), @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f → @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)) → @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
this :
  @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @cauchy.{u_1} α _inst_1 f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f
⊢ @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167          have A : t ∩ m &#x27;&#x27; s ∈ f := filter.inter_mem_sets ht fs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.inter_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_inter.{u_2} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {f : filter.{u_2} α} {s t : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s f → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) t f → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) (@has_inter.inter.{u_2} (set.{u_2} α) (@set.has_inter.{u_2} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168          obtain ⟨x, ⟨xt, ⟨y, ys, rfl⟩⟩⟩ : (t ∩ m &#x27;&#x27; s).nonempty,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f
⊢ @set.nonempty.{u_2} β
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f,
y : α,
ys : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y s,
xt : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m y) t
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169            from nonempty_of_mem_sets hf.1 A,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.nonempty_of_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {f : filter.{u_2} α}, @ne.{u_2+1} (filter.{u_2} α) f (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α))))) → ∀ {s : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s f → @set.nonempty.{u_2} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cauchy.{u_2} β _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f
⊢ @set.nonempty.{u_2} β
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))

α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f,
y : α,
ys : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y s,
xt : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m y) t
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f,
y : α,
ys : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y s,
xt : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m y) t
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170          exact ⟨y, xt⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m y) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
t : set.{u_2} β,
ht : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t f,
A :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@has_inter.inter.{u_2} (set.{u_2} β) (@set.has_inter.{u_2} β) t (@set.image.{u_1 u_2} α β m s))
    f,
y : α,
ys : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y s,
xt : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m y) t
⊢ @Exists.{u_1+1} α (λ (a : α), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
this :
  @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @cauchy.{u_1} α _inst_1 f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171        apply cauchy_comap _ hf this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='cauchy_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : filter.{u_2} β} {m : α → β}, @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α)))) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (p : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (m (@prod.fst.{u_1 u_1} α α p)) (m (@prod.snd.{u_1 u_1} α α p))) (@uniformity.{u_2} β _inst_2)) (@uniformity.{u_1} α _inst_1) → @cauchy.{u_2} β _inst_2 f → @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α))))) → @cauchy.{u_1} α _inst_1 (@filter.comap.{u_1 u_2} α β m f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cauchy.{u_2} β _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
this :
  @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @cauchy.{u_1} α _inst_1 f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
this :
  @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
       (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
          (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α))))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (m (@prod.fst.{u_1 u_1} α α p)) (m (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172        simp only [hm.comap_uniformity, le_refl] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (m (@prod.fst.{u_1 u_1} α α x)) (m (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2)) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : preorder.{?l_1} α] (a : α), @has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
this :
  @ne.{u_1+1} (filter.{u_1} α) (@filter.comap.{u_1 u_2} α β m f)
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
       (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
          (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α))))
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (p : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (m (@prod.fst.{u_1 u_1} α α p)) (m (@prod.snd.{u_1 u_1} α α p)))
       (@uniformity.{u_2} β _inst_2))
    (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173      have : f&#x27; ≤ principal s := by simp [f&#x27;]; exact</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174        ⟨m &#x27;&#x27; s, by simpa using fs, by simp [preimage_image_eq s hm.inj]⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='fs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='set.preimage_image_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1075, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : α → β} (s : set.{u_1} α), @function.injective.{u_1+1 u_2+1} α β f → @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@set.preimage.{u_1 u_2} α β f (@set.image.{u_1 u_2} α β f s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} β) (set.{u_2} (set.{u_2} β)) (@set.has_mem.{u_2} (set.{u_2} β))
    (@set.image.{u_1 u_2} α β m s)
    (@filter.sets.{u_2} β f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α)
    (@set.preimage.{u_1 u_2} α β m (@set.image.{u_1 u_2} α β m s))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;
⊢ @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s)
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      rcases c f&#x27; cf&#x27; this with ⟨x, xs, hx⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cf&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_complete.{u_1} α _inst_1 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cauchy.{u_1} α _inst_1 f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f&#x27; (@filter.principal.{u_1} α s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s)
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176      existsi [m x, mem_image_of_mem m xs],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_image_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 899, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} (f : α → β) {x : α} {a : set.{u_1} α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x a → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) (@set.image.{u_1 u_2} α β f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @Exists.{u_2+1} β
    (λ (x : β),
       @Exists.{0} (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s))
         (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@set.image.{u_1 u_2} α β m s)),
            @has_le.le.{u_2} (filter.{u_2} β)
              (@preorder.to_has_le.{u_2} (filter.{u_2} β)
                 (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
              f
              (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177      rw [(uniform_embedding.embedding hm).induced, nhds_induced] at hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='uniform_embedding.embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='nhds_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [T : topological_space.{u_2} α] (f : β → α) (a : β), @eq.{u_1+1} (filter.{u_1} β) (@nhds.{u_1} β (@topological_space.induced.{u_1 u_2} β α f T) a) (@filter.comap.{u_1 u_2} β α f (@nhds.{u_2} α T (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@nhds.{u_1} α
       (@topological_space.induced.{u_1 u_2} α β m (@uniform_space.to_topological_space.{u_2} β _inst_2))
       x)
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.comap.{u_1 u_2} α β m (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x)))
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.comap.{u_1 u_2} α β m (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x)))
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178      calc f = map m f&#x27; : (map_comap $ filter.mem_sets_of_superset fs $ image_subset_range _ _).symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='tactic.interactive.exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.map_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.mem_sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='fs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.image_subset_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 978, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1216, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_1} α → filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : filter.{u_2} β} {m : α → β}, @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.range.{u_2 u_1+1} β α m) f → @eq.{u_2+1} (filter.{u_2} β) (@filter.map.{u_1 u_2} α β m (@filter.comap.{u_1 u_2} α β m f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} {f : filter.{u_2} α} {x y : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) x f → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) x y → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {β : Type u_2} {ι : Type u_1} (f : ι → β) (s : set.{u_1} ι), @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) (@set.image.{u_1 u_2} ι β f s) (@set.range.{u_2 u_1+1} β ι f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_2} {a b : α}, @eq.{u_2+1} α a b → @eq.{u_2+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.comap.{u_1 u_2} α β m (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x)))
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179        ... ≤ map m (comap m (𝓝 (m x))) : map_mono hx</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.map_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 931, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {m : α → β}, @monotone.{u_1 u_2} (filter.{u_1} α) (filter.{u_2} β) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)) (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)) (@filter.map.{u_1 u_2} α β m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f&#x27; (@filter.comap.{u_1 u_2} α β m (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.comap.{u_1 u_2} α β m (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x)))
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180        ... ≤ 𝓝 (m x) : map_comap_le }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.map_comap_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 947, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {g : filter.{u_2} β} {m : α → β}, @has_le.le.{u_2} (filter.{u_2} β) (@preorder.to_has_le.{u_2} (filter.{u_2} β) (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β))) (@filter.map.{u_1 u_2} α β m (@filter.comap.{u_1 u_2} α β m g)) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : α → β,
s : set.{u_1} α,
hm : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 m,
c : @is_complete.{u_1} α _inst_1 s,
f : filter.{u_2} β,
hf : @cauchy.{u_2} β _inst_2 f,
fs :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@set.image.{u_1 u_2} α β m s) f,
f&#x27; : filter.{u_1} α := @filter.comap.{u_1 u_2} α β m f,
cf&#x27; : @cauchy.{u_1} α _inst_1 f&#x27;,
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.principal.{u_1} α s),
x : α,
xs : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f&#x27;
    (@filter.comap.{u_1 u_2} α β m (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x)))
⊢ @has_le.le.{u_2} (filter.{u_2} β)
    (@preorder.to_has_le.{u_2} (filter.{u_2} β)
       (@partial_order.to_preorder.{u_2} (filter.{u_2} β) (@filter.partial_order.{u_2} β)))
    f
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (m x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  lemma complete_space_extension {m : β → α} (hm : uniform_inducing m) (dense : dense_range m)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='dense_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                              </code><font color='orange'><a title='`f : α → β` has dense range if its range (image) is a dense subset of β.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    (h : ∀f:filter β, cauchy f → ∃x:α, map m f ≤ 𝓝 x) : complete_space α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : uniform_space.{u} α], filter.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  ⟨assume (f : filter α), assume hf : cauchy f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], filter.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  let</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    p : set (α × α) → set α → set α := λs t, {y : α| ∃x:α, x ∈ t ∧ (x, y) ∈ s},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    g := (𝓤 α).lift (λs, f.lift&#x27; (p s))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 175, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, filter.{u_1} α → (set.{u_1} α → filter.{u_1} β) → filter.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, filter.{u_1} α → (set.{u_1} α → set.{u_1} β) → filter.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' A variant on `bind` using a function `g` taking a set instead of a member of `α`.
This is essentially a push-forward along a function mapping each set to a filter.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' Specialize `lift` to functions `set α → set β`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  in</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  have mp₀ : monotone p,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='monotone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α β : Type u_1} [_inst_1 : preorder.{u_1} α] [_inst_2 : preorder.{u_1} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A function between preorders is monotone if
 `a ≤ b` implies `f a ≤ f b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    from assume a b h t s ⟨x, xs, xa⟩, ⟨x, xs, h xa⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='xa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@preorder.to_has_le.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α))))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) s (p a t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x s) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@has_le.le.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@preorder.to_has_le.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α))))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  have mp₁ : ∀{s}, monotone (p s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='monotone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1} [_inst_1 : preorder.{u_1} α] [_inst_2 : preorder.{u_1} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A function between preorders is monotone if
 `a ≤ b` implies `f a ≤ f b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    from assume s a b h x ⟨y, ya, yxs⟩, ⟨y, h ya, yxs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ya'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='yxs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (set.{u_1} α) (@preorder.to_has_le.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (p s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α y x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_le.le.{u_1} (set.{u_1} α) (@preorder.to_has_le.{u_1} (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  have f ≤ g, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196    le_infi $ assume s, le_infi $ assume hs, le_infi $ assume t, le_infi $ assume ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.le_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 300, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {ι : Type u_1} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (s i)) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (@lattice.infi.{u_1 (max (u_1+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{u_1} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {ι : Prop} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (s i)) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (@lattice.infi.{u_1 0} α ι (@lattice.complete_lattice.to_has_Inf.{u_1} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {ι : Type u_1} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (s i)) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (@lattice.infi.{u_1 (max (u_1+1) 1)} α ι (@lattice.complete_lattice.to_has_Inf.{u_1} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {ι : Prop} [_inst_1 : lattice.complete_lattice.{u_1} α] {s : ι → α} {a : α}, (∀ (i : ι), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (s i)) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α (@lattice.bounded_lattice.to_order_bot.{u_1} α (@lattice.complete_lattice.to_bounded_lattice.{u_1} α _inst_1))))) a (@lattice.infi.{u_1 0} α ι (@lattice.complete_lattice.to_has_Inf.{u_1} α _inst_1) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197    le_principal_iff.mpr $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {s : set.{u_1} α} {f : filter.{u_1} α}, iff (@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@filter.principal.{u_1} α s)) (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198    mem_sets_of_superset ht $ assume x hx, ⟨x, hx, refl_mem_uniformity hs⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='refl_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α} {x y : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) x f → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) x y → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {x : α} {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  have g ≠ ⊥, from ne_bot_of_le_ne_bot hf.left this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lattice.ne_bot_of_le_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : lattice.order_bot.{u_1} α] {a b : α}, @ne.{u_1+1} α b (@lattice.has_bot.bot.{u_1} α (@lattice.order_bot.to_has_bot.{u_1} α _inst_1)) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α _inst_1))) b a → @ne.{u_1+1} α a (@lattice.has_bot.bot.{u_1} α (@lattice.order_bot.to_has_bot.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@cauchy.{u_1} α _inst_1 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  have comap m g ≠ ⊥, from comap_ne_bot $ assume t ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.comap_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1042, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_2) [c : lattice.has_bot.{u_2} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} {f : filter.{u_1} β} {m : α → β}, (∀ (t : set.{u_1} β), @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) t f → @Exists.{u_2+1} α (λ (a : α), @has_mem.mem.{u_1 u_1} β (set.{u_1} β) (@set.has_mem.{u_1} β) (m a) t)) → @ne.{u_2+1} (filter.{u_2} α) (@filter.comap.{u_2 u_1} α β m f) (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203    let ⟨t&#x27;, ht&#x27;, ht_mem⟩ := (mem_lift_sets $ monotone_lift&#x27; monotone_const mp₀).mp ht in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.mem_lift_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.monotone_lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monotone_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mp₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 26, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 116, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α)) (λ (t_1 : set.{u_1} (prod.{u_1 u_1} α α)), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t_1 (@uniformity.{u_1} α _inst_1)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t_1 (@uniformity.{u_1} α _inst_1)), @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t (@filter.lift&#x27;.{u_1 u_1} α α f (p t_1)))) → @Exists.{u_2+1} β (λ (a : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t&#x27; (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t (@filter.lift&#x27;.{u_1 u_1} α α f (p t&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α β : Type u_1} {f : filter.{u_1} α} {g : set.{u_1} α → filter.{u_1} β}, @monotone.{u_1 u_1} (set.{u_1} α) (filter.{u_1} β) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (@partial_order.to_preorder.{u_1} (filter.{u_1} β) (@filter.partial_order.{u_1} β)) g → ∀ {s : set.{u_1} β}, iff (@has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) s (@filter.lift.{u_1 u_1} α β f g)) (@Exists.{u_1+1} (set.{u_1} α) (λ (t : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f), @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) s (g t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α β γ : Type u_1} [_inst_1 : preorder.{u_1} γ] {f : γ → filter.{u_1} α} {g : γ → set.{u_1} α → set.{u_1} β}, @monotone.{u_1 u_1} γ (filter.{u_1} α) _inst_1 (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)) f → @monotone.{u_1 u_1} γ (set.{u_1} α → set.{u_1} β) _inst_1 (@pi.preorder.{u_1 u_1} (set.{u_1} α) (λ (a : set.{u_1} α), set.{u_1} β) (λ (i : set.{u_1} α), @partial_order.to_preorder.{u_1} (set.{u_1} β) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} β) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} β) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} β) (@set.lattice_set.{u_1} β)))))) g → @monotone.{u_1 u_1} γ (filter.{u_1} β) _inst_1 (@partial_order.to_preorder.{u_1} (filter.{u_1} β) (@filter.partial_order.{u_1} β)) (λ (c : γ), @filter.lift&#x27;.{u_1 u_1} α β (f c) (g c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : preorder.{u_1} α] [_inst_2 : preorder.{u_1} β] {b : β}, @monotone.{u_1 u_1} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@monotone.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} α → set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α)))))) (@pi.preorder.{u_1 u_1} (set.{u_1} α) (λ (a : set.{u_1} α), set.{u_1} α) (λ (i : set.{u_1} α), @partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))) p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204    let ⟨t&#x27;&#x27;, ht&#x27;&#x27;, ht&#x27;_sub⟩ := (mem_lift&#x27;_sets mp₁).mp ht_mem in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht&#x27;_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.mem_lift&#x27;_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='mp₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u_1+1} (set.{u_1} α) (λ (t_1 : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t_1 f) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t_1 f), @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (p t&#x27; t_1) t)) → @Exists.{u_2+1} β (λ (a : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t&#x27;&#x27; f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (p t&#x27; t&#x27;&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α β : Type u_1} {f : filter.{u_1} α} {h : set.{u_1} α → set.{u_1} β}, @monotone.{u_1 u_1} (set.{u_1} α) (set.{u_1} β) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (@partial_order.to_preorder.{u_1} (set.{u_1} β) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} β) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} β) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} β) (@set.lattice_set.{u_1} β))))) h → ∀ {s : set.{u_1} β}, iff (@has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) s (@filter.lift&#x27;.{u_1 u_1} α β f h)) (@Exists.{u_1+1} (set.{u_1} α) (λ (t : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f), @has_subset.subset.{u_1} (set.{u_1} β) (@set.has_subset.{u_1} β) (h t) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {s : set.{u_1} (prod.{u_1 u_1} α α)}, @monotone.{u_1 u_1} (set.{u_1} α) (set.{u_1} α) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (@partial_order.to_preorder.{u_1} (set.{u_1} α) (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))) (p s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205    let ⟨x, (hx : x ∈ t&#x27;&#x27;)⟩ := nonempty_of_mem_sets hf.left ht&#x27;&#x27; in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.nonempty_of_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.nonempty.{u_1} α t&#x27;&#x27; → @Exists.{u_2+1} β (λ (a : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α}, @ne.{u_1+1} (filter.{u_1} α) f (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α))))) → ∀ {s : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @set.nonempty.{u_1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@cauchy.{u_1} α _inst_1 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206    have h₀ : 𝓝 x ⊓ principal (range m) ≠ ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207      by simpa [dense_range, closure_eq_nhds] using dense x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='dense_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure_eq_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 499, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 282, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : topological_space.{?l_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : topological_space.{?l_1} α] {s : set.{?l_1} α}, @eq.{(max (?l_1+1) 1)} (set.{?l_1} α) (@closure.{?l_1} α _inst_1 s) (@set_of.{?l_1} α (λ (a : α), @ne.{?l_1+1} (filter.{?l_1} α) (@lattice.has_inf.inf.{?l_1} (filter.{?l_1} α) (@filter.lattice.has_inf.{?l_1} α) (@nhds.{?l_1} α _inst_1 a) (@filter.principal.{?l_1} α s)) (@lattice.has_bot.bot.{?l_1} (filter.{?l_1} α) (@lattice.order_bot.to_has_bot.{?l_1} (filter.{?l_1} α) (@lattice.bounded_lattice.to_order_bot.{?l_1} (filter.{?l_1} α) (@lattice.complete_lattice.to_bounded_lattice.{?l_1} (filter.{?l_1} α) (@filter.lattice.complete_lattice.{?l_1} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`f : α → β` has dense range if its range (image) is a dense subset of β.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : β → α,
hm : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 m,
dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) m,
h :
  ∀ (f : filter.{u_2} β),
    @cauchy.{u_2} β _inst_2 f →
    @Exists.{u_1+1} α
      (λ (x : α),
         @has_le.le.{u_1} (filter.{u_1} α)
           (@preorder.to_has_le.{u_1} (filter.{u_1} α)
              (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
           (@filter.map.{u_2 u_1} β α m f)
           (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
p : set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α :=
  λ (s : set.{u_1} (prod.{u_1 u_1} α α)) (t : set.{u_1} α),
    @set_of.{u_1} α
      (λ (y : α),
         @Exists.{u_1+1} α
           (λ (x : α),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t)
                (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                   (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                   (@prod.mk.{u_1 u_1} α α x y)
                   s))),
g : filter.{u_1} α :=
  @filter.lift.{u_1 u_1} (prod.{u_1 u_1} α α) α (@uniformity.{u_1} α _inst_1)
    (λ (s : set.{u_1} (prod.{u_1 u_1} α α)), @filter.lift&#x27;.{u_1 u_1} α α f (p s)),
mp₀ :
  @monotone.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} α → set.{u_1} α)
    (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
       (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
          (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
                (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α))))))
    (@pi.preorder.{u_1 u_1} (set.{u_1} α) (λ (a : set.{u_1} α), set.{u_1} α)
       (λ (i : set.{u_1} α),
          @partial_order.to_preorder.{u_1} (set.{u_1} α)
            (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
               (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))
    p,
mp₁ :
  ∀ {s : set.{u_1} (prod.{u_1 u_1} α α)},
    @monotone.{u_1 u_1} (set.{u_1} α) (set.{u_1} α)
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (p s),
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    g,
this :
  @ne.{u_1+1} (filter.{u_1} α) g
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α))))),
t : set.{u_1} α,
ht : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t g,
_let_match :
  @Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α))
    (λ (t_1 : set.{u_1} (prod.{u_1 u_1} α α)),
       @Exists.{0}
         (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
            (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
            t_1
            (@uniformity.{u_1} α _inst_1))
         (λ
          (H :
            @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
              (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
              t_1
              (@uniformity.{u_1} α _inst_1)),
            @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t
              (@filter.lift&#x27;.{u_1 u_1} α α f (p t_1)))) →
  @Exists.{u_2+1} β (λ (a : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (m a) t),
t&#x27; : set.{u_1} (prod.{u_1 u_1} α α),
ht&#x27; :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t&#x27;
    (@uniformity.{u_1} α _inst_1),
ht_mem :
  @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t
    (@filter.lift&#x27;.{u_1 u_1} α α f (p t&#x27;)),
_let_match :
  @Exists.{u_1+1} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t_1 f)
         (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t_1 f),
            @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (p t&#x27; t_1) t)) →
  @Exists.{u_2+1} β (λ (a : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (m a) t),
t&#x27;&#x27; : set.{u_1} α,
ht&#x27;&#x27; : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t&#x27;&#x27; f,
ht&#x27;_sub : @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (p t&#x27; t&#x27;&#x27;) t,
_let_match :
  @set.nonempty.{u_1} α t&#x27;&#x27; →
  @Exists.{u_2+1} β (λ (a : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (m a) t),
x : α,
hx : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t&#x27;&#x27;
⊢ @ne.{u_1+1} (filter.{u_1} α)
    (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
       (@filter.principal.{u_1} α (@set.range.{u_1 u_2+1} α β m)))
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208    have h₁ : {y | (x, y) ∈ t&#x27;} ∈ 𝓝 x ⊓ principal (range m),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209      from @mem_inf_sets_of_left α (𝓝 x) (principal (range m)) _ $ mem_nhds_left x ht&#x27;,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.mem_inf_sets_of_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='mem_nhds_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 280, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u_1} {f g : filter.{u_1} α} {s : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] (x : α) {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) s)) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210    have h₂ : range m ∈ 𝓝 x ⊓ principal (range m),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211      from @mem_inf_sets_of_right α (𝓝 x) (principal (range m)) _ $ subset.refl _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.mem_inf_sets_of_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.subset.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 283, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u_1} {f g : filter.{u_1} α} {s : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s g → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} (a : set.{u_1} α), @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212    have {y | (x, y) ∈ t&#x27;} ∩ range m ∈ 𝓝 x ⊓ principal (range m),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [c : has_inter.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213      from @inter_mem_sets α (𝓝 x ⊓ principal (range m)) _ _ h₁ h₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.inter_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α} {s t : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) t&#x27;)) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x) (@filter.principal.{u_1} α (@set.range.{u_1 u_2+1} α β m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set.range.{u_1 u_2+1} α β m) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x) (@filter.principal.{u_1} α (@set.range.{u_1 u_2+1} α β m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214    let ⟨y, xyt&#x27;, b, b_eq⟩ := nonempty_of_mem_sets h₀ this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='xyt&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.nonempty_of_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h₀'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@set.nonempty.{u_1} α (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) (@set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) t&#x27;)) (@set.range.{u_1 u_2+1} α β m)) → @Exists.{u_2+1} β (λ (a : β), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) (m a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) t&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@eq.{u_1+1} α (m b) y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α}, @ne.{u_1+1} (filter.{u_1} α) f (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α))))) → ∀ {s : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @set.nonempty.{u_1} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x) (@filter.principal.{u_1} α (@set.range.{u_1 u_2+1} α β m))) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@has_inter.inter.{u_1} (set.{u_1} α) (@set.has_inter.{u_1} α) (@set_of.{u_1} α (λ (y : α), @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x y) t&#x27;)) (@set.range.{u_1 u_2+1} α β m)) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x) (@filter.principal.{u_1} α (@set.range.{u_1 u_2+1} α β m)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215    ⟨b, b_eq.symm ▸ ht&#x27;_sub ⟨x, hx, xyt&#x27;⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{u_1+1} α a b → @eq.{u_1+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {P : α → Prop} {a b : α}, @eq.{u_1+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  have cauchy g, from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], filter.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218    ⟨‹g ≠ ⊥›, assume s hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219    let</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α)) (λ (t : set.{u_1} (prod.{u_1 u_1} α α)), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α t t) s)) → @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@filter.prod.{u_1 u_1} α α g g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220      ⟨s₁, hs₁, (comp_s₁ : comp_rel s₁ s₁ ⊆ s)⟩ := comp_mem_uniformity_sets hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp_s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s₁ (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α s₁ s₁) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α)) (λ (t : set.{u_1} (prod.{u_1 u_1} α α)), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221      ⟨s₂, hs₂, (comp_s₂ : comp_rel s₂ s₂ ⊆ s₁)⟩ := comp_mem_uniformity_sets hs₁,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='comp_s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='comp_mem_uniformity_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s₂ (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α s₂ s₂) s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @Exists.{u_1+1} (set.{u_1} (prod.{u_1 u_1} α α)) (λ (t : set.{u_1} (prod.{u_1 u_1} α α)), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@comp_rel.{u_1} α t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222      ⟨t, ht, (prod_t : set.prod t t ⊆ s₂)⟩ := mem_prod_same_iff.mp (hf.right hs₂)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod_t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.mem_prod_same_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@set.prod.{u_1 u_1} α α t t) s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α β : Type u_1}, set.{u_1} α → set.{u_1} β → set.{u_1} (prod.{u_1 u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} {f : filter.{u_1} α} {s : set.{u_1} (prod.{u_1 u_1} α α)}, iff (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@filter.prod.{u_1 u_1} α α f f)) (@Exists.{u_1+1} (set.{u_1} α) (λ (t : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@set.prod.{u_1 u_1} α α t t) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@cauchy.{u_1} α _inst_1 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223    in</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224    have hg₁ : p (preimage prod.swap s₁) t ∈ g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_1}, (α → β) → set.{u_1} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → prod.{u_1 u_1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Swap the factors of a product. `swap (a, b) = (b, a)`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225      from mem_lift (symm_le_uniformity hs₁) $ @mem_lift&#x27; α α f _ t ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.mem_lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='symm_le_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.mem_lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 171, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α β : Type u_1} {f : filter.{u_1} α} {g : set.{u_1} α → filter.{u_1} β} {s : set.{u_1} β} {t : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f → @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) s (g t) → @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) s (@filter.lift.{u_1 u_1} α β f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α)))) (@filter.map.{u_1 u_1} (prod.{u_1 u_1} α α) (prod.{u_1 u_1} α α) (@prod.swap.{u_1 u_1} α α) (@uniformity.{u_1} α _inst_1)) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α β : Type u_1} {f : filter.{u_1} α} {h : set.{u_1} α → set.{u_1} β} {t : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f → @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) (h t) (@filter.lift&#x27;.{u_1 u_1} α β f h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226    have hg₂ : p s₂ t ∈ g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227      from mem_lift hs₂ $ @mem_lift&#x27; α α f _ t ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.mem_lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.mem_lift&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α β : Type u_1} {f : filter.{u_1} α} {g : set.{u_1} α → filter.{u_1} β} {s : set.{u_1} β} {t : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f → @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) s (g t) → @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) s (@filter.lift.{u_1 u_1} α β f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α β : Type u_1} {f : filter.{u_1} α} {h : set.{u_1} α → set.{u_1} β} {t : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t f → @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) (h t) (@filter.lift&#x27;.{u_1 u_1} α β f h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228    have hg : set.prod (p (preimage prod.swap s₁) t) (p s₂ t) ∈ filter.prod g g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1524, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α β : Type u_1}, set.{u_1} α → set.{u_1} β → set.{u_1} (prod.{u_1 u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_1}, (α → β) → set.{u_1} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → prod.{u_1 u_1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, filter.{u_1} α → filter.{u_1} β → filter.{u_1} (prod.{u_1 u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Swap the factors of a product. `swap (a, b) = (b, a)`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Product of filters. This is the filter generated by cartesian products
 of elements of the component filters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229      from @prod_mem_prod α α _ _ g g hg₁ hg₂,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.prod_mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hg₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1527, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='∀ {α β : Type u_1} {s : set.{u_1} α} {t : set.{u_1} β} {f : filter.{u_1} α} {g : filter.{u_1} β}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f → @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) t g → @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α β)) (filter.{u_1} (prod.{u_1 u_1} α β)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α β)) (@set.prod.{u_1 u_1} α β s t) (@filter.prod.{u_1 u_1} α β f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (p (@set.preimage.{u_1 u_1} (prod.{u_1 u_1} α α) (prod.{u_1 u_1} α α) (@prod.swap.{u_1 u_1} α α) s₁) t) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (p s₂ t) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    (filter.prod g g).sets_of_superset hg</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1524, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, filter.{u_1} α → filter.{u_1} β → filter.{u_1} (prod.{u_1 u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} (c : filter.{u_1} α) {x y : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) x (@filter.sets.{u_1} α c) → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) x y → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) y (@filter.sets.{u_1} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@set.prod.{u_1 u_1} α α (p (@set.preimage.{u_1 u_1} (prod.{u_1 u_1} α α) (prod.{u_1 u_1} α α) (@prod.swap.{u_1 u_1} α α) s₁) t) (p s₂ t)) (@filter.prod.{u_1 u_1} α α g g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Product of filters. This is the filter generated by cartesian products
 of elements of the component filters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231      (assume ⟨a, b⟩ ⟨⟨c₁, c₁t, hc₁⟩, ⟨c₂, c₂t, hc₂⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c₁t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='c₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c₂t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a b) (@set.prod.{u_1 u_1} α α (p (@set.preimage.{u_1 u_1} (prod.{u_1 u_1} α α) (prod.{u_1 u_1} α α) (@prod.swap.{u_1 u_1} α α) s₁) t) (p s₂ t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) c₁ t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α c₁ (@prod.fst.{u_1 u_1} α α (@prod.mk.{u_1 u_1} α α a b))) (@set.preimage.{u_1 u_1} (prod.{u_1 u_1} α α) (prod.{u_1 u_1} α α) (@prod.swap.{u_1 u_1} α α) s₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) c₂ t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α c₂ (@prod.snd.{u_1 u_1} α α (@prod.mk.{u_1 u_1} α α a b))) s₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232        have (c₁, c₂) ∈ set.prod t t, from ⟨c₁t, c₂t⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, set.{u_1} α → set.{u_1} β → set.{u_1} (prod.{u_1 u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233        comp_s₁ $ prod_mk_mem_comp_rel hc₁ $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='prod_mk_mem_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ {α : Type u_1} {a b c : α} {s t : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a c) s → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α c b) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a b) (@comp_rel.{u_1} α s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234        comp_s₂ $ prod_mk_mem_comp_rel (prod_t this) hc₂)⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='prod_mk_mem_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 59, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ {α : Type u_1} {a b c : α} {s t : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a c) s → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α c b) t → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α a b) (@comp_rel.{u_1} α s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α c₁ c₂) (@set.prod.{u_1 u_1} α α t t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  have cauchy (filter.comap m g),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : uniform_space.{u_2} α], filter.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237    from cauchy_comap (le_of_eq hm.comap_uniformity) ‹cauchy g› (by assumption),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='cauchy_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.comap_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : filter.{u_1} β} {m : α → β}, @has_le.le.{u_2} (filter.{u_2} (prod.{u_2 u_2} α α)) (@preorder.to_has_le.{u_2} (filter.{u_2} (prod.{u_2 u_2} α α)) (@partial_order.to_preorder.{u_2} (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.partial_order.{u_2} (prod.{u_2 u_2} α α)))) (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} α α) (prod.{u_1 u_1} β β) (λ (p : prod.{u_2 u_2} α α), @prod.mk.{u_1 u_1} β β (m (@prod.fst.{u_2 u_2} α α p)) (m (@prod.snd.{u_2 u_2} α α p))) (@uniformity.{u_1} β _inst_2)) (@uniformity.{u_2} α _inst_1) → @cauchy.{u_1} β _inst_2 f → @ne.{u_2+1} (filter.{u_2} α) (@filter.comap.{u_2 u_1} α β m f) (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α))))) → @cauchy.{u_2} α _inst_1 (@filter.comap.{u_2 u_1} α β m f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @eq.{u_2+1} α a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : α → β}, @uniform_inducing.{u_2 u_1} α β _inst_1 _inst_2 f → @eq.{u_2+1} (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} α α) (prod.{u_1 u_1} β β) (λ (x : prod.{u_2 u_2} α α), @prod.mk.{u_1 u_1} β β (f (@prod.fst.{u_2 u_2} α α x)) (f (@prod.snd.{u_2 u_2} α α x))) (@uniformity.{u_1} β _inst_2)) (@uniformity.{u_2} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], filter.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : β → α,
hm : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 m,
dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) m,
h :
  ∀ (f : filter.{u_2} β),
    @cauchy.{u_2} β _inst_2 f →
    @Exists.{u_1+1} α
      (λ (x : α),
         @has_le.le.{u_1} (filter.{u_1} α)
           (@preorder.to_has_le.{u_1} (filter.{u_1} α)
              (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
           (@filter.map.{u_2 u_1} β α m f)
           (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
p : set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α :=
  λ (s : set.{u_1} (prod.{u_1 u_1} α α)) (t : set.{u_1} α),
    @set_of.{u_1} α
      (λ (y : α),
         @Exists.{u_1+1} α
           (λ (x : α),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t)
                (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                   (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                   (@prod.mk.{u_1 u_1} α α x y)
                   s))),
g : filter.{u_1} α :=
  @filter.lift.{u_1 u_1} (prod.{u_1 u_1} α α) α (@uniformity.{u_1} α _inst_1)
    (λ (s : set.{u_1} (prod.{u_1 u_1} α α)), @filter.lift&#x27;.{u_1 u_1} α α f (p s)),
mp₀ :
  @monotone.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} α → set.{u_1} α)
    (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
       (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
          (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
                (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α))))))
    (@pi.preorder.{u_1 u_1} (set.{u_1} α) (λ (a : set.{u_1} α), set.{u_1} α)
       (λ (i : set.{u_1} α),
          @partial_order.to_preorder.{u_1} (set.{u_1} α)
            (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
               (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))
    p,
mp₁ :
  ∀ {s : set.{u_1} (prod.{u_1 u_1} α α)},
    @monotone.{u_1 u_1} (set.{u_1} α) (set.{u_1} α)
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (p s),
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    g,
this :
  @ne.{u_1+1} (filter.{u_1} α) g
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α))))),
this :
  @ne.{u_2+1} (filter.{u_2} β) (@filter.comap.{u_2 u_1} β α m g)
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β))))),
this : @cauchy.{u_1} α _inst_1 g
⊢ @ne.{u_2+1} (filter.{u_2} β) (@filter.comap.{u_2 u_1} β α m g)
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  let ⟨x, (hx : map m (filter.comap m g) ≤ 𝓝 x)⟩ := h _ this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_1+1} α (λ (x : α), @has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g)) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) → @Exists.{u_1+1} α (λ (x : α), @has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g)) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_2} α → filter.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ (f : filter.{u_2} β), @cauchy.{u_2} β _inst_2 f → @Exists.{u_1+1} α (λ (x : α), @has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) (@filter.map.{u_2 u_1} β α m f) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@cauchy.{u_2} β _inst_2 (@filter.comap.{u_2 u_1} β α m g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  have map m (filter.comap m g) ⊓ 𝓝 x ≠ ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_2} α → filter.{u_1} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241    from (le_nhds_iff_adhp_of_cauchy (cauchy_map hm.uniform_continuous this)).mp hx,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_nhds_iff_adhp_of_cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cauchy_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 64, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {f : filter.{u_1} α} {x : α}, @cauchy.{u_1} α _inst_1 f → iff (@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) (@ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) f (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : filter.{u_2} α} {m : α → β}, @uniform_continuous.{u_2 u_1} α β _inst_1 _inst_2 m → @cauchy.{u_2} α _inst_1 f → @cauchy.{u_1} β _inst_2 (@filter.map.{u_2 u_1} α β m f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : α → β}, @uniform_inducing.{u_2 u_1} α β _inst_1 _inst_2 f → @uniform_continuous.{u_2 u_1} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@cauchy.{u_2} β _inst_2 (@filter.comap.{u_2 u_1} β α m g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  have g ⊓ 𝓝 x ≠ ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    from ne_bot_of_le_ne_bot this (inf_le_inf (assume s hs, ⟨s, hs, subset.refl _⟩) (le_refl _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='lattice.ne_bot_of_le_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.inf_le_inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 117, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 201, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : lattice.order_bot.{u_1} α] {a b : α}, @ne.{u_1+1} α b (@lattice.has_bot.bot.{u_1} α (@lattice.order_bot.to_has_bot.{u_1} α _inst_1)) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α _inst_1))) b a → @ne.{u_1+1} α a (@lattice.has_bot.bot.{u_1} α (@lattice.order_bot.to_has_bot.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g)) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : lattice.semilattice_inf.{u_1} α] {a b c d : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α _inst_1))) a b → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α _inst_1))) c d → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α _inst_1))) (@lattice.has_inf.inf.{u_1} α (@lattice.semilattice_inf.to_has_inf.{u_1} α _inst_1) a c) (@lattice.has_inf.inf.{u_1} α (@lattice.semilattice_inf.to_has_inf.{u_1} α _inst_1) b d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} (a : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : preorder.{u_1} α] (a : α), @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  ⟨x, calc f ≤ g : by assumption</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : β → α,
hm : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 m,
dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) m,
h :
  ∀ (f : filter.{u_2} β),
    @cauchy.{u_2} β _inst_2 f →
    @Exists.{u_1+1} α
      (λ (x : α),
         @has_le.le.{u_1} (filter.{u_1} α)
           (@preorder.to_has_le.{u_1} (filter.{u_1} α)
              (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
           (@filter.map.{u_2 u_1} β α m f)
           (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
p : set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α :=
  λ (s : set.{u_1} (prod.{u_1 u_1} α α)) (t : set.{u_1} α),
    @set_of.{u_1} α
      (λ (y : α),
         @Exists.{u_1+1} α
           (λ (x : α),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t)
                (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                   (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                   (@prod.mk.{u_1 u_1} α α x y)
                   s))),
g : filter.{u_1} α :=
  @filter.lift.{u_1 u_1} (prod.{u_1 u_1} α α) α (@uniformity.{u_1} α _inst_1)
    (λ (s : set.{u_1} (prod.{u_1 u_1} α α)), @filter.lift&#x27;.{u_1 u_1} α α f (p s)),
mp₀ :
  @monotone.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} α → set.{u_1} α)
    (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
       (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
          (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
                (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α))))))
    (@pi.preorder.{u_1 u_1} (set.{u_1} α) (λ (a : set.{u_1} α), set.{u_1} α)
       (λ (i : set.{u_1} α),
          @partial_order.to_preorder.{u_1} (set.{u_1} α)
            (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
               (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))
    p,
mp₁ :
  ∀ {s : set.{u_1} (prod.{u_1 u_1} α α)},
    @monotone.{u_1 u_1} (set.{u_1} α) (set.{u_1} α)
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (p s),
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    g,
this :
  @ne.{u_1+1} (filter.{u_1} α) g
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α))))),
this :
  @ne.{u_2+1} (filter.{u_2} β) (@filter.comap.{u_2 u_1} β α m g)
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β))))),
this : @cauchy.{u_1} α _inst_1 g,
this : @cauchy.{u_2} β _inst_2 (@filter.comap.{u_2 u_1} β α m g),
_let_match :
  @Exists.{u_1+1} α
    (λ (x : α),
       @has_le.le.{u_1} (filter.{u_1} α)
         (@preorder.to_has_le.{u_1} (filter.{u_1} α)
            (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
         (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g))
         (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) →
  @Exists.{u_1+1} α
    (λ (x : α),
       @has_le.le.{u_1} (filter.{u_1} α)
         (@preorder.to_has_le.{u_1} (filter.{u_1} α)
            (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
         f
         (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)),
x : α,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g))
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x),
this :
  @ne.{u_1+1} (filter.{u_1} α)
    (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
       (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g))
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x))
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α))))),
this :
  @ne.{u_1+1} (filter.{u_1} α)
    (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) g
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x))
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246    ... ≤ 𝓝 x : le_nhds_of_cauchy_adhp ‹cauchy g› this⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='le_nhds_of_cauchy_adhp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='tactic'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/tactic.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {f : filter.{u_1} α} {x : α}, @cauchy.{u_1} α _inst_1 f → @ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) f (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α))))) → @has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], filter.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) g (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point
for `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
m : β → α,
hm : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 m,
dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) m,
h :
  ∀ (f : filter.{u_2} β),
    @cauchy.{u_2} β _inst_2 f →
    @Exists.{u_1+1} α
      (λ (x : α),
         @has_le.le.{u_1} (filter.{u_1} α)
           (@preorder.to_has_le.{u_1} (filter.{u_1} α)
              (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
           (@filter.map.{u_2 u_1} β α m f)
           (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)),
f : filter.{u_1} α,
hf : @cauchy.{u_1} α _inst_1 f,
p : set.{u_1} (prod.{u_1 u_1} α α) → set.{u_1} α → set.{u_1} α :=
  λ (s : set.{u_1} (prod.{u_1 u_1} α α)) (t : set.{u_1} α),
    @set_of.{u_1} α
      (λ (y : α),
         @Exists.{u_1+1} α
           (λ (x : α),
              and (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x t)
                (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                   (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                   (@prod.mk.{u_1 u_1} α α x y)
                   s))),
g : filter.{u_1} α :=
  @filter.lift.{u_1 u_1} (prod.{u_1 u_1} α α) α (@uniformity.{u_1} α _inst_1)
    (λ (s : set.{u_1} (prod.{u_1 u_1} α α)), @filter.lift&#x27;.{u_1 u_1} α α f (p s)),
mp₀ :
  @monotone.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (set.{u_1} α → set.{u_1} α)
    (@partial_order.to_preorder.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
       (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
          (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} (prod.{u_1 u_1} α α))
                (@set.lattice_set.{u_1} (prod.{u_1 u_1} α α))))))
    (@pi.preorder.{u_1 u_1} (set.{u_1} α) (λ (a : set.{u_1} α), set.{u_1} α)
       (λ (i : set.{u_1} α),
          @partial_order.to_preorder.{u_1} (set.{u_1} α)
            (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
               (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
                  (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α))))))
    p,
mp₁ :
  ∀ {s : set.{u_1} (prod.{u_1 u_1} α α)},
    @monotone.{u_1 u_1} (set.{u_1} α) (set.{u_1} α)
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (@partial_order.to_preorder.{u_1} (set.{u_1} α)
         (@lattice.order_bot.to_partial_order.{u_1} (set.{u_1} α)
            (@lattice.bounded_lattice.to_order_bot.{u_1} (set.{u_1} α)
               (@lattice.complete_lattice.to_bounded_lattice.{u_1} (set.{u_1} α) (@set.lattice_set.{u_1} α)))))
      (p s),
this :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    g,
this :
  @ne.{u_1+1} (filter.{u_1} α) g
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α))))),
this :
  @ne.{u_2+1} (filter.{u_2} β) (@filter.comap.{u_2 u_1} β α m g)
    (@lattice.has_bot.bot.{u_2} (filter.{u_2} β)
       (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} β)
          (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} β)
             (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} β)
                (@filter.lattice.complete_lattice.{u_2} β))))),
this : @cauchy.{u_1} α _inst_1 g,
this : @cauchy.{u_2} β _inst_2 (@filter.comap.{u_2 u_1} β α m g),
_let_match :
  @Exists.{u_1+1} α
    (λ (x : α),
       @has_le.le.{u_1} (filter.{u_1} α)
         (@preorder.to_has_le.{u_1} (filter.{u_1} α)
            (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
         (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g))
         (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)) →
  @Exists.{u_1+1} α
    (λ (x : α),
       @has_le.le.{u_1} (filter.{u_1} α)
         (@preorder.to_has_le.{u_1} (filter.{u_1} α)
            (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
         f
         (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)),
x : α,
hx :
  @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g))
    (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x),
this :
  @ne.{u_1+1} (filter.{u_1} α)
    (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
       (@filter.map.{u_2 u_1} β α m (@filter.comap.{u_2 u_1} β α m g))
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x))
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α))))),
this :
  @ne.{u_1+1} (filter.{u_1} α)
    (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) g
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x))
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α)))))
⊢ @has_le.le.{u_1} (filter.{u_1} α)
    (@preorder.to_has_le.{u_1} (filter.{u_1} α)
       (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α)))
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  lemma totally_bounded_preimage {f : α → β} {s : set β} (hf : uniform_embedding f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249    (hs : totally_bounded s) : totally_bounded (f ⁻¹&#x27; s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='totally_bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='totally_bounded'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : uniform_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : uniform_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A set `s` is totally bounded if for every entourage `d` there is a finite
 set of points `t` such that every element of `s` is `d`-near to some element of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='A set `s` is totally bounded if for every entourage `d` there is a finite
 set of points `t` such that every element of `s` is `d`-near to some element of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  λ t ht, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@uniformity.{u_1} α _inst_1)
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251    rw ← hf.comap_uniformity at ht,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2)) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@uniformity.{u_1} α _inst_1)
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    rcases mem_comap_sets.2 ht with ⟨t&#x27;, ht&#x27;, ts⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.mem_comap_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 906, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {g : filter.{u_2} β} {m : α → β} {s : set.{u_1} α}, iff (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s (@filter.comap.{u_1 u_2} α β m g)) (@Exists.{u_2+1} (set.{u_2} β) (λ (t : set.{u_2} β), @Exists.{0} (@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t g) (λ (H : @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) t g), @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β m t) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2))
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253    rcases totally_bounded_iff_subset.1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='totally_bounded_iff_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 207, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] {s : set.{u_2} α}, iff (@totally_bounded.{u_2} α _inst_1 s) (∀ (d : set.{u_2} (prod.{u_2 u_2} α α)), @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} α α)) (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} α α)) d (@uniformity.{u_2} α _inst_1) → @Exists.{u_2+1} (set.{u_2} α) (λ (t : set.{u_2} α), @Exists.{0} (@has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) t s) (λ (H : @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) t s), and (@set.finite.{u_2} α t) (@has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.Union.{u_2 u_2+1} α α (λ (y : α), @set.Union.{u_2 0} α (@has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y t) (λ (H : @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) y t), @set_of.{u_2} α (λ (x : α), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} α α) (set.{u_2} (prod.{u_2 u_2} α α)) (@set.has_mem.{u_2} (prod.{u_2 u_2} α α)) (@prod.mk.{u_2 u_2} α α x y) d))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254      (totally_bounded_subset (image_preimage_subset f s) hs) _ ht&#x27; with ⟨c, cs, hfc, hct⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='totally_bounded_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.image_preimage_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ht&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1067, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : uniform_space.{u_2} α] {s₁ s₂ : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s₁ s₂ → @totally_bounded.{u_2} α _inst_1 s₂ → @totally_bounded.{u_2} α _inst_1 s₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : set.{u_2} β), @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@totally_bounded.{u_2} β _inst_2 s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) t&#x27; (@uniformity.{u_2} β _inst_2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;))))
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255    refine ⟨f ⁻¹&#x27; c, finite_preimage (inj_on_of_injective _ hf.inj) hfc, λ x h, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.finite_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.inj_on_of_injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hfc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/finite.lean&#x27;, &#x27;line&#x27;: 241, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/function.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_2} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {s : set.{u_2} β} {f : α → β}, @set.inj_on.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s) → @set.finite.{u_2} β s → @set.finite.{u_1} α (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : α → β} (s : set.{u_1} α), @function.injective.{u_1+1 u_2+1} α β f → @set.inj_on.{u_1 u_2} α β f s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.finite.{u_2} β c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;))))
⊢ @Exists.{(max (u_1+1) 1)} (set.{u_1} α)
    (λ (t_1 : set.{u_1} α),
       and (@set.finite.{u_1} α t_1)
         (@has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@set.preimage.{u_1 u_2} α β f s)
            (@set.Union.{u_1 u_1+1} α α
               (λ (y : α),
                  @set.Union.{u_1 0} α (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1)
                    (λ (H : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y t_1),
                       @set_of.{u_1} α
                         (λ (x : α),
                            @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                              (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                              (@prod.mk.{u_1 u_1} α α x y)
                              t))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s)
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.Union.{u_1 u_1+1} α α
       (λ (y : α),
          @set.Union.{u_1 0} α
            (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f c))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f c)),
               @set_of.{u_1} α
                 (λ (x : α),
                    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                      (@prod.mk.{u_1 u_1} α α x y)
                      t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256    have := hct (mem_image_of_mem f h), simp at this ⊢,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hct'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_image_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 899, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)) (@set.Union.{u_2 u_2+1} β β (λ (y : β), @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c) (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c), @set_of.{u_2} β (λ (x : β), @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β x y) t&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} (f : α → β) {x : α} {a : set.{u_1} α}, @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x a → @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x) (@set.image.{u_1 u_2} α β f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s)
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.Union.{u_1 u_1+1} α α
       (λ (y : α),
          @set.Union.{u_1 0} α
            (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f c))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f c)),
               @set_of.{u_1} α
                 (λ (x : α),
                    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                      (@prod.mk.{u_1 u_1} α α x y)
                      t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f x)
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;))))
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.Union.{u_1 u_1+1} α α
       (λ (y : α),
          @set.Union.{u_1 0} α
            (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f c))
            (λ
             (H :
               @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f c)),
               @set_of.{u_1} α
                 (λ (x : α),
                    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
                      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
                      (@prod.mk.{u_1 u_1} α α x y)
                      t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
this :
  @Exists.{u_2+1} β
    (λ (i : β),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) i c)
         (@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
            (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
            (@prod.mk.{u_2 u_2} β β (f x) i)
            t&#x27;))
⊢ @Exists.{u_1+1} α
    (λ (i : α),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f i) c)
         (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
            (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
            (@prod.mk.{u_1 u_1} α α x i)
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257    rcases this with ⟨z, zc, zt⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_2+1} β (λ (i : β), and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) i c) (@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) i) t&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
this :
  @Exists.{u_2+1} β
    (λ (i : β),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) i c)
         (@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
            (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
            (@prod.mk.{u_2 u_2} β β (f x) i)
            t&#x27;))
⊢ @Exists.{u_1+1} α
    (λ (i : α),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f i) c)
         (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
            (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
            (@prod.mk.{u_1 u_1} α α x i)
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
z : β,
zc : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) z c,
zt :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β (f x) z)
    t&#x27;
⊢ @Exists.{u_1+1} α
    (λ (i : α),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f i) c)
         (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
            (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
            (@prod.mk.{u_1 u_1} α α x i)
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258    rcases cs zc with ⟨y, yc, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='zc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) z c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
z : β,
zc : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) z c,
zt :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β (f x) z)
    t&#x27;
⊢ @Exists.{u_1+1} α
    (λ (i : α),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f i) c)
         (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
            (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
            (@prod.mk.{u_1 u_1} α α x i)
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
y : α,
yc : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f s),
zc : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) c,
zt :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β (f x) (f y))
    t&#x27;
⊢ @Exists.{u_1+1} α
    (λ (i : α),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f i) c)
         (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
            (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
            (@prod.mk.{u_1 u_1} α α x i)
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259    exact ⟨y, zc, ts (by exact zt)⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='zt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) t&#x27;) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@prod.mk.{u_2 u_2} β β (f x) (f y)) t&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
y : α,
yc : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f s),
zc : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) c,
zt :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β (f x) (f y))
    t&#x27;
⊢ @Exists.{u_1+1} α
    (λ (i : α),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f i) c)
         (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
            (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
            (@prod.mk.{u_1 u_1} α α x i)
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
y : α,
yc : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f s),
zc : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) c,
zt :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β (f x) (f y))
    t&#x27;
⊢ @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@prod.mk.{u_1 u_1} α α x y)
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
f : α → β,
s : set.{u_2} β,
hf : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f,
hs : @totally_bounded.{u_2} β _inst_2 s,
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_2} β _inst_2)),
t&#x27; : set.{u_2} (prod.{u_2 u_2} β β),
ht&#x27; :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    t&#x27;
    (@uniformity.{u_2} β _inst_2),
ts :
  @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α))
    (@set.preimage.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x)))
       t&#x27;)
    t,
c : set.{u_2} β,
cs :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) c
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s)),
hfc : @set.finite.{u_2} β c,
hct :
  @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β)
    (@set.image.{u_1 u_2} α β f (@set.preimage.{u_1 u_2} α β f s))
    (@set.Union.{u_2 u_2+1} β β
       (λ (y : β),
          @set.Union.{u_2 0} β (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c)
            (λ (H : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) y c),
               @set_of.{u_2} β
                 (λ (x : β),
                    @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
                      (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
                      (@prod.mk.{u_2 u_2} β β x y)
                      t&#x27;)))),
x : α,
h : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set.preimage.{u_1 u_2} α β f s),
y : α,
yc : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) y (@set.preimage.{u_1 u_2} α β f s),
zc : @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f y) c,
zt :
  @has_mem.mem.{u_2 u_2} (prod.{u_2 u_2} β β) (set.{u_2} (prod.{u_2 u_2} β β))
    (@set.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@prod.mk.{u_2 u_2} β β (f x) (f y))
    t&#x27;
⊢ @Exists.{u_1+1} α
    (λ (i : α),
       and (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f i) c)
         (@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
            (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
            (@prod.mk.{u_1 u_1} α α x i)
            t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  lemma uniform_embedding_comap {α : Type*} {β : Type*} {f : α → β} [u : uniform_space β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265    (hf : function.injective f) : @uniform_embedding α β (uniform_space.comap f u) u f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 540, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → uniform_space.{u_2} β → uniform_space.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='uniform_space.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='uniform_space.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title='Given `f : α → β` and a uniformity `u` on `β`, the inverse image of `u` under `f`
 is the inverse image in the filter sense of the induced function `α × α → β × β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  @uniform_embedding.mk _ _ (uniform_space.comap f u) _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_embedding.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='uniform_space.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 540, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f → @function.injective.{u_1+1 u_2+1} α β f → @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → uniform_space.{u_2} β → uniform_space.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='uniform_space.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='Given `f : α → β` and a uniformity `u` on `β`, the inverse image of `u` under `f`
 is the inverse image in the filter sense of the induced function `α × α → β × β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267    (@uniform_inducing.mk _ _ (uniform_space.comap f u) _ _ rfl) hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_inducing.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='uniform_space.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 540, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.comap.{u_1 u_2} (prod.{u_1 u_1} α α) (prod.{u_2 u_2} β β) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_2 u_2} β β (f (@prod.fst.{u_1 u_1} α α x)) (f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_2} β _inst_2)) (@uniformity.{u_1} α _inst_1) → @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → uniform_space.{u_2} β → uniform_space.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='uniform_space.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@function.injective.{u_1+1 u_2+1} α β f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='Given `f : α → β` and a uniformity `u` on `β`, the inverse image of `u` under `f`
 is the inverse image in the filter sense of the induced function `α × α → β × β`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  section uniform_extension</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  variables {α : Type*} {β : Type*} {γ : Type*}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272            [uniform_space α] [uniform_space β] [uniform_space γ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_3 → Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A uniform space is a generalization of the &quot;uniform&quot; topological aspects of a
 metric space. It consists of a filter on `α × α` called the &quot;uniformity&quot;, which
 satisfies properties analogous to the reflexivity, symmetry, and triangle properties
 of a metric.

 A metric space has a natural uniformity, and a uniform space has a natural topology.
 A topological group also has a natural uniformity, even when it is not metrizable.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273            {e : β → α}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274            (h_e : uniform_inducing e)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275            (h_dense : dense_range e)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='dense_range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`f : α → β` has dense range if its range (image) is a dense subset of β.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276            {f : β → γ}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277            (h_f : uniform_continuous f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279  local notation `ψ` := (h_e.dense_inducing h_dense).extend f</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  lemma uniformly_extend_exists [complete_space γ] (a : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π (α : Type u_3) [_inst_2 : uniform_space.{u_3} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282    ∃c, tendsto f (comap e (𝓝 a)) (𝓝 c) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{v} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_3} [_inst_1 : topological_space.{u_3} α], α → filter.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  let de := (h_e.dense_inducing h_dense) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='de'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.dense_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : α → β}, @uniform_inducing.{u_2 u_1} α β _inst_1 _inst_2 f → @dense_range.{u_2 u_1} α β (@uniform_space.to_topological_space.{u_1} β _inst_2) f → @dense_inducing.{u_2 u_1} α β (@uniform_space.to_topological_space.{u_2} α _inst_1) (@uniform_space.to_topological_space.{u_1} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  have cauchy (𝓝 a), from cauchy_nhds,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cauchy_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α], filter.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {a : α}, @cauchy.{u_1} α _inst_1 (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  have cauchy (comap e (𝓝 a)), from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : uniform_space.{u_2} α], filter.{u_2} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286    cauchy_comap (le_of_eq h_e.comap_uniformity) this de.comap_nhds_ne_bot,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cauchy_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.comap_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='de'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dense_inducing.comap_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 100, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : filter.{u_1} β} {m : α → β}, @has_le.le.{u_2} (filter.{u_2} (prod.{u_2 u_2} α α)) (@preorder.to_has_le.{u_2} (filter.{u_2} (prod.{u_2 u_2} α α)) (@partial_order.to_preorder.{u_2} (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.partial_order.{u_2} (prod.{u_2 u_2} α α)))) (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} α α) (prod.{u_1 u_1} β β) (λ (p : prod.{u_2 u_2} α α), @prod.mk.{u_1 u_1} β β (m (@prod.fst.{u_2 u_2} α α p)) (m (@prod.snd.{u_2 u_2} α α p))) (@uniformity.{u_1} β _inst_2)) (@uniformity.{u_2} α _inst_1) → @cauchy.{u_1} β _inst_2 f → @ne.{u_2+1} (filter.{u_2} α) (@filter.comap.{u_2 u_1} α β m f) (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α))))) → @cauchy.{u_2} α _inst_1 (@filter.comap.{u_2 u_1} α β m f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @eq.{u_2+1} α a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : α → β}, @uniform_inducing.{u_2 u_1} α β _inst_1 _inst_2 f → @eq.{u_2+1} (filter.{u_2} (prod.{u_2 u_2} α α)) (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} α α) (prod.{u_1 u_1} β β) (λ (x : prod.{u_2 u_2} α α), @prod.mk.{u_1 u_1} β β (f (@prod.fst.{u_2 u_2} α α x)) (f (@prod.snd.{u_2 u_2} α α x))) (@uniformity.{u_1} β _inst_2)) (@uniformity.{u_2} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@cauchy.{u_1} α _inst_1 (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_1} β] {i : α → β}, @dense_inducing.{u_2 u_1} α β _inst_1 _inst_2 i → ∀ {b : β}, @ne.{u_2+1} (filter.{u_2} α) (@filter.comap.{u_2 u_1} α β i (@nhds.{u_1} β _inst_2 b)) (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  have cauchy (map f (comap e (𝓝 a))), from</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='cauchy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_3} [_inst_1 : uniform_space.{u_3} α], filter.{u_3} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → filter.{u_2} α → filter.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A filter `f` is Cauchy if for every entourage `r`, there exists an
 `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy
 sequences, because if `a : ℕ → α` then the filter of sets containing
 cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288    cauchy_map h_f this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cauchy_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_3} β] {f : filter.{u_2} α} {m : α → β}, @uniform_continuous.{u_2 u_3} α β _inst_1 _inst_2 m → @cauchy.{u_2} α _inst_1 f → @cauchy.{u_3} β _inst_2 (@filter.map.{u_2 u_3} α β m f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@cauchy.{u_2} β _inst_2 (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  complete_space.complete this</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='complete_space.complete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_3} [_inst_2 : uniform_space.{u_3} α] [c : @complete_space.{u_3} α _inst_2] {f : filter.{u_3} α}, @cauchy.{u_3} α _inst_2 f → @Exists.{u_3+1} α (λ (x : α), @has_le.le.{u_3} (filter.{u_3} α) (@preorder.to_has_le.{u_3} (filter.{u_3} α) (@partial_order.to_preorder.{u_3} (filter.{u_3} α) (@filter.partial_order.{u_3} α))) f (@nhds.{u_3} α (@uniform_space.to_topological_space.{u_3} α _inst_2) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@cauchy.{u_3} γ _inst_3 (@filter.map.{u_2 u_3} β γ f (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291  lemma uniform_extend_subtype [complete_space γ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π (α : Type u_3) [_inst_2 : uniform_space.{u_3} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    {p : α → Prop} {e : α → β} {f : α → γ} {b : β} {s : set α}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293    (hf : uniform_continuous (λx:subtype p, f x.val))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Sort u}, (α → Prop) → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294    (he : uniform_embedding e) (hd : ∀x:β, x ∈ closure (range e))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Sort x}, (ι → α) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295    (hb : closure (e &#x27;&#x27; s) ∈ 𝓝 b) (hs : is_closed s) (hp : ∀x∈s, p x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], set.{u} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A set is closed if its complement is open'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296    ∃c, tendsto f (comap e (𝓝 b)) (𝓝 c) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{v} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_3} [_inst_1 : topological_space.{u_3} α], α → filter.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  have de : dense_embedding e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='dense_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 230, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='A dense embedding is an embedding with dense image.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298    from he.dense_embedding hd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.dense_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 95, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @dense_range.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_2} β _inst_2) f → @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  have de&#x27; : dense_embedding (dense_embedding.subtype_emb p e),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='dense_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dense_embedding.subtype_emb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 230, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u_2} [_inst_2 : topological_space.{u_2} β] {α : Type u_1} (p : α → Prop) (e : α → β), @subtype.{u_1+1} α (λ (x : α), p x) → @subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A dense embedding is an embedding with dense image.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The dense embedding of a subtype inside its closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300    by exact de.subtype p,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='de'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 267, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e
⊢ @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  have ue&#x27; : uniform_embedding (dense_embedding.subtype_emb p e),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='uniform_embedding'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dense_embedding.subtype_emb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u_2} [_inst_2 : topological_space.{u_2} β] {α : Type u_1} (p : α → Prop) (e : α → β), @subtype.{u_1+1} α (λ (x : α), p x) → @subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The dense embedding of a subtype inside its closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302    from uniform_embedding_subtype_emb _ he de,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniform_embedding_subtype_emb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='de'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] (p : α → Prop) {e : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e → @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) e → @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))) (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1) (@subtype.uniform_space.{u_2} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))) _inst_2) (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  have b ∈ closure (e &#x27;&#x27; {x | p x}),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304    from (closure_mono $ mono_image $ hp) (mem_of_nhds hb),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='closure_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.mono_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_of_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 918, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 425, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {s t : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s t → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@closure.{u_2} α _inst_1 s) (@closure.{u_2} α _inst_1 t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s t : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) s t → @has_subset.subset.{u_2} (set.{u_2} β) (@set.has_subset.{u_2} β) (@set.image.{u_1 u_2} α β f s) (@set.image.{u_1 u_2} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {a : α} {s : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s (@nhds.{u_2} α _inst_1 a) → @has_mem.mem.{u_2 u_2} α (set.{u_2} α) (@set.has_mem.{u_2} α) a s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s)) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305  let ⟨c, (hc : tendsto (f ∘ subtype.val) (comap (dense_embedding.subtype_emb p e) (𝓝 ⟨b, this⟩)) (𝓝 c))⟩ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dense_embedding.subtype_emb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 263, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_3+1} γ (λ (c : γ), @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)) (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))) (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e) (@nhds.{u_2} (@subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))) (@uniform_space.to_topological_space.{u_2} (@subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))) (@subtype.uniform_space.{u_2} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))) _inst_2)) (@subtype.mk.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))) b this))) (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) → @Exists.{u_3+1} γ (λ (c : γ), @filter.tendsto.{u_1 u_3} α γ f (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)) (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_3}, (α → β) → filter.{u_1} α → filter.{u_3} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {β : Type u_2} [_inst_2 : topological_space.{u_2} β] {α : Type u_1} (p : α → Prop) (e : α → β), @subtype.{u_1+1} α (λ (x : α), p x) → @subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β _inst_2 (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_3} [_inst_1 : topological_space.{u_3} α], α → filter.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The dense embedding of a subtype inside its closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306    uniformly_extend_exists ue&#x27;.to_uniform_inducing de&#x27;.dense hf _ in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformly_extend_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ue&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_embedding.to_uniform_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='de&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dense_inducing.dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 33, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 77, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] [_inst_3 : uniform_space.{u_3} γ] {e : β → α}, @uniform_inducing.{u_1 u_2} β α _inst_2 _inst_1 e → @dense_range.{u_1 u_2} β α (@uniform_space.to_topological_space.{u_2} α _inst_1) e → ∀ {f : β → γ}, @uniform_continuous.{u_1 u_3} β γ _inst_2 _inst_3 f → ∀ [_inst_4 : @complete_space.{u_3} γ _inst_3] (a : α), @Exists.{u_3+1} γ (λ (c : γ), @filter.tendsto.{u_1 u_3} β γ f (@filter.comap.{u_1 u_2} β α e (@nhds.{u_2} α (@uniform_space.to_topological_space.{u_2} α _inst_1) a)) (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))) (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1) (@subtype.uniform_space.{u_2} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))) _inst_2) (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] {f : α → β}, @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 f → @uniform_inducing.{u_1 u_2} α β _inst_1 _inst_2 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x)) (@subtype.{u_2+1} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))) (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1)) (@subtype.topological_space.{u_2} β (λ (x : β), @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))) (@uniform_space.to_topological_space.{u_2} β _inst_2)) (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β] {i : α → β}, @dense_inducing.{u_1 u_2} α β _inst_1 _inst_2 i → @dense_range.{u_1 u_2} α β _inst_2 i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3 (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.{u_2+1} β
          (λ (x : β),
             @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
               (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                  (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
       (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
       (@nhds.{u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@subtype.topological_space.{u_2} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             (@uniform_space.to_topological_space.{u_2} β _inst_2))
          (@subtype.mk.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             b
             this)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308    rw [nhds_subtype_eq_comap] at hc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nhds_subtype_eq_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 407, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : topological_space.{u_2} α] {p : α → Prop} {a : α} {h : p a}, @eq.{u_2+1} (filter.{u_2} (@subtype.{u_2+1} α p)) (@nhds.{u_2} (@subtype.{u_2+1} α p) (@subtype.topological_space.{u_2} α p _inst_1) (@subtype.mk.{u_2+1} α p a h)) (@filter.comap.{u_2 u_2} (@subtype.{u_2+1} α p) α (@subtype.val.{u_2+1} α p) (@nhds.{u_2} α _inst_1 a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.{u_2+1} β
          (λ (x : β),
             @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
               (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                  (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
       (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
       (@nhds.{u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@subtype.topological_space.{u_2} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             (@uniform_space.to_topological_space.{u_2} β _inst_2))
          (@subtype.mk.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             b
             this)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.{u_2+1} β
          (λ (x : β),
             @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
               (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                  (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
       (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
       (@filter.comap.{u_2 u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          β
          (@subtype.val.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.{u_2+1} β
          (λ (x : β),
             @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
               (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                  (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
       (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
       (@nhds.{u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@subtype.topological_space.{u_2} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             (@uniform_space.to_topological_space.{u_2} β _inst_2))
          (@subtype.mk.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
             b
             this)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.{u_2+1} β
          (λ (x : β),
             @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
               (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                  (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
       (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
       (@filter.comap.{u_2 u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          β
          (@subtype.val.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309    simp [comap_comap_comp] at hc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.comap_comap_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 914, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} {f : filter.{?l_1} α} {m : γ → β} {n : β → α}, @eq.{?l_3+1} (filter.{?l_3} γ) (@filter.comap.{?l_3 ?l_2} γ β m (@filter.comap.{?l_2 ?l_1} β α n f)) (@filter.comap.{?l_3 ?l_1} γ α (@function.comp.{?l_3+1 ?l_2+1 ?l_1+1} γ β α n m) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
       (@subtype.{u_2+1} β
          (λ (x : β),
             @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
               (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                  (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
       (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
       (@filter.comap.{u_2 u_2}
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          β
          (@subtype.val.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x)) β
       (@function.comp.{u_1+1 u_2+1 u_2+1} (@subtype.{u_1+1} α (λ (x : α), p x))
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          β
          (@subtype.val.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e))
       (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310    change (tendsto (f ∘ @subtype.val α p) (comap (e ∘ @subtype.val α p) (𝓝 b)) (𝓝 c)) at hc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='function.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 25}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_3}, (α → β) → filter.{u_1} α → filter.{u_3} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1} {φ : Type u_3}, (β → φ) → (α → β) → α → φ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → filter.{u_2} β → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], α → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α (λ (x : α), p x)) α γ f
       (@subtype.val.{u_1+1} α (λ (x : α), p x)))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x)) β
       (@function.comp.{u_1+1 u_2+1 u_2+1} (@subtype.{u_1+1} α (λ (x : α), p x))
          (@subtype.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          β
          (@subtype.val.{u_2+1} β
             (λ (x : β),
                @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                  (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                     (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
          (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e))
       (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α p) β
       (@function.comp.{(max 1 (u_1+1)) u_1+1 u_2+1} (@subtype.{u_1+1} α p) α β e (@subtype.val.{u_1+1} α p))
       (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311    rw [←comap_comap_comp, tendsto_comap&#x27;_iff] at hc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.comap_comap_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto_comap&#x27;_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 914, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1426, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β γ : Type u_1} {f : filter.{u_2} α} {m : γ → β} {n : β → α}, @eq.{u_1+1} (filter.{u_1} γ) (@filter.comap.{u_1 u_1} γ β m (@filter.comap.{u_1 u_2} β α n f)) (@filter.comap.{u_1 u_2} γ α (@function.comp.{u_1+1 u_1+1 u_2+1} γ β α n m) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_3} {γ : Type u_1} {m : α → β} {f : filter.{u_1} α} {g : filter.{u_3} β} {i : γ → α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) (@set.range.{u_1 u_1+1} α γ i) f → iff (@filter.tendsto.{u_1 u_3} γ β (@function.comp.{u_1+1 u_1+1 u_3+1} γ α β m i) (@filter.comap.{u_1 u_1} γ α i f) g) (@filter.tendsto.{u_1 u_3} α β m f g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α p) β
       (@function.comp.{(max 1 (u_1+1)) u_1+1 u_2+1} (@subtype.{u_1+1} α p) α β e (@subtype.val.{u_1+1} α p))
       (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} α γ f
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α p) β
       (@function.comp.{(max 1 (u_1+1)) u_1+1 u_2+1} (@subtype.{u_1+1} α p) α β e (@subtype.val.{u_1+1} α p))
       (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} α γ f
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312    exact ⟨c, hc⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{u_1 u_3} α γ f (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)) (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} α γ f
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313    exact ⟨_, hb, assume x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β) (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s)) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>314      begin</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.preimage.{u_1 u_2} α β e
       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>315        change e x ∈ (closure (e &#x27;&#x27; s)) → x ∈ range subtype.val,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [_inst_1 : topological_space.{u_2} α], set.{u_2} α → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2}, (α → β) → set.{u_1} α → set.{u_2} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_1}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The closure of `s` is the smallest closed set containing `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.preimage.{u_1 u_2} α β e
       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (e x)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s)) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>316        rw [←closure_induced, closure_eq_nhds, mem_set_of_eq, (≠), nhds_induced, ← de.to_dense_inducing.nhds_eq_comap],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='closure_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure_eq_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds_induced'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 542, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 499, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/order.lean&#x27;, &#x27;line&#x27;: 511, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [t : topological_space.{u_2} β] {f : α → β} {a : α} {s : set.{u_1} α}, (∀ (x y : α), @eq.{u_2+1} β (f x) (f y) → @eq.{u_1+1} α x y) → iff (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@closure.{u_1} α (@topological_space.induced.{u_1 u_2} α β f t) s)) (@has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (f a) (@closure.{u_2} β t (@set.image.{u_1 u_2} α β f s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@closure.{u_1} α _inst_1 s) (@set_of.{u_1} α (λ (a : α), @ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@nhds.{u_1} α _inst_1 a) (@filter.principal.{u_1} α s)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set_of.{u_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [T : topological_space.{u_2} α] (f : β → α) (a : β), @eq.{u_1+1} (filter.{u_1} β) (@nhds.{u_1} β (@topological_space.induced.{u_1 u_2} β α f T) a) (@filter.comap.{u_1 u_2} β α f (@nhds.{u_2} α T (f a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : α), @eq.{u_1+1} (filter.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (e a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) (e x)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s)) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@closure.{u_1} α
       (@topological_space.induced.{u_1 u_2} α β e (@uniform_space.to_topological_space.{u_2} β _inst_2))
       s) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set_of.{u_1} α
       (λ (a : α),
          @ne.{u_1+1} (filter.{u_1} α)
            (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
               (@nhds.{u_1} α
                  (@topological_space.induced.{u_1 u_2} α β e (@uniform_space.to_topological_space.{u_2} β _inst_2))
                  a)
               (@filter.principal.{u_1} α s))
            (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
               (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
                  (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
                     (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                        (@filter.lattice.complete_lattice.{u_1} α))))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @ne.{u_1+1} (filter.{u_1} α)
    (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
       (@nhds.{u_1} α
          (@topological_space.induced.{u_1 u_2} α β e (@uniform_space.to_topological_space.{u_2} β _inst_2))
          x)
       (@filter.principal.{u_1} α s))
    (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
       (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
          (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
             (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                (@filter.lattice.complete_lattice.{u_1} α))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ not
    (@eq.{u_1+1} (filter.{u_1} α)
       (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
          (@nhds.{u_1} α
             (@topological_space.induced.{u_1 u_2} α β e (@uniform_space.to_topological_space.{u_2} β _inst_2))
             x)
          (@filter.principal.{u_1} α s))
       (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
          (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
             (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                   (@filter.lattice.complete_lattice.{u_1} α)))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ not
    (@eq.{u_1+1} (filter.{u_1} α)
       (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
          (@filter.comap.{u_1 u_2} α β e
             (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (e x)))
          (@filter.principal.{u_1} α s))
       (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
          (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
             (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                   (@filter.lattice.complete_lattice.{u_1} α)))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ not
    (@eq.{u_1+1} (filter.{u_1} α)
       (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
          (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
          (@filter.principal.{u_1} α s))
       (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
          (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
             (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                   (@filter.lattice.complete_lattice.{u_1} α)))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>317        change x ∈ {x | 𝓝 x ⊓ principal s ≠ ⊥} → x ∈ range subtype.val,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.has_inf.inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/lattice.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x (@set_of.{u_1} α (λ (x : α), @ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x) (@filter.principal.{u_1} α s)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, (α → Prop) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [c : lattice.has_inf.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_1}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {p : α → Prop}, @subtype.{u_1+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ not
    (@eq.{u_1+1} (filter.{u_1} α)
       (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
          (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
          (@filter.principal.{u_1} α s))
       (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
          (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
             (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
                (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                   (@filter.lattice.complete_lattice.{u_1} α)))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set_of.{u_1} α
       (λ (x : α),
          @ne.{u_1+1} (filter.{u_1} α)
            (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
               (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
               (@filter.principal.{u_1} α s))
            (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
               (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
                  (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
                     (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                        (@filter.lattice.complete_lattice.{u_1} α))))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>318        rw [←closure_eq_nhds, closure_eq_of_is_closed hs],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='closure_eq_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='closure_eq_of_is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 499, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 256, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@closure.{u_1} α _inst_1 s) (@set_of.{u_1} α (λ (a : α), @ne.{u_1+1} (filter.{u_1} α) (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α) (@nhds.{u_1} α _inst_1 a) (@filter.principal.{u_1} α s)) (@lattice.has_bot.bot.{u_1} (filter.{u_1} α) (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α) (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α) (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α) (@filter.lattice.complete_lattice.{u_1} α)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, @is_closed.{u_1} α _inst_1 s → @eq.{(max (u_1+1) 1)} (set.{u_1} α) (@closure.{u_1} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set_of.{u_1} α
       (λ (x : α),
          @ne.{u_1+1} (filter.{u_1} α)
            (@lattice.has_inf.inf.{u_1} (filter.{u_1} α) (@filter.lattice.has_inf.{u_1} α)
               (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x)
               (@filter.principal.{u_1} α s))
            (@lattice.has_bot.bot.{u_1} (filter.{u_1} α)
               (@lattice.order_bot.to_has_bot.{u_1} (filter.{u_1} α)
                  (@lattice.bounded_lattice.to_order_bot.{u_1} (filter.{u_1} α)
                     (@lattice.complete_lattice.to_bounded_lattice.{u_1} (filter.{u_1} α)
                        (@filter.lattice.complete_lattice.{u_1} α))))))) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@closure.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s) →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>319        exact assume hxs, ⟨⟨x, hp x hxs⟩, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s →
  @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x
    (@set.range.{u_1 (max 1 (u_1+1))} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>320        exact de.inj</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='de'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 230, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_2} β _inst_2) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>321      end⟩</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c),
x : α
⊢ ∀ (x y : α), @eq.{u_2+1} β (e x) (e y) → @eq.{u_1+1} α x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
_inst_4 : @complete_space.{u_3} γ _inst_3,
p : α → Prop,
e : α → β,
f : α → γ,
b : β,
s : set.{u_1} α,
hf :
  @uniform_continuous.{u_1 u_3} (@subtype.{u_1+1} α p) γ (@subtype.uniform_space.{u_1} α p _inst_1) _inst_3
    (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x)),
he : @uniform_embedding.{u_1 u_2} α β _inst_1 _inst_2 e,
hd :
  ∀ (x : β),
    @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
      (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.range.{u_2 u_1+1} β α e)),
hb :
  @has_mem.mem.{u_2 u_2} (set.{u_2} β) (filter.{u_2} β) (@filter.has_mem.{u_2} β)
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) (@set.image.{u_1 u_2} α β e s))
    (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b),
hs : @is_closed.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) s,
hp : ∀ (x : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) x s → p x,
de :
  @dense_embedding.{u_1 u_2} α β (@uniform_space.to_topological_space.{u_1} α _inst_1)
    (@uniform_space.to_topological_space.{u_2} β _inst_2)
    e,
de&#x27; :
  @dense_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.topological_space.{u_1} α (λ (x : α), p x) (@uniform_space.to_topological_space.{u_1} α _inst_1))
    (@subtype.topological_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       (@uniform_space.to_topological_space.{u_2} β _inst_2))
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
ue&#x27; :
  @uniform_embedding.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
    (@subtype.{u_2+1} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
    (@subtype.uniform_space.{u_1} α (λ (x : α), p x) _inst_1)
    (@subtype.uniform_space.{u_2} β
       (λ (x : β),
          @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
            (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
       _inst_2)
    (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e),
this :
  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) b
    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))),
_let_match :
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α (λ (x : α), p x)) γ
         (λ (x : @subtype.{u_1+1} α p), f (@subtype.val.{u_1+1} α p x))
         (@filter.comap.{u_1 u_2} (@subtype.{u_1+1} α (λ (x : α), p x))
            (@subtype.{u_2+1} β
               (λ (x : β),
                  @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                    (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
            (@dense_embedding.subtype_emb.{u_2 u_1} β (@uniform_space.to_topological_space.{u_2} β _inst_2) α p e)
            (@nhds.{u_2}
               (@subtype.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
               (@uniform_space.to_topological_space.{u_2}
                  (@subtype.{u_2+1} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x))))))
                  (@subtype.uniform_space.{u_2} β
                     (λ (x : β),
                        @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                          (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                             (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                     _inst_2))
               (@subtype.mk.{u_2+1} β
                  (λ (x : β),
                     @has_mem.mem.{u_2 u_2} β (set.{u_2} β) (@set.has_mem.{u_2} β) x
                       (@closure.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2)
                          (@set.image.{u_1 u_2} α β e (@set_of.{u_1} α (λ (x : α), p x)))))
                  b
                  this)))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)) →
  @Exists.{u_3+1} γ
    (λ (c : γ),
       @filter.tendsto.{u_1 u_3} α γ f
         (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))
         (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)),
c : γ,
hc :
  @filter.tendsto.{u_1 u_3} (@subtype.{u_1+1} α p) γ
    (@function.comp.{u_1+1 u_1+1 u_3+1} (@subtype.{u_1+1} α p) α γ f (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_1} (@subtype.{u_1+1} α p) α (@subtype.val.{u_1+1} α p)
       (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c)
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α)
    (@set.range.{u_1 u_1+1} α (@subtype.{u_1+1} α p) (@subtype.val.{u_1+1} α p))
    (@filter.comap.{u_1 u_2} α β e (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>322  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>323  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>324  variables [separated γ]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/separation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (α : Type u_3) [_inst_4 : uniform_space.{u_3} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>325  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>326  lemma uniformly_extend_of_ind (b : β) : ψ (e b) = f b :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>327  dense_inducing.extend_e_eq _ b (continuous_iff_continuous_at.1 h_f.continuous b)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dense_inducing.extend_e_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_iff_continuous_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_continuous.continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 168, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 677, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 591, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_1} β] {i : α → β} (di : @dense_inducing.{u_2 u_1} α β _inst_1 _inst_2 i) [_inst_4 : topological_space.{u_3} γ] [_inst_5 : @t2_space.{u_3} γ _inst_4] {f : α → γ} (a : α), @continuous_at.{u_2 u_3} α γ _inst_1 _inst_4 f a → @eq.{u_3+1} γ (@dense_inducing.extend.{u_2 u_1 u_3} α β γ _inst_1 _inst_2 i _inst_4 di f (i a)) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_3} β] {f : α → β}, iff (@continuous.{u_2 u_3} α β _inst_1 _inst_2 f) (∀ (x : α), @continuous_at.{u_2 u_3} α β _inst_1 _inst_2 f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_3} β] {f : α → β}, @uniform_continuous.{u_2 u_3} α β _inst_1 _inst_2 f → @continuous.{u_2 u_3} α β (@uniform_space.to_topological_space.{u_2} α _inst_1) (@uniform_space.to_topological_space.{u_3} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>328  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>329  include h_f</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>330  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>331  lemma uniformly_extend_spec [complete_space γ] (a : α) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π (α : Type u_3) [_inst_2 : uniform_space.{u_3} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>332    tendsto f (comap e (𝓝 a)) (𝓝 (ψ a)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{v} β → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_3} [_inst_1 : topological_space.{u_3} α], α → filter.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>333  let de := (h_e.dense_inducing h_dense) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='de'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.dense_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : α → β}, @uniform_inducing.{u_2 u_1} α β _inst_1 _inst_2 f → @dense_range.{u_2 u_1} α β (@uniform_space.to_topological_space.{u_1} β _inst_2) f → @dense_inducing.{u_2 u_1} α β (@uniform_space.to_topological_space.{u_2} α _inst_1) (@uniform_space.to_topological_space.{u_1} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>334  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>335    by_cases ha : a ∈ range e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.range'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1190, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {ι : Type u_2}, (ι → α) → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Range of a function.

This function is more flexible than `f &#x27;&#x27; univ`, as the image requires that the domain is in Type
and not an arbitrary Sort.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e)
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e))
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>336    { rcases ha with ⟨b, rfl⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e)
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))

α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e))
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e)
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
b : β
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) (e b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          (e b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>337      rw [uniformly_extend_of_ind _ _ h_f, ← de.nhds_eq_comap],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniformly_extend_of_ind'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 326, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] [_inst_3 : uniform_space.{u_3} γ] {e : β → α} (h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e) (h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e) {f : β → γ}, @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f → ∀ [_inst_4 : @separated.{u_3} γ _inst_3] (b : β), @eq.{u_3+1} γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (e b)) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : β), @eq.{u_2+1} (filter.{u_2} β) (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) a) (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) (e a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
b : β
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) (e b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          (e b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
b : β
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) (e b)))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) (f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
b : β
⊢ @filter.tendsto.{u_2 u_3} β γ f (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) (f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>338      exact h_f.continuous.tendsto _ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='h_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 591, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
b : β
⊢ @filter.tendsto.{u_2 u_3} β γ f (@nhds.{u_2} β (@uniform_space.to_topological_space.{u_2} β _inst_2) b)
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) (f b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e))
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>339    { simp only [dense_inducing.extend, dif_neg ha],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='dense_inducing.extend'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dif_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 934, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} {γ : Type ?l_3} [_inst_1 : topological_space.{?l_1} α] [_inst_2 : topological_space.{?l_2} β] {i : α → β} [_inst_4 : topological_space.{?l_3} γ], @dense_inducing.{?l_1 ?l_2} α β _inst_1 _inst_2 i → (α → γ) → β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c] (hnc : not c) {α : Sort ?l_1} {t : c → α} {e : not c → α}, @eq.{?l_1} α (@dite.{?l_1} c h α t e) (e hnc)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e))
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
          (@uniform_space.to_topological_space.{u_1} α _inst_1)
          e
          (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
          f
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e))
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@lim.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@inhabited.mk.{u_3+1} γ
             (f
                (@inhabited.default.{u_2+1} β
                   (@dense_range.inhabited.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e
                      (@dense_inducing.dense.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
                         (@uniform_space.to_topological_space.{u_1} α _inst_1)
                         e
                         (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense))
                      a))))
          (@filter.map.{u_2 u_3} β γ f
             (@filter.comap.{u_2 u_1} β α e
                (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>340      exact (@lim_spec _ _ (id _) _ $ uniformly_extend_exists h_e h_dense h_f _) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='lim_spec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniformly_extend_exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 587, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 281, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : topological_space.{u_3} α] [_inst_2 : inhabited.{u_3+1} α] {f : filter.{u_3} α}, @Exists.{u_3+1} α (λ (a : α), @has_le.le.{u_3} (filter.{u_3} α) (@preorder.to_has_le.{u_3} (filter.{u_3} α) (@partial_order.to_preorder.{u_3} (filter.{u_3} α) (@filter.partial_order.{u_3} α))) f (@nhds.{u_3} α _inst_1 a)) → @has_le.le.{u_3} (filter.{u_3} α) (@preorder.to_has_le.{u_3} (filter.{u_3} α) (@partial_order.to_preorder.{u_3} (filter.{u_3} α) (@filter.partial_order.{u_3} α))) f (@nhds.{u_3} α _inst_1 (@lim.{u_3} α _inst_1 _inst_2 f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] [_inst_3 : uniform_space.{u_3} γ] {e : β → α}, @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e → @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e → ∀ {f : β → γ}, @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f → ∀ [_inst_4 : @complete_space.{u_3} γ _inst_3] (a : α), @Exists.{u_3+1} γ (λ (c : γ), @filter.tendsto.{u_2 u_3} β γ f (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)) (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
_inst_5 : @complete_space.{u_3} γ _inst_3,
a : α,
de : @dense_inducing.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
  (@uniform_space.to_topological_space.{u_1} α _inst_1)
  e :=
  @uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense,
ha : not (@has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a (@set.range.{u_1 u_2+1} α β e))
⊢ @filter.tendsto.{u_2 u_3} β γ f
    (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))
    (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
       (@lim.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3)
          (@inhabited.mk.{u_3+1} γ
             (f
                (@inhabited.default.{u_2+1} β
                   (@dense_range.inhabited.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e
                      (@dense_inducing.dense.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_2} β _inst_2)
                         (@uniform_space.to_topological_space.{u_1} α _inst_1)
                         e
                         (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense))
                      a))))
          (@filter.map.{u_2 u_3} β γ f
             (@filter.comap.{u_2 u_1} β α e
                (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>341  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>342  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>343  lemma uniform_continuous_uniformly_extend [cγ : complete_space γ] : uniform_continuous ψ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>344  assume d hd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='set.{u_3} (prod.{u_3 u_3} γ γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) d (@uniformity.{u_3} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>345  let ⟨s, hs, hs_comp⟩ := (mem_lift&#x27;_sets $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hs_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='filter.mem_lift&#x27;_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/lift.lean&#x27;, &#x27;line&#x27;: 184, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)), @Exists.{0} (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) t (@uniformity.{u_3} γ _inst_3)) (λ (H : @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) t (@uniformity.{u_3} γ _inst_3)), @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ)) (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t) (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t) (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t))) d)) → @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) d (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.fst.{u_1 u_1} α α x)) (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_3} (prod.{u_3 u_3} γ γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) s (@uniformity.{u_3} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ)) (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s) (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s) (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s))) d'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α β : Type u_3} {f : filter.{u_3} α} {h : set.{u_3} α → set.{u_3} β}, @monotone.{u_3 u_3} (set.{u_3} α) (set.{u_3} β) (@partial_order.to_preorder.{u_3} (set.{u_3} α) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} α) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} α) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} α) (@set.lattice_set.{u_3} α))))) (@partial_order.to_preorder.{u_3} (set.{u_3} β) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} β) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} β) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} β) (@set.lattice_set.{u_3} β))))) h → ∀ {s : set.{u_3} β}, iff (@has_mem.mem.{u_3 u_3} (set.{u_3} β) (filter.{u_3} β) (@filter.has_mem.{u_3} β) s (@filter.lift&#x27;.{u_3 u_3} α β f h)) (@Exists.{u_3+1} (set.{u_3} α) (λ (t : set.{u_3} α), @Exists.{0} (@has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) t f) (λ (H : @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) t f), @has_subset.subset.{u_3} (set.{u_3} β) (@set.has_subset.{u_3} β) (h t) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>346    monotone_comp_rel monotone_id $ monotone_comp_rel monotone_id monotone_id).mp (comp_le_uniformity3 hd) in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='monotone_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monotone_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='monotone_comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monotone_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='monotone_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='comp_le_uniformity3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u_3} [_inst_1 : preorder.{u_3} β] {f g : β → set.{u_3} (prod.{u_3 u_3} α α)}, @monotone.{u_3 u_3} β (set.{u_3} (prod.{u_3 u_3} α α)) _inst_1 (@partial_order.to_preorder.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@set.lattice_set.{u_3} (prod.{u_3 u_3} α α)))))) f → @monotone.{u_3 u_3} β (set.{u_3} (prod.{u_3 u_3} α α)) _inst_1 (@partial_order.to_preorder.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@set.lattice_set.{u_3} (prod.{u_3 u_3} α α)))))) g → @monotone.{u_3 u_3} β (set.{u_3} (prod.{u_3 u_3} α α)) _inst_1 (@partial_order.to_preorder.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@set.lattice_set.{u_3} (prod.{u_3 u_3} α α)))))) (λ (x : β), @comp_rel.{u_3} α (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : preorder.{u_3} α], @monotone.{u_3 u_3} α α _inst_1 _inst_1 (@id.{u_3+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α β : Type u_3} [_inst_1 : preorder.{u_3} β] {f g : β → set.{u_3} (prod.{u_3 u_3} α α)}, @monotone.{u_3 u_3} β (set.{u_3} (prod.{u_3 u_3} α α)) _inst_1 (@partial_order.to_preorder.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@set.lattice_set.{u_3} (prod.{u_3 u_3} α α)))))) f → @monotone.{u_3 u_3} β (set.{u_3} (prod.{u_3 u_3} α α)) _inst_1 (@partial_order.to_preorder.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@set.lattice_set.{u_3} (prod.{u_3 u_3} α α)))))) g → @monotone.{u_3 u_3} β (set.{u_3} (prod.{u_3 u_3} α α)) _inst_1 (@partial_order.to_preorder.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.order_bot.to_partial_order.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.bounded_lattice.to_order_bot.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (@set.lattice_set.{u_3} (prod.{u_3 u_3} α α)))))) (λ (x : β), @comp_rel.{u_3} α (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : preorder.{u_3} α], @monotone.{u_3 u_3} α α _inst_1 _inst_1 (@id.{u_3+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : preorder.{u_3} α], @monotone.{u_3 u_3} α α _inst_1 _inst_1 (@id.{u_3+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : uniform_space.{u_3} α], @has_le.le.{u_3} (filter.{u_3} (prod.{u_3 u_3} α α)) (@preorder.to_has_le.{u_3} (filter.{u_3} (prod.{u_3 u_3} α α)) (@partial_order.to_preorder.{u_3} (filter.{u_3} (prod.{u_3 u_3} α α)) (@filter.partial_order.{u_3} (prod.{u_3 u_3} α α)))) (@filter.lift&#x27;.{u_3 u_3} (prod.{u_3 u_3} α α) (prod.{u_3 u_3} α α) (@uniformity.{u_3} α _inst_1) (λ (s : set.{u_3} (prod.{u_3 u_3} α α)), @comp_rel.{u_3} α s (@comp_rel.{u_3} α s s))) (@uniformity.{u_3} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) d (@uniformity.{u_3} γ _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>347  have h_pnt : ∀{a m}, m ∈ 𝓝 a → ∃c, c ∈ f &#x27;&#x27; preimage e m ∧ (c, ψ a) ∈ s ∧ (ψ a, c) ∈ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>348    from assume a m hm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>349    have nb : map f (comap e (𝓝 a)) ≠ ⊥,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → filter.{u_2} α → filter.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_3}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_3) [c : lattice.has_bot.{u_3} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>350      from map_ne_bot (h_e.dense_inducing h_dense).comap_nhds_ne_bot,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.map_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_inducing.dense_inducing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='dense_inducing.comap_nhds_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1070, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {f : filter.{u_2} α} {m : α → β}, @ne.{u_2+1} (filter.{u_2} α) f (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α))))) → @ne.{u_3+1} (filter.{u_3} β) (@filter.map.{u_2 u_3} α β m f) (@lattice.has_bot.bot.{u_3} (filter.{u_3} β) (@lattice.order_bot.to_has_bot.{u_3} (filter.{u_3} β) (@lattice.bounded_lattice.to_order_bot.{u_3} (filter.{u_3} β) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (filter.{u_3} β) (@filter.lattice.complete_lattice.{u_3} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : uniform_space.{u_2} α] [_inst_2 : uniform_space.{u_1} β] {f : α → β}, @uniform_inducing.{u_2 u_1} α β _inst_1 _inst_2 f → @dense_range.{u_2 u_1} α β (@uniform_space.to_topological_space.{u_1} β _inst_2) f → @dense_inducing.{u_2 u_1} α β (@uniform_space.to_topological_space.{u_2} α _inst_1) (@uniform_space.to_topological_space.{u_1} β _inst_2) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} [_inst_1 : topological_space.{u_2} α] [_inst_2 : topological_space.{u_1} β] {i : α → β}, @dense_inducing.{u_2 u_1} α β _inst_1 _inst_2 i → ∀ {b : β}, @ne.{u_2+1} (filter.{u_2} α) (@filter.comap.{u_2 u_1} α β i (@nhds.{u_1} β _inst_2 b)) (@lattice.has_bot.bot.{u_2} (filter.{u_2} α) (@lattice.order_bot.to_has_bot.{u_2} (filter.{u_2} α) (@lattice.bounded_lattice.to_order_bot.{u_2} (filter.{u_2} α) (@lattice.complete_lattice.to_bounded_lattice.{u_2} (filter.{u_2} α) (@filter.lattice.complete_lattice.{u_2} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>351    have (f &#x27;&#x27; preimage e m) ∩ ({c | (c, ψ a) ∈ s } ∩ {c | (ψ a, c) ∈ s }) ∈ map f (comap e (𝓝 a)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_inter.inter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 324, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 764, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3} [c : has_inter.{u_3} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → set.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_3} [c : has_inter.{u_3} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, (α → Prop) → set.{u_3} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → filter.{u_2} α → filter.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The forward map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>352      from inter_mem_sets (image_mem_map $ preimage_mem_comap $ hm)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.inter_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.image_mem_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.preimage_mem_comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 778, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 908, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_3} {f : filter.{u_3} α} {s t : set.{u_3} α}, @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) s f → @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) t f → @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) (@has_inter.inter.{u_3} (set.{u_3} α) (@set.has_inter.{u_3} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {f : filter.{u_2} α} {m : α → β} {s : set.{u_2} α}, @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) s f → @has_mem.mem.{u_3 u_3} (set.{u_3} β) (filter.{u_3} β) (@filter.has_mem.{u_3} β) (@set.image.{u_2 u_3} α β m s) (@filter.map.{u_2 u_3} α β m f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} {g : filter.{u_1} β} {m : α → β} {t : set.{u_1} β}, @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) t g → @has_mem.mem.{u_2 u_2} (set.{u_2} α) (filter.{u_2} α) (@filter.has_mem.{u_2} α) (@set.preimage.{u_2 u_1} α β m t) (@filter.comap.{u_2 u_1} α β m g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>353        (uniformly_extend_spec h_e h_dense h_f _ (inter_mem_sets (mem_nhds_right _ hs) (mem_nhds_left _ hs))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='uniformly_extend_spec'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.inter_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mem_nhds_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mem_nhds_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 331, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 124, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 290, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 284, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β] [_inst_3 : uniform_space.{u_3} γ] {e : β → α} (h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e) (h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e) {f : β → γ}, @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f → ∀ [_inst_4 : @separated.{u_3} γ _inst_3] [_inst_5 : @complete_space.{u_3} γ _inst_3] (a : α), @filter.tendsto.{u_2 u_3} β γ f (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)) (@nhds.{u_3} γ (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_3} {f : filter.{u_3} α} {s t : set.{u_3} α}, @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) s f → @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) t f → @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) (@has_inter.inter.{u_3} (set.{u_3} α) (@set.has_inter.{u_3} α) s t) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : uniform_space.{u_3} α] (y : α) {s : set.{u_3} (prod.{u_3 u_3} α α)}, @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (filter.{u_3} (prod.{u_3 u_3} α α)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} α α)) s (@uniformity.{u_3} α _inst_1) → @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) (@set_of.{u_3} α (λ (x : α), @has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} α α) (set.{u_3} (prod.{u_3 u_3} α α)) (@set.has_mem.{u_3} (prod.{u_3 u_3} α α)) (@prod.mk.{u_3 u_3} α α x y) s)) (@nhds.{u_3} α (@uniform_space.to_topological_space.{u_3} α _inst_1) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_3} [_inst_1 : uniform_space.{u_3} α] (x : α) {s : set.{u_3} (prod.{u_3 u_3} α α)}, @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} α α)) (filter.{u_3} (prod.{u_3 u_3} α α)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} α α)) s (@uniformity.{u_3} α _inst_1) → @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) (@set_of.{u_3} α (λ (y : α), @has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} α α) (set.{u_3} (prod.{u_3 u_3} α α)) (@set.has_mem.{u_3} (prod.{u_3 u_3} α α)) (@prod.mk.{u_3 u_3} α α x y) s)) (@nhds.{u_3} α (@uniform_space.to_topological_space.{u_3} α _inst_1) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>354    nonempty_of_mem_sets nb this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.nonempty_of_mem_sets'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='nb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 395, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_3} {f : filter.{u_3} α}, @ne.{u_3+1} (filter.{u_3} α) f (@lattice.has_bot.bot.{u_3} (filter.{u_3} α) (@lattice.order_bot.to_has_bot.{u_3} (filter.{u_3} α) (@lattice.bounded_lattice.to_order_bot.{u_3} (filter.{u_3} α) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (filter.{u_3} α) (@filter.lattice.complete_lattice.{u_3} α))))) → ∀ {s : set.{u_3} α}, @has_mem.mem.{u_3 u_3} (set.{u_3} α) (filter.{u_3} α) (@filter.has_mem.{u_3} α) s f → @set.nonempty.{u_3} α s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@ne.{u_3+1} (filter.{u_3} γ) (@filter.map.{u_2 u_3} β γ f (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a))) (@lattice.has_bot.bot.{u_3} (filter.{u_3} γ) (@lattice.order_bot.to_has_bot.{u_3} (filter.{u_3} γ) (@lattice.bounded_lattice.to_order_bot.{u_3} (filter.{u_3} γ) (@lattice.complete_lattice.to_bounded_lattice.{u_3} (filter.{u_3} γ) (@filter.lattice.complete_lattice.{u_3} γ)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} (set.{u_3} γ) (filter.{u_3} γ) (@filter.has_mem.{u_3} γ) (@has_inter.inter.{u_3} (set.{u_3} γ) (@set.has_inter.{u_3} γ) (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)) (@has_inter.inter.{u_3} (set.{u_3} γ) (@set.has_inter.{u_3} γ) (@set_of.{u_3} γ (λ (c : γ), @has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ c (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f a)) s)) (@set_of.{u_3} γ (λ (c : γ), @has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f a) c) s)))) (@filter.map.{u_2 u_3} β γ f (@filter.comap.{u_2 u_1} β α e (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>355  have preimage (λp:β×β, (f p.1, f p.2)) s ∈ 𝓤 β,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_2) [_inst_2 : uniform_space.{u_2} α], filter.{u_2} (prod.{u_2 u_2} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>356    from h_f hs,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h_f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>357  have preimage (λp:β×β, (f p.1, f p.2)) s ∈ comap (λx:β×β, (e x.1, e x.2)) (𝓤 α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.comap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 803, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α γ : Type u_2} [c : has_mem.{u_2 u_2} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → filter.{u_1} β → filter.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='The inverse map of a filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>358    by rwa [h_e.comap_uniformity.symm] at this,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_2+1} (filter.{u_2} (prod.{u_2 u_2} β β)) (@uniformity.{u_2} β _inst_2) (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α) (λ (x : prod.{u_2 u_2} β β), @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x))) (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
cγ : @complete_space.{u_3} γ _inst_3,
d : set.{u_3} (prod.{u_3 u_3} γ γ),
hd :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@uniformity.{u_3} γ _inst_3),
_let_match :
  @Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ))
    (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)),
       @Exists.{0}
         (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
            (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
            t
            (@uniformity.{u_3} γ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
              (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
              t
              (@uniformity.{u_3} γ _inst_3)),
            @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
              (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                 (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                    (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)))
              d)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
s : set.{u_3} (prod.{u_3 u_3} γ γ),
hs :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    s
    (@uniformity.{u_3} γ _inst_3),
hs_comp :
  @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
    (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
       (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
          (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)))
    d,
h_pnt :
  ∀ {a : α} {m : set.{u_1} α},
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m
      (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) →
    @Exists.{u_3+1} γ
      (λ (c : γ),
         and
           (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c
              (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)))
           (and
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ c
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a))
                 s)
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a)
                    c)
                 s))),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@uniformity.{u_2} β _inst_2)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
cγ : @complete_space.{u_3} γ _inst_3,
d : set.{u_3} (prod.{u_3 u_3} γ γ),
hd :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@uniformity.{u_3} γ _inst_3),
_let_match :
  @Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ))
    (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)),
       @Exists.{0}
         (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
            (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
            t
            (@uniformity.{u_3} γ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
              (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
              t
              (@uniformity.{u_3} γ _inst_3)),
            @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
              (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                 (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                    (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)))
              d)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
s : set.{u_3} (prod.{u_3 u_3} γ γ),
hs :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    s
    (@uniformity.{u_3} γ _inst_3),
hs_comp :
  @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
    (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
       (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
          (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)))
    d,
h_pnt :
  ∀ {a : α} {m : set.{u_1} α},
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m
      (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) →
    @Exists.{u_3+1} γ
      (λ (c : γ),
         and
           (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c
              (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)))
           (and
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ c
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a))
                 s)
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a)
                    c)
                 s))),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1))
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
cγ : @complete_space.{u_3} γ _inst_3,
d : set.{u_3} (prod.{u_3 u_3} γ γ),
hd :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@uniformity.{u_3} γ _inst_3),
_let_match :
  @Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ))
    (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)),
       @Exists.{0}
         (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
            (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
            t
            (@uniformity.{u_3} γ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
              (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
              t
              (@uniformity.{u_3} γ _inst_3)),
            @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
              (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                 (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                    (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)))
              d)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
s : set.{u_3} (prod.{u_3 u_3} γ γ),
hs :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    s
    (@uniformity.{u_3} γ _inst_3),
hs_comp :
  @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
    (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
       (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
          (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)))
    d,
h_pnt :
  ∀ {a : α} {m : set.{u_1} α},
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m
      (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) →
    @Exists.{u_3+1} γ
      (λ (c : γ),
         and
           (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c
              (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)))
           (and
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ c
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a))
                 s)
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a)
                    c)
                 s))),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@uniformity.{u_2} β _inst_2)
⊢ @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>359  let ⟨t, ht, ts⟩ := this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ) (λ (p : prod.{u_2 u_2} β β), @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p))) s) (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α) (λ (x : prod.{u_2 u_2} β β), @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x))) (@uniformity.{u_1} α _inst_1)) → @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ)) (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) d (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ) (λ (x : prod.{u_1 u_1} α α), @prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.fst.{u_1 u_1} α α x)) (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.snd.{u_1 u_1} α α x))) (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) t (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β)) (@set.preimage.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α) (λ (x : prod.{u_2 u_2} β β), @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x))) t) (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ) (λ (p : prod.{u_2 u_2} β β), @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p))) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β)) (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β)) (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ) (λ (p : prod.{u_2 u_2} β β), @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p))) s) (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α) (λ (x : prod.{u_2 u_2} β β), @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x))) (@uniformity.{u_1} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>360  show preimage (λp:(α×α), (ψ p.1, ψ p.2)) d ∈ 𝓤 α,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, prod.{u_1 u_1} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u_3} (prod.{u_3 u_3} γ γ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>361    from (𝓤 α).sets_of_superset (interior_mem_uniformity ht) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='interior_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 413, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (α : Type u_1) [_inst_2 : uniform_space.{u_1} α], filter.{u_1} (prod.{u_1 u_1} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} (c : filter.{u_1} α) {x y : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) x (@filter.sets.{u_1} α c) → @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) x y → @has_mem.mem.{u_1 u_1} (set.{u_1} α) (set.{u_1} (set.{u_1} α)) (@set.has_mem.{u_1} (set.{u_1} α)) y (@filter.sets.{u_1} α c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {s : set.{u_1} (prod.{u_1 u_1} α α)}, @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) s (@uniformity.{u_1} α _inst_1) → @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@interior.{u_1} (prod.{u_1 u_1} α α) (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_1} α _inst_1)) s) (@uniformity.{u_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>362    assume ⟨x₁, x₂⟩ hx_t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hx_t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='prod.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x₁ x₂) (@interior.{u_1} (prod.{u_1 u_1} α α) (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_1} α _inst_1)) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>363    have 𝓝 (x₁, x₂) ≤ principal (interior t),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, set.{u_1} α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>364      from is_open_iff_nhds.mp is_open_interior (x₁, x₂) hx_t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='is_open_iff_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_open_interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hx_t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 492, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 186, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, iff (@is_open.{u_1} α _inst_1 s) (∀ (a : α), @has_mem.mem.{u_1 u_1} α (set.{u_1} α) (@set.has_mem.{u_1} α) a s → @has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) (@nhds.{u_1} α _inst_1 a) (@filter.principal.{u_1} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, @is_open.{u_1} α _inst_1 (@interior.{u_1} α _inst_1 s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x₁ x₂) (@interior.{u_1} (prod.{u_1 u_1} α α) (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_1} α _inst_1)) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>365    have interior t ∈ filter.prod (𝓝 x₁) (𝓝 x₂),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1524, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_1}, filter.{u_1} α → filter.{u_1} β → filter.{u_1} (prod.{u_1 u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], α → filter.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Product of filters. This is the filter generated by cartesian products
 of elements of the component filters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>366      by rwa [nhds_prod_eq, le_principal_iff] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='nhds_prod_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.le_principal_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 132, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_1} β] {a : α} {b : β}, @eq.{u_1+1} (filter.{u_1} (prod.{u_1 u_1} α β)) (@nhds.{u_1} (prod.{u_1 u_1} α β) (@prod.topological_space.{u_1 u_1} α β _inst_1 _inst_2) (@prod.mk.{u_1 u_1} α β a b)) (@filter.prod.{u_1 u_1} α β (@nhds.{u_1} α _inst_1 a) (@nhds.{u_1} β _inst_2 b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {s : set.{u_1} α} {f : filter.{u_1} α}, iff (@has_le.le.{u_1} (filter.{u_1} α) (@preorder.to_has_le.{u_1} (filter.{u_1} α) (@partial_order.to_preorder.{u_1} (filter.{u_1} α) (@filter.partial_order.{u_1} α))) f (@filter.principal.{u_1} α s)) (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) s f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
cγ : @complete_space.{u_3} γ _inst_3,
d : set.{u_3} (prod.{u_3 u_3} γ γ),
hd :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@uniformity.{u_3} γ _inst_3),
_let_match :
  @Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ))
    (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)),
       @Exists.{0}
         (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
            (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
            t
            (@uniformity.{u_3} γ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
              (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
              t
              (@uniformity.{u_3} γ _inst_3)),
            @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
              (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                 (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                    (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)))
              d)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
s : set.{u_3} (prod.{u_3 u_3} γ γ),
hs :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    s
    (@uniformity.{u_3} γ _inst_3),
hs_comp :
  @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
    (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
       (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
          (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)))
    d,
h_pnt :
  ∀ {a : α} {m : set.{u_1} α},
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m
      (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) →
    @Exists.{u_3+1} γ
      (λ (c : γ),
         and
           (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c
              (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)))
           (and
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ c
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a))
                 s)
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a)
                    c)
                 s))),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@uniformity.{u_2} β _inst_2),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)),
_let_match :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@uniformity.{u_1} α _inst_1),
ts :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       t)
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s),
_x : prod.{u_1 u_1} α α,
_fun_match :
  ∀ (_a : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@interior.{u_1} (prod.{u_1 u_1} α α)
         (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
            (@uniform_space.to_topological_space.{u_1} α _inst_1))
         t) →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@set.preimage.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
         (λ (p : prod.{u_1 u_1} α α),
            @prod.mk.{u_3 u_3} γ γ
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.fst.{u_1 u_1} α α p))
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.snd.{u_1 u_1} α α p)))
         d),
x₁ x₂ : α,
hx_t :
  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@prod.mk.{u_1 u_1} α α x₁ x₂)
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t),
this :
  @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
       (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
          (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α))))
    (@nhds.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       (@prod.mk.{u_1 u_1} α α x₁ x₂))
    (@filter.principal.{u_1} (prod.{u_1 u_1} α α)
       (@interior.{u_1} (prod.{u_1 u_1} α α)
          (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
             (@uniform_space.to_topological_space.{u_1} α _inst_1))
          t))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t)
    (@filter.prod.{u_1 u_1} α α (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
cγ : @complete_space.{u_3} γ _inst_3,
d : set.{u_3} (prod.{u_3 u_3} γ γ),
hd :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@uniformity.{u_3} γ _inst_3),
_let_match :
  @Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ))
    (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)),
       @Exists.{0}
         (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
            (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
            t
            (@uniformity.{u_3} γ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
              (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
              t
              (@uniformity.{u_3} γ _inst_3)),
            @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
              (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                 (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                    (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)))
              d)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
s : set.{u_3} (prod.{u_3 u_3} γ γ),
hs :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    s
    (@uniformity.{u_3} γ _inst_3),
hs_comp :
  @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
    (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
       (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
          (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)))
    d,
h_pnt :
  ∀ {a : α} {m : set.{u_1} α},
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m
      (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) →
    @Exists.{u_3+1} γ
      (λ (c : γ),
         and
           (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c
              (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)))
           (and
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ c
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a))
                 s)
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a)
                    c)
                 s))),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@uniformity.{u_2} β _inst_2),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)),
_let_match :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@uniformity.{u_1} α _inst_1),
ts :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       t)
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s),
_x : prod.{u_1 u_1} α α,
_fun_match :
  ∀ (_a : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@interior.{u_1} (prod.{u_1 u_1} α α)
         (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
            (@uniform_space.to_topological_space.{u_1} α _inst_1))
         t) →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@set.preimage.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
         (λ (p : prod.{u_1 u_1} α α),
            @prod.mk.{u_3 u_3} γ γ
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.fst.{u_1 u_1} α α p))
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.snd.{u_1 u_1} α α p)))
         d),
x₁ x₂ : α,
hx_t :
  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@prod.mk.{u_1 u_1} α α x₁ x₂)
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t),
this :
  @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
       (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
          (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α))))
    (@filter.prod.{u_1 u_1} α α (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂))
    (@filter.principal.{u_1} (prod.{u_1 u_1} α α)
       (@interior.{u_1} (prod.{u_1 u_1} α α)
          (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
             (@uniform_space.to_topological_space.{u_1} α _inst_1))
          t))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t)
    (@filter.prod.{u_1 u_1} α α (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
cγ : @complete_space.{u_3} γ _inst_3,
d : set.{u_3} (prod.{u_3 u_3} γ γ),
hd :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@uniformity.{u_3} γ _inst_3),
_let_match :
  @Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ))
    (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)),
       @Exists.{0}
         (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
            (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
            t
            (@uniformity.{u_3} γ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
              (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
              t
              (@uniformity.{u_3} γ _inst_3)),
            @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
              (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                 (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                    (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)))
              d)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
s : set.{u_3} (prod.{u_3 u_3} γ γ),
hs :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    s
    (@uniformity.{u_3} γ _inst_3),
hs_comp :
  @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
    (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
       (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
          (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)))
    d,
h_pnt :
  ∀ {a : α} {m : set.{u_1} α},
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m
      (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) →
    @Exists.{u_3+1} γ
      (λ (c : γ),
         and
           (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c
              (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)))
           (and
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ c
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a))
                 s)
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a)
                    c)
                 s))),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@uniformity.{u_2} β _inst_2),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)),
_let_match :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@uniformity.{u_1} α _inst_1),
ts :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       t)
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s),
_x : prod.{u_1 u_1} α α,
_fun_match :
  ∀ (_a : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@interior.{u_1} (prod.{u_1 u_1} α α)
         (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
            (@uniform_space.to_topological_space.{u_1} α _inst_1))
         t) →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@set.preimage.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
         (λ (p : prod.{u_1 u_1} α α),
            @prod.mk.{u_3 u_3} γ γ
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.fst.{u_1 u_1} α α p))
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.snd.{u_1 u_1} α α p)))
         d),
x₁ x₂ : α,
hx_t :
  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@prod.mk.{u_1 u_1} α α x₁ x₂)
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t),
this :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t)
    (@filter.prod.{u_1 u_1} α α (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t)
    (@filter.prod.{u_1 u_1} α α (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
γ : Type u_3,
_inst_1 : uniform_space.{u_1} α,
_inst_2 : uniform_space.{u_2} β,
_inst_3 : uniform_space.{u_3} γ,
e : β → α,
h_e : @uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e,
h_dense : @dense_range.{u_2 u_1} β α (@uniform_space.to_topological_space.{u_1} α _inst_1) e,
f : β → γ,
h_f : @uniform_continuous.{u_2 u_3} β γ _inst_2 _inst_3 f,
_inst_4 : @separated.{u_3} γ _inst_3,
cγ : @complete_space.{u_3} γ _inst_3,
d : set.{u_3} (prod.{u_3 u_3} γ γ),
hd :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@uniformity.{u_3} γ _inst_3),
_let_match :
  @Exists.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ))
    (λ (t : set.{u_3} (prod.{u_3 u_3} γ γ)),
       @Exists.{0}
         (@has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
            (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
            t
            (@uniformity.{u_3} γ _inst_3))
         (λ
          (H :
            @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
              (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
              t
              (@uniformity.{u_3} γ _inst_3)),
            @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
              (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                 (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)
                    (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) t)))
              d)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
s : set.{u_3} (prod.{u_3 u_3} γ γ),
hs :
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    s
    (@uniformity.{u_3} γ _inst_3),
hs_comp :
  @has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ))
    (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
       (@comp_rel.{u_3} γ (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)
          (@id.{u_3+1} (set.{u_3} (prod.{u_3 u_3} γ γ)) s)))
    d,
h_pnt :
  ∀ {a : α} {m : set.{u_1} α},
    @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m
      (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) →
    @Exists.{u_3+1} γ
      (λ (c : γ),
         and
           (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c
              (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m)))
           (and
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ c
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a))
                 s)
              (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ))
                 (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
                 (@prod.mk.{u_3 u_3} γ γ
                    (@dense_inducing.extend.{u_2 u_1 u_3} β α γ
                       (@uniform_space.to_topological_space.{u_2} β _inst_2)
                       (@uniform_space.to_topological_space.{u_1} α _inst_1)
                       e
                       (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                       (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                       f
                       a)
                    c)
                 s))),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@uniformity.{u_2} β _inst_2),
this :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)),
_let_match :
  @has_mem.mem.{u_2 u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (filter.{u_2} (prod.{u_2 u_2} β β))
    (@filter.has_mem.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s)
    (@filter.comap.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       (@uniformity.{u_1} α _inst_1)) →
  @has_mem.mem.{u_3 u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (filter.{u_3} (prod.{u_3 u_3} γ γ))
    (@filter.has_mem.{u_3} (prod.{u_3 u_3} γ γ))
    d
    (@filter.map.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
       (λ (x : prod.{u_1 u_1} α α),
          @prod.mk.{u_3 u_3} γ γ
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.fst.{u_1 u_1} α α x))
            (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
               (@uniform_space.to_topological_space.{u_1} α _inst_1)
               e
               (@uniform_space.to_topological_space.{u_3} γ _inst_3)
               (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
               f
               (@prod.snd.{u_1 u_1} α α x)))
       (@uniformity.{u_1} α _inst_1)),
t : set.{u_1} (prod.{u_1 u_1} α α),
ht :
  @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    t
    (@uniformity.{u_1} α _inst_1),
ts :
  @has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β))
    (@set.preimage.{u_2 u_1} (prod.{u_2 u_2} β β) (prod.{u_1 u_1} α α)
       (λ (x : prod.{u_2 u_2} β β),
          @prod.mk.{u_1 u_1} α α (e (@prod.fst.{u_2 u_2} β β x)) (e (@prod.snd.{u_2 u_2} β β x)))
       t)
    (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ)
       (λ (p : prod.{u_2 u_2} β β),
          @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p)))
       s),
_x : prod.{u_1 u_1} α α,
_fun_match :
  ∀ (_a : prod.{u_1 u_1} α α),
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@interior.{u_1} (prod.{u_1 u_1} α α)
         (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
            (@uniform_space.to_topological_space.{u_1} α _inst_1))
         t) →
    @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
      (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
      _a
      (@set.preimage.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ)
         (λ (p : prod.{u_1 u_1} α α),
            @prod.mk.{u_3 u_3} γ γ
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.fst.{u_1 u_1} α α p))
              (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2)
                 (@uniform_space.to_topological_space.{u_1} α _inst_1)
                 e
                 (@uniform_space.to_topological_space.{u_3} γ _inst_3)
                 (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense)
                 f
                 (@prod.snd.{u_1 u_1} α α p)))
         d),
x₁ x₂ : α,
hx_t :
  @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α))
    (@set.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@prod.mk.{u_1 u_1} α α x₁ x₂)
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t),
this :
  @has_le.le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
    (@preorder.to_has_le.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
       (@partial_order.to_preorder.{u_1} (filter.{u_1} (prod.{u_1 u_1} α α))
          (@filter.partial_order.{u_1} (prod.{u_1 u_1} α α))))
    (@nhds.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       (@prod.mk.{u_1 u_1} α α x₁ x₂))
    (@filter.principal.{u_1} (prod.{u_1 u_1} α α)
       (@interior.{u_1} (prod.{u_1 u_1} α α)
          (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
             (@uniform_space.to_topological_space.{u_1} α _inst_1))
          t))
⊢ @has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α))
    (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α))
    (@interior.{u_1} (prod.{u_1 u_1} α α)
       (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1)
          (@uniform_space.to_topological_space.{u_1} α _inst_1))
       t)
    (@filter.prod.{u_1 u_1} α α (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)
       (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>367    let ⟨m₁, hm₁, m₂, hm₂, (hm : set.prod m₁ m₂ ⊆ interior t)⟩ := mem_prod_iff.mp this in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hm₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hm₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.mem_prod_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1531, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u_1+1} (set.{u_1} α) (λ (t₁ : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t₁ (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t₁ (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)), @Exists.{u_1+1} (set.{u_1} α) (λ (t₂ : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t₂ (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂)) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t₂ (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂)), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@set.prod.{u_1 u_1} α α t₁ t₂) (@interior.{u_1} (prod.{u_1 u_1} α α) (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_1} α _inst_1)) t))))) → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x₁ x₂) (@set.preimage.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ) (λ (p : prod.{u_1 u_1} α α), @prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.fst.{u_1 u_1} α α p)) (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.snd.{u_1 u_1} α α p))) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m₁ (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m₂ (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α α)) (@set.prod.{u_1 u_1} α α m₁ m₂) (@interior.{u_1} (prod.{u_1 u_1} α α) (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_1} α _inst_1)) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α β : Type u_1}, set.{u_1} α → set.{u_1} β → set.{u_1} (prod.{u_1 u_1} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [c : has_subset.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α β : Type u_1} {s : set.{u_1} (prod.{u_1 u_1} α β)} {f : filter.{u_1} α} {g : filter.{u_1} β}, iff (@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α β)) (filter.{u_1} (prod.{u_1 u_1} α β)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α β)) s (@filter.prod.{u_1 u_1} α β f g)) (@Exists.{u_1+1} (set.{u_1} α) (λ (t₁ : set.{u_1} α), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t₁ f) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) t₁ f), @Exists.{u_1+1} (set.{u_1} β) (λ (t₂ : set.{u_1} β), @Exists.{0} (@has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) t₂ g) (λ (H : @has_mem.mem.{u_1 u_1} (set.{u_1} β) (filter.{u_1} β) (@filter.has_mem.{u_1} β) t₂ g), @has_subset.subset.{u_1} (set.{u_1} (prod.{u_1 u_1} α β)) (@set.has_subset.{u_1} (prod.{u_1 u_1} α β)) (@set.prod.{u_1 u_1} α β t₁ t₂) s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} (set.{u_1} (prod.{u_1 u_1} α α)) (filter.{u_1} (prod.{u_1 u_1} α α)) (@filter.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@interior.{u_1} (prod.{u_1 u_1} α α) (@prod.topological_space.{u_1 u_1} α α (@uniform_space.to_topological_space.{u_1} α _inst_1) (@uniform_space.to_topological_space.{u_1} α _inst_1)) t) (@filter.prod.{u_1 u_1} α α (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₁) (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) x₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>368    let ⟨a, ha₁, _, ha₂⟩ := h_pnt hm₁ in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ha₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='ha₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h_pnt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u_3+1} γ (λ (c : γ), and (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m₁))) (and (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ c (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f x₁)) s) (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f x₁) c) s))) → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x₁ x₂) (@set.preimage.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ) (λ (p : prod.{u_1 u_1} α α), @prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.fst.{u_1 u_1} α α p)) (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.snd.{u_1 u_1} α α p))) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) a (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m₁))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f x₁) a) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {a : α} {m : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) → @Exists.{u_3+1} γ (λ (c : γ), and (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m))) (and (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ c (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f a)) s) (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f a) c) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>369    let ⟨b, hb₁, hb₂, _⟩ := h_pnt hm₂ in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hb₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='h_pnt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@Exists.{u_3+1} γ (λ (c : γ), and (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m₂))) (and (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ c (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f x₂)) s) (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f x₂) c) s))) → @has_mem.mem.{u_1 u_1} (prod.{u_1 u_1} α α) (set.{u_1} (prod.{u_1 u_1} α α)) (@set.has_mem.{u_1} (prod.{u_1 u_1} α α)) (@prod.mk.{u_1 u_1} α α x₁ x₂) (@set.preimage.{u_1 u_3} (prod.{u_1 u_1} α α) (prod.{u_3 u_3} γ γ) (λ (p : prod.{u_1 u_1} α α), @prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.fst.{u_1 u_1} α α p)) (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f (@prod.snd.{u_1 u_1} α α p))) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) b (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ b (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f x₂)) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {a : α} {m : set.{u_1} α}, @has_mem.mem.{u_1 u_1} (set.{u_1} α) (filter.{u_1} α) (@filter.has_mem.{u_1} α) m (@nhds.{u_1} α (@uniform_space.to_topological_space.{u_1} α _inst_1) a) → @Exists.{u_3+1} γ (λ (c : γ), and (@has_mem.mem.{u_3 u_3} γ (set.{u_3} γ) (@set.has_mem.{u_3} γ) c (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m))) (and (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ c (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f a)) s) (@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ (@dense_inducing.extend.{u_2 u_1 u_3} β α γ (@uniform_space.to_topological_space.{u_2} β _inst_2) (@uniform_space.to_topological_space.{u_1} α _inst_1) e (@uniform_space.to_topological_space.{u_3} γ _inst_3) (@uniform_inducing.dense_inducing.{u_2 u_1} β α _inst_2 _inst_1 e h_e h_dense) f a) c) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>370    have set.prod (preimage e m₁) (preimage e m₂) ⊆ preimage (λp:(β×β), (f p.1, f p.2)) s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u_2}, set.{u_2} α → set.{u_2} β → set.{u_2} (prod.{u_2 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_2} [c : has_subset.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>371      from calc _ ⊆ preimage (λp:(β×β), (e p.1, e p.2)) (interior t) : preimage_mono hm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='interior'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.preimage_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 840, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : topological_space.{u_1} α], set.{u_1} α → set.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} {f : α → β} {s t : set.{u_1} β}, @has_subset.subset.{u_1} (set.{u_1} β) (@set.has_subset.{u_1} β) s t → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@set.preimage.{u_2 u_1} α β f s) (@set.preimage.{u_2 u_1} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The interior of a set `s` is the largest open subset of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>372      ... ⊆ preimage (λp:(β×β), (e p.1, e p.2)) t : preimage_mono interior_subset</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.preimage_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='interior_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 840, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_1}, α → β → prod.{u_1 u_1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_1} {f : α → β} {s t : set.{u_1} β}, @has_subset.subset.{u_1} (set.{u_1} β) (@set.has_subset.{u_1} β) s t → @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) (@set.preimage.{u_2 u_1} α β f s) (@set.preimage.{u_2 u_1} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : topological_space.{u_1} α] {s : set.{u_1} α}, @has_subset.subset.{u_1} (set.{u_1} α) (@set.has_subset.{u_1} α) (@interior.{u_1} α _inst_1 s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>373      ... ⊆ preimage (λp:(β×β), (f p.1, f p.2)) s : ts,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>374    have set.prod (f &#x27;&#x27; preimage e m₁) (f &#x27;&#x27; preimage e m₂) ⊆ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u_3}, set.{u_3} α → set.{u_3} β → set.{u_3} (prod.{u_3 u_3} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_3} [c : has_subset.{u_3} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>375      from calc set.prod (f &#x27;&#x27; preimage e m₁) (f &#x27;&#x27; preimage e m₂) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π {α β : Type u_3}, set.{u_3} α → set.{u_3} β → set.{u_3} (prod.{u_3 u_3} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>376        (λp:(β×β), (f p.1, f p.2)) &#x27;&#x27; (set.prod (preimage e m₁) (preimage e m₂)) : prod_image_image_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.prod_image_image_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1460, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u_2}, set.{u_2} α → set.{u_2} β → set.{u_2} (prod.{u_2 u_2} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_1}, (α → β) → set.{u_1} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α β : Type u_2} {γ δ : Type u_3} {s : set.{u_2} α} {t : set.{u_2} β} {m₁ : α → γ} {m₂ : β → δ}, @eq.{(max (u_3+1) 1)} (set.{u_3} (prod.{u_3 u_3} γ δ)) (@set.prod.{u_3 u_3} γ δ (@set.image.{u_2 u_3} α γ m₁ s) (@set.image.{u_2 u_3} β δ m₂ t)) (@set.image.{u_2 u_3} (prod.{u_2 u_2} α β) (prod.{u_3 u_3} γ δ) (λ (p : prod.{u_2 u_2} α β), @prod.mk.{u_3 u_3} γ δ (m₁ (@prod.fst.{u_2 u_2} α β p)) (m₂ (@prod.snd.{u_2 u_2} α β p))) (@set.prod.{u_2 u_2} α β s t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>377      ... ⊆ (λp:(β×β), (f p.1, f p.2)) &#x27;&#x27; preimage (λp:(β×β), (f p.1, f p.2)) s : mono_image this</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.mono_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 829, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 918, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_2} α → set.{u_3} β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} {β : Type u_3}, (α → β) → set.{u_3} β → set.{u_2} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2 → Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='β → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u_2 u_2} β β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_2}, prod.{u_2 u_2} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {f : α → β} {s t : set.{u_2} α}, @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s t → @has_subset.subset.{u_3} (set.{u_3} β) (@set.has_subset.{u_3} β) (@set.image.{u_2 u_3} α β f s) (@set.image.{u_2 u_3} α β f t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{u_2} (set.{u_2} (prod.{u_2 u_2} β β)) (@set.has_subset.{u_2} (prod.{u_2 u_2} β β)) (@set.prod.{u_2 u_2} β β (@set.preimage.{u_2 u_1} β α e m₁) (@set.preimage.{u_2 u_1} β α e m₂)) (@set.preimage.{u_2 u_3} (prod.{u_2 u_2} β β) (prod.{u_3 u_3} γ γ) (λ (p : prod.{u_2 u_2} β β), @prod.mk.{u_3 u_3} γ γ (f (@prod.fst.{u_2 u_2} β β p)) (f (@prod.snd.{u_2 u_2} β β p))) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='The preimage of `s : set β` by `f : α → β`, written `f ⁻¹&#x27; s`,
 is the set of `x : α` such that `f x ∈ s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>378      ... ⊆ s : image_subset_iff.mpr $ subset.refl _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='set.image_subset_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.subset.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1063, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {α : Type u_2} {β : Type u_3} {s : set.{u_2} α} {t : set.{u_3} β} {f : α → β}, iff (@has_subset.subset.{u_3} (set.{u_3} β) (@set.has_subset.{u_3} β) (@set.image.{u_2 u_3} α β f s) t) (@has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) s (@set.preimage.{u_2 u_3} α β f t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_2} (a : set.{u_2} α), @has_subset.subset.{u_2} (set.{u_2} α) (@set.has_subset.{u_2} α) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='image and preimage are a Galois connection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>379    have (a, b) ∈ s, from @this (a, b) ⟨ha₁, hb₁⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_subset.subset.{u_3} (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_subset.{u_3} (prod.{u_3 u_3} γ γ)) (@set.prod.{u_3 u_3} γ γ (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m₁)) (@set.image.{u_2 u_3} β γ f (@set.preimage.{u_2 u_1} β α e m₂))) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>380    hs_comp $ show (ψ x₁, ψ x₂) ∈ comp_rel s (comp_rel s s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h_e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='comp_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/dense_embedding.lean&#x27;, &#x27;line&#x27;: 86, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π {α β : Type u_3}, α → β → prod.{u_3 u_3} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@uniform_inducing.{u_2 u_1} β α _inst_2 _inst_1 e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α γ : Type u_3} [c : has_mem.{u_3 u_3} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_3}, set.{u_3} (prod.{u_3 u_3} α α) → set.{u_3} (prod.{u_3 u_3} α α) → set.{u_3} (prod.{u_3 u_3} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_3}, set.{u_3} (prod.{u_3 u_3} α α) → set.{u_3} (prod.{u_3 u_3} α α) → set.{u_3} (prod.{u_3 u_3} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='If `i : α → β` is a dense inducing, then any function `f : α → γ` &quot;extends&quot;
 to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a
 continuous extension, then `g` is the unique such extension. In general,
 `g` might not be continuous or even extend `f`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The composition of relations'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>381      from ⟨a, ha₂, ⟨b, this, hb₂⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='@has_mem.mem.{u_3 u_3} (prod.{u_3 u_3} γ γ) (set.{u_3} (prod.{u_3 u_3} γ γ)) (@set.has_mem.{u_3} (prod.{u_3 u_3} γ γ)) (@prod.mk.{u_3 u_3} γ γ a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>382  end uniform_extension</code></pre>
</body>