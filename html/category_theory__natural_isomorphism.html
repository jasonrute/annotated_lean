<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Tim Baumann, Stephen Morgan, Scott Morrison, Floris van Doorn</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.functor_category</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.isomorphism</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  universes v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  open nat_trans</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  /-- The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  @[simp, reducible] def iso.app {C : Type u₁} [category.{v₁} C] {D : Type u₂} [category.{v₂} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Type u₁ → Type (max u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u₂ → Type (max u₂ (v₂+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='reducible'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18    {F G : C ⥤ D} (α : F ≅ G) (X : C) : F.obj X ≅ G.obj X :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  { hom := α.hom.app X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20    inv := α.inv.app X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21    hom_inv_id&#x27; := begin rw [← comp_app, iso.hom_inv_id], refl end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X X) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X Y X (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
_inst_1 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
_inst_2 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
_inst_1 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
_inst_2 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F F
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2))
          F
          G
          F
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α)
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
_inst_1 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
_inst_2 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F F
       (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2))
          F)
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22    inv_hom_id&#x27; := begin rw [← comp_app, iso.inv_hom_id], refl end }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.inv_hom_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y Y) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y X Y (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
_inst_1 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
_inst_2 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
_inst_1 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
_inst_2 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G G
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2))
          G
          F
          G
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α)
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
_inst_1 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
_inst_2 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G G
       (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2))
          G)
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  namespace nat_iso</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  open category_theory.category category_theory.functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  variables {C : Type u₁} [𝒞 : category.{v₁} C] {D : Type u₂} [𝒟 : category.{v₂} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    {E : Type u₃} [ℰ : category.{v₃} E]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  @[simp] lemma trans_app {F G H : C ⥤ D} (α : F ≅ G) (β : G ≅ H) (X : C) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    (α ≪≫ β).app X = α.app X ≪≫ β.app X := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [𝒞 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y Z : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C 𝒞 X Y → @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C 𝒞 Y Z → @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C 𝒞 X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) G H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G → Π (X : C), @category_theory.iso.{v₂ u₂} D _inst_2 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G → Π (X : C), @category_theory.iso.{v₂ u₂} D _inst_2 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {X Y Z : C}, @category_theory.iso.{v₂ u₂} C 𝒞 X Y → @category_theory.iso.{v₂ u₂} C 𝒞 Y Z → @category_theory.iso.{v₂ u₂} C 𝒞 X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) G H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G → Π (X : C), @category_theory.iso.{v₂ u₂} D _inst_2 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₂} {a : α}, @eq.{v₂+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  @[simp] lemma app_hom {F G : C ⥤ D} (α : F ≅ G) (X : C) : (α.app X).hom = α.hom.app X := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G → Π (X : C), @category_theory.iso.{v₂ u₂} D _inst_2 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₂} {a : α}, @eq.{v₂+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  @[simp] lemma app_inv {F G : C ⥤ D} (α : F ≅ G) (X : C) : (α.app X).inv = α.inv.app X := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G → Π (X : C), @category_theory.iso.{v₂ u₂} D _inst_2 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type v₂} {a : α}, @eq.{v₂+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  @[simp] lemma hom_inv_id_app {F G : C ⥤ D} (α : F ≅ G) (X : C) : α.hom.app X ≫ α.inv.app X = 𝟙 (F.obj X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  congr_fun (congr_arg app α.hom_inv_id) X</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u₁} {β : α → Type v₂} {f g : Π (x : α), β x}, @eq.{(max (u₁+1) (v₂+1))} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v₂+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u₁ v₂)} {β : Type (max u₁ v₂)} {a₁ a₂ : α} (f : α → β), @eq.{(max u₁ v₂)+1} α a₁ a₂ → @eq.{(max (u₁+1) (v₂+1))} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X X) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X Y X (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  @[simp] lemma inv_hom_id_app {F G : C ⥤ D} (α : F ≅ G) (X : C) : α.inv.app X ≫ α.hom.app X = 𝟙 (G.obj X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  congr_fun (congr_arg app α.inv_hom_id) X</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv_hom_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u₁} {β : α → Type v₂} {f g : Π (x : α), β x}, @eq.{(max (u₁+1) (v₂+1))} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v₂+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type (max u₁ v₂)} {β : Type (max u₁ v₂)} {a₁ a₂ : α} (f : α → β), @eq.{(max u₁ v₂)+1} α a₁ a₂ → @eq.{(max (u₁+1) (v₂+1))} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y Y) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y X Y (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  variables {F G : C ⥤ D}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  instance hom_app_is_iso (α : F ≅ G) (X : C) : is_iso (α.hom.app X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  { inv := α.inv.app X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    hom_inv_id&#x27; := begin rw [←comp_app, iso.hom_inv_id, ←id_app] end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.id_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X X) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X Y X (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F) X) (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          F
          G
          F
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F
       (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          F)
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    inv_hom_id&#x27; := begin rw [←comp_app, iso.inv_hom_id, ←id_app] end }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.inv_hom_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.id_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y Y) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y X Y (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F) X) (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G G
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          G
          F
          G
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G G
       (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          G)
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  instance inv_app_is_iso (α : F ≅ G) (X : C) : is_iso (α.inv.app X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  { inv := α.hom.app X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    hom_inv_id&#x27; := begin rw [←comp_app, iso.inv_hom_id, ←id_app] end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.inv_hom_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.id_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y Y) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y X Y (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F) X) (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G G
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          G
          F
          G
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G G
       (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          G)
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    inv_hom_id&#x27; := begin rw [←comp_app, iso.hom_inv_id, ←id_app] end }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.id_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C} (c : @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X X) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X Y X (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c) (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y c)) (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F) X) (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          F
          G
          F
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F
       (@category_theory.category_struct.id.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          F)
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  @[simp] lemma hom_app_inv_app_id (α : F ≅ G) (X : C) : α.hom.app X ≫ α.inv.app X = 𝟙 _ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    rw ←comp_app, simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          F
          G
          F
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  @[simp] lemma inv_app_hom_app_id (α : F ≅ G) (X : C) : α.inv.app X ≫ α.hom.app X = 𝟙 _ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    rw ←comp_app, simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
X : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G G
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          G
          F
          G
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α))
       X)
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  variables {X Y : C}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  @[simp] lemma naturality_1 (α : F ≅ G) (f : X ⟶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    (α.inv.app X) ≫ (F.map f) ≫ (α.hom.app Y) = G.map f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  begin erw [naturality, ←category.assoc, is_iso.hom_inv_id, category.id_comp] end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 168, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {X Y : C} (f : @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y) [_inst_1 : @category_theory.is_iso.{v₂ u₂} C 𝒞 X Y f], @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X X) (@category_theory.category_struct.comp.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞) X Y X f (@category_theory.is_iso.inv.{v₂ u₂} C 𝒞 X Y f _inst_1)) (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X X Y (@category_theory.category_struct.id.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             Y)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             X)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
          (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             Y)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  @[simp] lemma naturality_2 (α : F ≅ G) (f : X ⟶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70    (α.hom.app X) ≫ (G.map f) ≫ (α.inv.app Y) = F.map f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  begin erw [naturality, ←category.assoc, is_iso.hom_inv_id, category.id_comp] end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 168, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {X Y : C} (f : @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y) [_inst_1 : @category_theory.is_iso.{v₂ u₂} C 𝒞 X Y f], @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X X) (@category_theory.category_struct.comp.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞) X Y X f (@category_theory.is_iso.inv.{v₂ u₂} C 𝒞 X Y f _inst_1)) (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X X Y (@category_theory.category_struct.id.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             Y)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             X)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
X Y : C,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
          (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             F
             G
             α)
          X)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G F
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             Y)))
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  def is_iso_of_is_iso_app (α : F ⟶ G) [∀ X : C, is_iso (α.app X)] : is_iso α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ v₂ u₁ u₂)} [c : category_theory.has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj], obj → obj → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  { inv :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    { app := λ X, inv (α.app X),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y) [c : @category_theory.is_iso.{v u} C 𝒞 X Y f], @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76      naturality&#x27; := λ X Y f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77       begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    F
    G,
_inst_1 :
  Π (X : C),
    @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
      (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78         have h := congr_arg (λ f, inv (α.app X) ≫ (f ≫ inv (α.app Y))) (α.naturality f).symm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.is_iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v₂} {a₁ a₂ : α} (f : α → β), @eq.{v₂+1} α a₁ a₂ → @eq.{v₂+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {X Y : C} (f : @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y) [c : @category_theory.is_iso.{v₂ u₂} C 𝒞 X Y f], @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    F
    G,
_inst_1 :
  Π (X : C),
    @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
      (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    F
    G,
_inst_1 :
  Π (X : C),
    @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
      (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
h :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)),
        @category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
             (_inst_1 X))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
             f
             (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
                (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
                (_inst_1 Y))))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)),
        @category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
             (_inst_1 X))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
             f
             (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
                (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
                (_inst_1 Y))))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79         simp only [is_iso.inv_hom_id_assoc, is_iso.hom_inv_id, assoc, comp_id, cancel_mono] at h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.is_iso.inv_hom_id_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.cancel_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 177, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 168, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {X Y Z : C} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X Y) [_inst_1 : @category_theory.is_iso.{?l_2 ?l_1} C 𝒞 X Y f] (g : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) Y Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) Y X Z (@category_theory.is_iso.inv.{?l_2 ?l_1} C 𝒞 X Y f _inst_1) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) X Y Z f g)) g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {X Y : C} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X Y) [_inst_1 : @category_theory.is_iso.{?l_2 ?l_1} C 𝒞 X Y f], @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X X) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) X Y X f (@category_theory.is_iso.inv.{?l_2 ?l_1} C 𝒞 X Y f _inst_1)) (@category_theory.category_struct.id.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W X) (g : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (h : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) Y Z), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) W Z) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W Y Z (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) W X Z f (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X Y Y f (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type ?l_1} [𝒞 : category_theory.category.{?l_2 ?l_1} C] {X Y Z : C} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) X Y) [_inst_1 : @category_theory.mono.{?l_2 ?l_1} C 𝒞 X Y f] {g h : @category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) Z X}, iff (@eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) Z Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) Z X Y g f) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) Z X Y h f)) (@eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) Z X) g h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    F
    G,
_inst_1 :
  Π (X : C),
    @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
      (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
h :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)),
        @category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
             (_inst_1 X))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
             f
             (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
                (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
                (_inst_1 Y))))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)),
        @category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
             (_inst_1 X))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
             f
             (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
                (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
                (_inst_1 Y))))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    F
    G,
_inst_1 :
  Π (X : C),
    @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
      (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
h :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80         exact h</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f) (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y) (_inst_1 Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (_inst_1 X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    F
    G,
_inst_1 :
  Π (X : C),
    @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
      (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
h :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81       end } }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    F
    G,
_inst_1 :
  Π (X : C),
    @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
      (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X),
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
h :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α Y)
          (_inst_1 Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
       (@category_theory.is_iso.inv.{v₂ u₂} D 𝒟
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)
          (_inst_1 X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  instance is_iso_of_is_iso_app&#x27; (α : F ⟶ G) [H : ∀ X : C, is_iso (nat_trans.app α X)] : is_iso α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ v₂ u₁ u₂)} [c : category_theory.has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj], obj → obj → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  @nat_iso.is_iso_of_is_iso_app _ _ _ _ _ _ α H</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_iso.is_iso_of_is_iso_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) [_inst_1 : Π (X : C), @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)], @category_theory.is_iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C), @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  -- TODO can we make this an instance?</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  def is_iso_app_of_is_iso (α : F ⟶ G) [is_iso α] (X) : is_iso (α.app X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ v₂ u₁ u₂)} [c : category_theory.has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj], obj → obj → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [𝒞 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C 𝒞)) X Y → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  { inv := (inv α).app X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.is_iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y) [c : @category_theory.is_iso.{v u} C 𝒞 X Y f], @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    hom_inv_id&#x27; := congr_fun (congr_arg nat_trans.app (is_iso.hom_inv_id α)) X,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso.hom_inv_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 168, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f g : Π (x : α), β x}, @eq.{(imax u v)} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), @eq.{u} α a₁ a₂ → @eq.{v} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y) [_inst_1 : @category_theory.is_iso.{v u} C 𝒞 X Y f], @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X X) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X Y X f (@category_theory.is_iso.inv.{v u} C 𝒞 X Y f _inst_1)) (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    inv_hom_id&#x27; := congr_fun (congr_arg nat_trans.app (is_iso.inv_hom_id α)) X }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.is_iso.inv_hom_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {α : Sort u} {β : α → Sort v} {f g : Π (x : α), β x}, @eq.{(imax u v)} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), @eq.{u} α a₁ a₂ → @eq.{v} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y) [_inst_1 : @category_theory.is_iso.{v u} C 𝒞 X Y f], @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y Y) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) Y X Y (@category_theory.is_iso.inv.{v u} C 𝒞 X Y f _inst_1) f) (@category_theory.category_struct.id.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  def of_components (app : ∀ X : C, (F.obj X) ≅ (G.obj X))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    (naturality : ∀ {X Y : C} (f : X ⟶ Y), (F.map f) ≫ ((app Y).hom) = ((app X).hom) ≫ (G.map f)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94    F ≅ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  as_iso { app := λ X, (app X).hom }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.as_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C} (f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y) [h : @category_theory.is_iso.{v u} C 𝒞 X Y f], @category_theory.iso.{v u} C 𝒞 X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  @[simp] lemma of_components.app (app&#x27; : ∀ X : C, (F.obj X) ≅ (G.obj X)) (naturality) (X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    (of_components app&#x27; naturality).app X = app&#x27; X :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='app&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='app&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 17, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (app&#x27; Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (app&#x27; X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) F G → Π (X : C), @category_theory.iso.{v₂ u₂} D _inst_2 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  by tidy</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
app&#x27; :
  Π (X : C),
    @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X),
naturality :
  ∀ {X Y : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
         (@category_theory.iso.hom.{v₂ u₂} D 𝒟
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
            (app&#x27; Y)))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)
         (@category_theory.iso.hom.{v₂ u₂} D 𝒟
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)
            (app&#x27; X))
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f)),
X : C
⊢ @eq.{v₂+1}
    (@category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X))
    (@category_theory.iso.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
       (@category_theory.nat_iso.of_components.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G app&#x27; naturality)
       X)
    (app&#x27; X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  @[simp] lemma of_components.hom_app (app : ∀ X : C, (F.obj X) ≅ (G.obj X)) (naturality) (X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    (of_components app naturality).hom.app X = (app X).hom := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v₂} {a : α}, @eq.{v₂+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  @[simp] lemma of_components.inv_app (app : ∀ X : C, (F.obj X) ≅ (G.obj X)) (naturality) (X) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C], C → C → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    (of_components app naturality).inv.app X = (app X).inv := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {X Y : C}, @category_theory.iso.{v₂ u₂} C _inst_1 X Y → @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v₂} {a : α}, @eq.{v₂+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  include ℰ</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  def hcomp {F G : C ⥤ D} {H I : D ⥤ E} (α : F ≅ G) (β : H ≅ I) : F ⋙ H ≅ G ⋙ I :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₂ v₃ u₂ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C], C → C → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₂ v₃ u₂ u₃)} [_inst_1 : category_theory.category.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} C], C → C → Type (max u₂ v₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₃ u₁ u₃)} [_inst_1 : category_theory.category.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} C], C → C → Type (max u₁ v₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ @category_theory.iso.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
    (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    refine ⟨α.hom ◫ β.hom, α.inv ◫ β.inv, _, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.hcomp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G → @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) H I → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type (max v₂ v₃ u₂ u₃)} [_inst_1 : category_theory.category.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} C] {X Y : C}, @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} C (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} C (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`hcomp α β` is the horizontal composition of natural transformations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ @category_theory.iso.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
    (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
    (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ auto_param.{0}
    (@eq.{(max u₁ v₃)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
                (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
                (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H))
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ auto_param.{0}
    (@eq.{(max u₁ v₃)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
                (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
                (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I))
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    { ext, rw [←nat_trans.exchange], simp, refl },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.nat_trans.exchange'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {I J K : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (γ : @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) I J) (δ : @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) J K), @eq.{(max u₁ v₃)+1} (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F I) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H K)) (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H I K (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) (@category_theory.category_struct.comp.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)) I J K γ δ)) (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F I) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G J) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H K) (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G I J α γ) (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G H J K β δ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ auto_param.{0}
    (@eq.{(max u₁ v₃)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
                (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
                (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H))
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ auto_param.{0}
    (@eq.{(max u₁ v₃)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
                (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
                (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I))
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ auto_param.{0}
    (@eq.{(max u₁ v₃)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
                (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
                (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H))
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I,
x : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          x)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          x))
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       x)
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I,
x : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          x)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          x))
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F F H H
          (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
             F
             G
             F
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α))
          (@category_theory.category_struct.comp.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
             (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))
             H
             I
             H
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       x)
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I,
x : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          x)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          x))
    (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ H
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
    (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ auto_param.{0}
    (@eq.{(max u₁ v₃)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
                (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
                (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I))
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    ext, rw [←nat_trans.exchange], simp, refl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.nat_trans.exchange'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {I J K : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (γ : @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) I J) (δ : @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) J K), @eq.{(max u₁ v₃)+1} (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F I) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H K)) (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H I K (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) (@category_theory.category_struct.comp.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)) I J K γ δ)) (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F I) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G J) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H K) (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G I J α γ) (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G H J K β δ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I
⊢ auto_param.{0}
    (@eq.{(max u₁ v₃)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
                (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
                (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I))
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I,
x : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          x)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          x))
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.category_struct.comp.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F I H
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β))
          (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G H I
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       x)
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I,
x : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          x)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          x))
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.nat_trans.hcomp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G G I I
          (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
             G
             F
             G
             (@category_theory.iso.inv.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α)
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                F
                G
                α))
          (@category_theory.category_struct.comp.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
             (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
             (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))
             I
             H
             I
             (@category_theory.iso.inv.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)
             (@category_theory.iso.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
                (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
                H
                I
                β)))
       x)
    (@category_theory.nat_trans.app.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
       (@category_theory.category_struct.id.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
          (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
          (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)}
             (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ)
             (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
E : Type u₃,
ℰ : category_theory.category.{v₃ u₃} E,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
H I : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ,
α :
  @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    F
    G,
β :
  @category_theory.iso.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)}
    (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ)
    H
    I,
x : C
⊢ @eq.{v₃+1}
    (@category_theory.has_hom.hom.{v₃ u₃} E
       (@category_theory.category_struct.to_has_hom.{v₃ u₃} E
          (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ))
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          x)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          x))
    (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ I
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G x)))
    (@category_theory.category_struct.id.{v₃ u₃} E (@category_theory.category.to_category_struct.{v₃ u₃} E ℰ)
       (@category_theory.functor.obj.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ
          (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G I)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  omit ℰ</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  -- declare local notation for nat_iso.hcomp</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  localized &quot;infix ` ■ `:80 := category_theory.nat_iso.hcomp&quot; in category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  end nat_iso</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  variables {C : Type u₁} [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  def ulift_down_up : ulift_down.{v₁} C ⋙ ulift_up C ≅ 𝟭 (ulift.{u₂} C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.functor.ulift_down'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.ulift_up'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ (max u₁ u₂) u₁} (ulift.{u₂ u₁} C) (@category_theory.ulift_category.{v₁ u₁ u₂} C 𝒞) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u₁ u₂)} [𝒞 : category_theory.category.{v₁ (max u₁ u₂)} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type (max u₁ u₂)} [ℰ : category_theory.category.{v₁ (max u₁ u₂)} E], @category_theory.functor.{v₁ v₁ (max u₁ u₂) u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ (max u₁ u₂)} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ (max u₁ u₂) (max u₁ u₂)} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ (max u₁ u₂)} C 𝒞 (ulift.{u₂ u₁} C) (@category_theory.ulift_category.{v₁ u₁ u₂} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ u₁ u₂)} [_inst_1 : category_theory.category.{(max (max u₁ u₂) v₁) (max v₁ u₁ u₂)} C], C → C → Type (max (max u₁ u₂) v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u₁ u₂)) [𝒞 : category_theory.category.{v₁ (max u₁ u₂)} C], @category_theory.functor.{v₁ v₁ (max u₁ u₂) (max u₁ u₂)} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type s → Type (max s r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  { hom := { app := λ X, @category_struct.id (ulift.{u₂} C) _ X },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ulift.{u₂ u₁} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] (X : obj), @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type s → Type (max s r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ulift.{u₂ u₁} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126    inv := { app := λ X, @category_struct.id (ulift.{u₂} C) _ X } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='ulift.{u₂ u₁} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type u} [c : category_theory.category_struct.{v u} obj] (X : obj), @category_theory.has_hom.hom.{v u} obj (@category_theory.category_struct.to_has_hom.{v u} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type s → Type (max s r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='ulift.{u₂ u₁} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  def ulift_up_down : ulift_up.{v₁} C ⋙ ulift_down C ≅ 𝟭 C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='category_theory.functor.ulift_up'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.ulift_down'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ (max u₁ u₂)} C 𝒞 (ulift.{u₂ u₁} C) (@category_theory.ulift_category.{v₁ u₁ u₂} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (max u₁ u_1)} [𝒟 : category_theory.category.{v₁ (max u₁ u_1)} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₁ u₁ (max u₁ u_1)} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ (max u₁ u_1) u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ (max u₁ u₂) u₁} (ulift.{u₂ u₁} C) (@category_theory.ulift_category.{v₁ u₁ u₂} C 𝒞) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ u₁)} [_inst_1 : category_theory.category.{(max u₁ v₁) (max v₁ u₁)} C], C → C → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  { hom := { app := λ X, 𝟙 X },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    inv := { app := λ X, 𝟙 X } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  end category_theory</code></pre>
</body>